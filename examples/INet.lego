-- INet.lego: Interaction Net Language
-- Core primitives for optimal reduction
--
-- DESIGN:
--   Agents (nodes) have a principal port and auxiliary ports
--   Interaction happens only between principal ports
--   Lafont's 3 fundamental agents: γ (constructor), δ (duplicator), ε (eraser)
--
-- COMPILATION TARGET:
--   INet → RewriteMachine via INet2RewriteMachine.lego

import Base

lang INet (Base) :=

-----------------------------------------------------
-- Agents (nodes with ports)
-----------------------------------------------------
piece Agents
  agent ::= "(" "agent" name nat ")"    -- agent name arity
  port  ::= "(" "port" name nat ")"     -- port of agent at index
          | "(" "principal" name ")"    -- principal port (port 0)

-----------------------------------------------------
-- Wiring (connections between ports)
-----------------------------------------------------
piece Wiring
  wire ::= "(" "wire" port port ")"     -- symmetric connection
  net  ::= "(" "net" netelem* ")"       -- network of elements
  netelem ::= agent | wire

-----------------------------------------------------
-- Lafont's Fundamental Agents
-----------------------------------------------------
piece Lafont
-- era: eraser, 0 auxiliary ports
  era ::= "ε" | "(era)"
  -- dup: duplicator, 2 auxiliary ports  
  dup ::= "δ" | "(dup)"
  -- con: constructor, 2 auxiliary ports
  con ::= "γ" | "(con)"

prelude:
  def era = (agent era 0)
  def dup = (agent dup 2)
  def con = (agent con 2)

-----------------------------------------------------
-- Lambda Encoding (interaction combinators)
-----------------------------------------------------
piece LambdaEncoding
  lam_node ::= "@λ" | "(lam-node)"      -- lambda: 2 aux ports (binder, body)
  app_node ::= "@@" | "(app-node)"      -- application: 2 aux ports (func, arg)

prelude:
  def lamNode = (agent lam 2)
  def appNode = (agent app 2)

-----------------------------------------------------
-- Interaction Rules (principal port reduction)
-----------------------------------------------------
piece Interaction
  interact ::= "(" "interact" agent agent ")"
    
-- Annihilation: same type agents
rule annihilate_con:
  (interact (con) (con)) ~> (net)
  
rule annihilate_dup:  
  (interact (dup) (dup)) ~> (net)

-- Commutation: different type agents
-- δ ⊗ γ → cross-wiring
rule commute_dup_con:
  (interact (dup) (con)) ~>
    (net
      (con a) (con b)
      (dup c) (dup d)
      (wire (port a 1) (port c 1))
      (wire (port a 2) (port d 1))
      (wire (port b 1) (port c 2))
      (wire (port b 2) (port d 2)))

-- Erasure: ε erases anything
rule erase_con:
  (interact (era) (con)) ~>
    (net (era) (era))
    
rule erase_dup:
  (interact (era) (dup)) ~>
    (net (era) (era))

-- Beta reduction (lambda/app interaction)
rule beta:
  (interact (app-node) (lam-node)) ~>
    (net
      (wire (port app 1) (port lam 1))   -- func's binder to arg
      (wire (port app 2) (port lam 2)))  -- result to body

-----------------------------------------------------
-- Network Operations
-----------------------------------------------------
piece NetOps
-- Find active pair (two connected principal ports)
rule findRedex:
  (findRedex (net $agents $wires)) ~>
    (findActivePair $wires)
    
-- Step: reduce one active pair
rule step:
  (step (net $es)) ~>
    (reduce (findRedex (net $es)) (net $es))

-----------------------------------------------------
-- Encoding Lambda Terms to INet
-----------------------------------------------------
piece LambdaToINet
-- Variable: just a wire endpoint
rule encode_var:
  (toINet (var $x)) ~> (port $x principal)

-- Lambda: create @λ node
rule encode_lam:
  (toINet (lam $x $body)) ~>
    (let n (fresh 1)
      (net
        (node lam n)
        (bind $x (port n 1))
        (wire (toINet $body) (port n 2))))

-- Application: create @@ node
rule encode_app:
  (toINet (app $f $a)) ~>
    (let n (fresh 1)
      (net
        (node app n)
        (wire (toINet $f) (port n 1))
        (wire (toINet $a) (port n 2))))

-----------------------------------------------------
-- Tests (TODO: prelude def expansion not yet implemented)
-----------------------------------------------------
test "era_agent": era ~~> (agent era 0)
test "dup_agent": dup ~~> (agent dup 2)
test "con_agent": con ~~> (agent con 2)

-- =============================================================================
-- TODO: Executable Language Checklist for INet
-- =============================================================================
-- [ ] Normalize: reduction rules
-- [ ] Keywords: cuts := ["piece", "rule", "test", "def"]
-- =============================================================================
-- TODO: INet needs reduction rules
