-----------------------------------------------------
-- CoolttCubical: Cubical Type Theory Foundations
--
-- This defines the mathematical foundations of cooltt's
-- cartesian cubical type theory, including:
-- - Interval operations
-- - Cofibrations (face lattice)
-- - Extension types
-- - Coercion and composition
-- - V types (univalence)
-----------------------------------------------------

-----------------------------------------------------
-- The Interval ð•€
-----------------------------------------------------

piece Interval
  -- The interval type ð•€ has two endpoints 0 and 1
  -- and is closed under reversal and connection operations
  
  dim ::= ð•€                               -- The interval type
  endpoint ::= 0 | 1                       -- Endpoints
  
  -- Reversal: 1-i
  rev ::= i => (1 - i)
  
  -- In cooltt, we work with the cartesian cube category
  -- ð•€ is NOT a type in the usual sense - it's a "dimension"

-----------------------------------------------------
-- Cofibrations (Face Lattice)
-----------------------------------------------------

piece Cofibrations
  -- Cofibrations are propositions built from:
  -- - (i = 0) and (i = 1) for dimension i
  -- - âŠ¤ (true) and âŠ¥ (false)
  -- - âˆ§ (meet) and âˆ¨ (join)
  
  coftype ::= ð”½                           -- Cofibration type
  
  -- Basic face constraints
  face ::= (i = 0)                         -- Left face
         | (i = 1)                         -- Right face
  
  -- Boundary: âˆ‚i = (i=0) âˆ¨ (i=1)
  boundary ::= âˆ‚ i                         -- Either endpoint
  
  -- Lattice operations
  meet ::= Ï† âˆ§ Ïˆ                          -- Both conditions
  join ::= Ï† âˆ¨ Ïˆ                          -- Either condition
  
  -- The face lattice is NOT Boolean:
  -- Â¬(i=0) is NOT (i=1)
  -- Instead we have a de Morgan algebra

-----------------------------------------------------
-- Extension Types
-----------------------------------------------------

piece ExtensionTypes
  -- The extension type [Î“, i:ð•€] A [Ï† â†¦ u]
  -- consists of elements a : A(i) such that a = u when Ï† holds
  
  -- Syntax: ext i => A with [Ï† => u]
  ext ::= ext vars => body with bdry
  vars ::= name+
  bdry ::= "[" constraints "]"
  constraints ::= ("|"? constraint)*
  constraint ::= cofibration "=>" term
  
  -- Path types are a special case:
  -- path A a b := ext i => A with [i=0 => a | i=1 => b]
  
  -- Dependent path:
  -- path-p (i => A i) a b := ext i => A i with [i=0 => a | i=1 => b]

-----------------------------------------------------
-- Sub Types (Partial Elements)
-----------------------------------------------------

piece SubTypes
  -- sub A Ï† a : the type of elements of A that are
  -- definitionally equal to a when Ï† holds
  
  -- Formation: sub A Ï† a
  -- This is similar to extension but "checking" form
  
  -- Example: (x : sub nat (i=0) 5) is a nat that equals 5 when i=0
  
  sub ::= sub type cofibration term

-----------------------------------------------------
-- Coercion (coe)
-----------------------------------------------------

piece Coercion
  -- coe : (i:ð•€ â†’ type) â†’ (r s : ð•€) â†’ A(r) â†’ A(s)
  -- Transport along a line of types
  
  coe ::= coe family src tgt element
  
  -- Key computation rule:
  -- coe (i => A) r r a = a  (reflexivity)
  
  -- Coercion through type formers:
  
  rule coe_pi:
    coe (i => (x : A i) -> B i x) r s f
      ~> Î»x. coe (i => B i (coe (j => A j) s i x)) r s 
             (f (coe (i => A i) s r x))
  
  rule coe_sg:
    coe (i => (x : A i) Ã— B i x) r s (a, b)
      ~> (coe (i => A i) r s a, 
          coe (i => B i (coe (j => A j) r i a)) r s b)
  
  rule coe_path:
    coe (i => path (A i) (a i) (b i)) r s p
      ~> Î»j. com (i => A i) r s (j=0 âˆ¨ j=1) 
             [j=0 i => a i | j=1 i => b i | ... => p j]

-----------------------------------------------------
-- Homogeneous Composition (hcom)
-----------------------------------------------------

piece HCom
  -- hcom : (A : type) â†’ (r s : ð•€) â†’ (Ï† : ð”½) â†’ 
  --        (u : (i:ð•€) â†’ Partial Ï† A) â†’ A
  -- with u(s) = hcom A r s Ï† u  when Ï† holds
  
  hcom ::= hcom type src tgt cof tube
  
  -- The tube provides a partial element for each i in [r,s]
  -- The result agrees with the tube when the cofibration holds
  
  -- Example: symmetry of paths uses hcom
  -- symm p := hcom A 0 1 (âˆ‚i) [i=0 => p 0 | i=1 => p (1-i)]

-----------------------------------------------------
-- Kan Filling (hfill)
-----------------------------------------------------

piece HFill
  -- hfill is the "open box" version of hcom
  -- hfill A r Ï† u : (i:ð•€) â†’ sub A (Ï† âˆ¨ i=r) [Ï† => u i | i=r => u r]
  
  hfill ::= hfill type src cof tube
  
  -- Key property: hfill A r Ï† u 1 = hcom A r 1 Ï† u

-----------------------------------------------------
-- Heterogeneous Composition (com)
-----------------------------------------------------

piece Com
  -- com : (A : ð•€ â†’ type) â†’ (r s : ð•€) â†’ (Ï† : ð”½) â†’
  --       (u : (i:ð•€) â†’ Partial Ï† (A i)) â†’ A(s)
  
  com ::= com family src tgt cof tube
  
  -- Defined in terms of hcom and coe:
  -- com A r s Ï† u = hcom (A s) r s Ï† (i => coe A i s (u i))

-----------------------------------------------------
-- V Types (Univalence)
-----------------------------------------------------

piece VTypes
  -- V r A B e : the "glue" type for univalence
  -- - When r=0: V 0 A B e â‰ƒ A
  -- - When r=1: V 1 A B e â‰ƒ B
  -- - e : A â‰ƒ B is the equivalence witnessing the connection
  
  V ::= V dim type type equiv
  
  -- V type computation:
  rule V_zero:
    V 0 A B e ~> A
  
  rule V_one:
    V 1 A B e ~> B
  
  -- Introduction: given a:A and b:B such that e a = b
  vin ::= [a, b]  -- pair in V type
  
  -- Elimination: vproj extracts the B component
  vproj ::= vproj term
  
  -- vproj [a, b] = b when r=1
  
  -- cap: extracts boundary info
  cap ::= cap term
  
  -- Univalence: the map ua : (A â‰ƒ B) â†’ (A = B) is given by
  -- ua e := i => V i A B e

-----------------------------------------------------
-- Derived Operations
-----------------------------------------------------

piece DerivedOps
  -- path : type â†’ term â†’ term â†’ type
  path ::= ext i => A with [i=0 => a | i=1 => b]
  
  -- path-p : (ð•€ â†’ type) â†’ term â†’ term â†’ type  
  pathp ::= ext i => A i with [i=0 => a | i=1 => b]
  
  -- refl : path A a a
  refl ::= i => a
  
  -- symm : path A a b â†’ path A b a
  symm ::= hfill A 0 (âˆ‚ i) [i=0 => p j | i=1 => p 0]
  
  -- trans : path A a b â†’ path A b c â†’ path A a c
  trans ::= hcom A 0 1 (âˆ‚ i) [i=0 => p j | i=1 => q j]
  
  -- ap/cong : (f : A â†’ B) â†’ path A a a' â†’ path B (f a) (f a')
  cong ::= i => f (p i)
  
  -- funext : ((x:A) â†’ path B (f x) (g x)) â†’ path (Aâ†’B) f g
  funext ::= i x => h x i
  
  -- transport : path type A B â†’ A â†’ B
  transport ::= coe (i => p i) 0 1

-----------------------------------------------------
-- Kan Operations Laws
-----------------------------------------------------

piece KanLaws
  -- Reflexivity laws (endpoints equal):
  rule coe_refl:
    coe A r r a ~> a
  
  rule hcom_refl:
    hcom A r r Ï† u ~> u r
  
  rule com_refl:
    com A r r Ï† u ~> u r
  
  -- Boundary conditions:
  rule hcom_boundary:
    hcom A r s Ï† u ~> u s   when Ï† holds
  
  rule com_boundary:
    com A r s Ï† u ~> u s    when Ï† holds
  
  -- Connection with hfill:
  rule hfill_endpoint:
    hfill A r Ï† u 1 ~> hcom A r 1 Ï† u

-----------------------------------------------------
-- Tests
-----------------------------------------------------

piece Tests
  -- Path types
  test "path_type": ext i => A with [i=0 => a | i=1 => b]
    ~~> ext i => A with [i=0 => a | i=1 => b]
  
  test "refl": i => x ~~> i => x
  
  -- Coercion
  test "coe_refl": coe (i => A) 0 0 a ~~> a
  test "coe_refl_one": coe (i => A) 1 1 a ~~> a
  
  -- V types
  test "V_zero": V 0 A B e ~~> A
  test "V_one": V 1 A B e ~~> B

