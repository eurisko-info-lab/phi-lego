-----------------------------------------------------
-- CoolttExamples: Parsed examples from cooltt test suite
--
-- These are real cooltt code samples parsed into 
-- the Lego representation, demonstrating the full
-- grammar coverage.
-----------------------------------------------------

import Cooltt
import CoolttAST
import CoolttCubical

-----------------------------------------------------
-- Example 1: Prelude (path types)
-----------------------------------------------------

piece PreludeExamples

  -- def path (A : type) (x y : A) : type :=
  --   ext i => A with [i=0 => x | i=1 => y]
  example "path":
    Def {
      abstract: false,
      shadowing: false,
      name: `User ["path"],
      args: [
        Cell {names: [`User ["A"]], tp: Type},
        Cell {names: [`User ["x"], `User ["y"]], tp: Var (`User ["A"])}
      ],
      def: Ext [`User ["i"]] 
           (Var (`User ["A"])) 
           [(CofEq (Var (`User ["i"])) (Lit 0), Var (`User ["x"])),
            (CofEq (Var (`User ["i"])) (Lit 1), Var (`User ["y"]))],
      tp: Type,
      unfolding: []
    }

  -- def path-p (A : ð•€ â†’ type) (x : A 0) (y : A 1) : type :=
  --   ext i => A i with [i=0 => x | i=1 => y]
  example "path-p":
    Def {
      abstract: false,
      shadowing: false,
      name: `User ["path-p"],
      args: [
        Cell {names: [`User ["A"]], tp: Pi [Cell {names: [`Anon], tp: Dim}] Type},
        Cell {names: [`User ["x"]], tp: Ap (Var (`User ["A"])) [Lit 0]},
        Cell {names: [`User ["y"]], tp: Ap (Var (`User ["A"])) [Lit 1]}
      ],
      def: Ext [`User ["i"]] 
           (Ap (Var (`User ["A"])) [Var (`User ["i"])])
           [(CofEq (Var (`User ["i"])) (Lit 0), Var (`User ["x"])),
            (CofEq (Var (`User ["i"])) (Lit 1), Var (`User ["y"]))],
      tp: Type,
      unfolding: []
    }

  -- def refl (A : type) (x : A) : path A x x :=
  --   i => x
  example "refl":
    Def {
      abstract: false,
      shadowing: false,
      name: `User ["refl"],
      args: [
        Cell {names: [`User ["A"]], tp: Type},
        Cell {names: [`User ["x"]], tp: Var (`User ["A"])}
      ],
      def: Lam [`User ["i"]] (Var (`User ["x"])),
      tp: Ap (Var (`User ["path"])) [Var (`User ["A"]), Var (`User ["x"]), Var (`User ["x"])],
      unfolding: []
    }

-----------------------------------------------------
-- Example 2: Natural Numbers
-----------------------------------------------------

piece NatExamples

  -- abstract
  -- def + : nat â†’ nat â†’ nat :=
  --   elim [
  --   | zero => n => n
  --   | suc {_ => ih} => n => suc {ih n}
  --   ]
  example "plus":
    Def {
      abstract: true,
      shadowing: false,
      name: `User ["+"],
      args: [],
      def: LamElim [
        (Pat {lbl: ["zero"], args: []}, 
         Lam [`User ["n"]] (Var (`User ["n"]))),
        (Pat {lbl: ["suc"], args: [`Inductive (`Anon, `User ["ih"])]},
         Lam [`User ["n"]] (Suc (Ap (Var (`User ["ih"])) [Var (`User ["n"])])))
      ],
      tp: Pi [Cell {names: [`Anon], tp: Nat}] 
            (Pi [Cell {names: [`Anon], tp: Nat}] Nat),
      unfolding: []
    }

  -- #print +
  example "print_plus":
    Print {unfolding: [], name: {node: `User ["+"], info: None}}

  -- #normalize + 2 3
  example "normalize_plus":
    NormalizeTerm {
      unfolding: [],
      con: Ap (Var (`User ["+"])) [Lit 2, Lit 3]
    }

  -- unfold + in ...
  example "unfold_in":
    Unfold [`User ["+"]] (Ap (Var (`User ["+"])) [Lit 2, Lit 3])

-----------------------------------------------------
-- Example 3: Circle and Loops
-----------------------------------------------------

piece CircleExamples

  -- def Î©1s1 : type :=
  --   path circle base base
  example "loop_space":
    Def {
      abstract: false,
      shadowing: false,
      name: `User ["Î©1s1"],
      args: [],
      def: Ap (Var (`User ["path"])) [Circle, Base, Base],
      tp: Type,
      unfolding: []
    }

  -- def loopn : nat -> Î©1s1 :=
  --   elim [
  --   | zero => _ => base
  --   | suc {n => loopn} =>
  --     i =>
  --     hcom circle 0 1 {âˆ‚ i} {k =>
  --       [ k=0 => loopn i
  --       | i=0 => base
  --       | i=1 => loop k
  --       ]
  --     }
  --   ]
  example "loopn":
    Def {
      abstract: false,
      shadowing: false,
      name: `User ["loopn"],
      args: [],
      def: LamElim [
        (Pat {lbl: ["zero"], args: []},
         Lam [`Anon] Base),
        (Pat {lbl: ["suc"], args: [`Inductive (`User ["n"], `User ["loopn"])]},
         Lam [`User ["i"]] 
           (HCom Circle (Lit 0) (Lit 1) 
                 (CofBoundary (Var (`User ["i"])))
                 (Lam [`User ["k"]] 
                   (CofSplit [
                     (CofEq (Var (`User ["k"])) (Lit 0), 
                      Ap (Var (`User ["loopn"])) [Var (`User ["i"])]),
                     (CofEq (Var (`User ["i"])) (Lit 0), Base),
                     (CofEq (Var (`User ["i"])) (Lit 1), 
                      Loop (Var (`User ["k"])))]))))
      ],
      tp: Pi [Cell {names: [`Anon], tp: Nat}] (Var (`User ["Î©1s1"])),
      unfolding: []
    }

-----------------------------------------------------
-- Example 4: Records
-----------------------------------------------------

piece RecordExamples

  -- def basic : type :=
  --   sig
  --     def foo::x : nat
  --     def bar : nat â†’ nat
  --   end
  example "sig_basic":
    Def {
      abstract: false,
      shadowing: false,
      name: `User ["basic"],
      args: [],
      def: Signature [
        `Field (`User ["foo", "x"], Nat),
        `Field (`User ["bar"], Pi [Cell {names: [`Anon], tp: Nat}] Nat)
      ],
      tp: Type,
      unfolding: []
    }

  -- def basic::inhabit : basic := struct [foo::x := 1, bar := x => suc x]
  example "struct_inhabit":
    Def {
      abstract: false,
      shadowing: false,
      name: `User ["basic", "inhabit"],
      args: [],
      def: Struct [
        `Field (`User ["foo", "x"], Lit 1),
        `Field (`User ["bar"], Lam [`User ["x"]] (Suc (Var (`User ["x"]))))
      ],
      tp: Var (`User ["basic"]),
      unfolding: []
    }

  -- #normalize basic::inhabit.foo::x
  example "proj_normalize":
    NormalizeTerm {
      unfolding: [],
      con: Proj (Var (`User ["basic", "inhabit"])) (`User ["foo", "x"])
    }

  -- def basic/ext with paths
  example "sig_ext":
    Def {
      abstract: false,
      shadowing: false,
      name: `User ["basic/ext"],
      args: [
        Cell {names: [`User ["b0"], `User ["b1"]], tp: Var (`User ["basic"])},
        Cell {names: [`User ["p"]], 
              tp: Ap (Var (`User ["path"])) [Nat, 
                    Proj (Var (`User ["b0"])) (`User ["foo", "x"]),
                    Proj (Var (`User ["b1"])) (`User ["foo", "x"])]},
        Cell {names: [`User ["q"]], 
              tp: Ap (Var (`User ["path"])) [
                    Pi [Cell {names: [`Anon], tp: Nat}] Nat,
                    Proj (Var (`User ["b0"])) (`User ["bar"]),
                    Proj (Var (`User ["b1"])) (`User ["bar"])]}
      ],
      def: Lam [`User ["i"]] 
           (Struct [
             `Field (`User ["foo", "x"], 
                    Ap (Var (`User ["p"])) [Var (`User ["i"])]),
             `Field (`User ["bar"], 
                    Ap (Var (`User ["q"])) [Var (`User ["i"])])
           ]),
      tp: Ap (Var (`User ["path"])) [
            Var (`User ["basic"]), 
            Var (`User ["b0"]), 
            Var (`User ["b1"])],
      unfolding: []
    }

-----------------------------------------------------
-- Example 5: Coercion
-----------------------------------------------------

piece CoercionExamples

  -- def coe/fwd (A : ð•€ â†’ type) (x : A 0) : A 1 :=
  --   coe A 0 1 x
  example "coe_fwd":
    Def {
      abstract: false,
      shadowing: false,
      name: `User ["coe/fwd"],
      args: [
        Cell {names: [`User ["A"]], tp: Pi [Cell {names: [`Anon], tp: Dim}] Type},
        Cell {names: [`User ["x"]], tp: Ap (Var (`User ["A"])) [Lit 0]}
      ],
      def: Coe (Var (`User ["A"])) (Lit 0) (Lit 1) (Var (`User ["x"])),
      tp: Ap (Var (`User ["A"])) [Lit 1],
      unfolding: []
    }

  -- def transport/fwd (A : type) (B : A â†’ type) (p : ð•€ â†’ A) (x : B {p 0}) : B {p 1} :=
  --   coe/fwd {i => B {p i}} x
  example "transport_fwd":
    Def {
      abstract: false,
      shadowing: false,
      name: `User ["transport/fwd"],
      args: [
        Cell {names: [`User ["A"]], tp: Type},
        Cell {names: [`User ["B"]], tp: Pi [Cell {names: [`Anon], tp: Var (`User ["A"])}] Type},
        Cell {names: [`User ["p"]], tp: Pi [Cell {names: [`Anon], tp: Dim}] (Var (`User ["A"]))},
        Cell {names: [`User ["x"]], tp: Ap (Var (`User ["B"])) [Ap (Var (`User ["p"])) [Lit 0]]}
      ],
      def: Ap (Var (`User ["coe/fwd"])) [
        Lam [`User ["i"]] (Ap (Var (`User ["B"])) [Ap (Var (`User ["p"])) [Var (`User ["i"])]]),
        Var (`User ["x"])
      ],
      tp: Ap (Var (`User ["B"])) [Ap (Var (`User ["p"])) [Lit 1]],
      unfolding: []
    }

-----------------------------------------------------
-- Example 6: Sections and Modules
-----------------------------------------------------

piece SectionExamples

  -- section x1::y1 begin
  --   def a1 : nat := 0
  -- end
  example "section_prefix":
    Section {
      shadowing: false,
      prefix: Some ["x1", "y1"],
      decls: [
        Def {
          abstract: false, shadowing: false,
          name: `User ["a1"], args: [],
          def: Lit 0, tp: Nat, unfolding: []
        }
      ],
      modifier: None
    }

  -- section begin def a2 : nat := 10 end
  example "section_no_prefix":
    Section {
      shadowing: false,
      prefix: None,
      decls: [
        Def {
          abstract: false, shadowing: false,
          name: `User ["a2"], args: [],
          def: Lit 10, tp: Nat, unfolding: []
        }
      ],
      modifier: None
    }

  -- shadowing section begin
  --   shadowing def a3 : nat := 30
  -- end
  example "section_shadowing":
    Section {
      shadowing: true,
      prefix: None,
      decls: [
        Def {
          abstract: false, shadowing: true,
          name: `User ["a3"], args: [],
          def: Lit 30, tp: Nat, unfolding: []
        }
      ],
      modifier: None
    }

  -- section x4 begin def a4 : nat := 40 end [ a4 -> b4 ]
  example "section_rename":
    Section {
      shadowing: false,
      prefix: Some ["x4"],
      decls: [
        Def {
          abstract: false, shadowing: false,
          name: `User ["a4"], args: [],
          def: Lit 40, tp: Nat, unfolding: []
        }
      ],
      modifier: Some (ModRename ["a4"] ["b4"])
    }

  -- view [?]
  example "view_all":
    View {shadowing: false, modifier: ModPrint {name: None, silent: false}}

-----------------------------------------------------
-- Example 7: Equations
-----------------------------------------------------

piece EquationExamples

  -- equation nat begin
  --   + {suc y} 0 =[ +-suc-l y 0 ]
  --   suc {+ y 0} =[ i => suc {ih i} ]
  --   suc y
  -- end
  example "equation_basic":
    Equations {
      code: Nat,
      eqns: Step (Equals (
        Ap (Var (`User ["+"])) [Suc (Var (`User ["y"])), Lit 0],
        Ap (Var (`User ["+-suc-l"])) [Var (`User ["y"]), Lit 0],
        Step (Equals (
          Suc (Ap (Var (`User ["+"])) [Var (`User ["y"]), Lit 0]),
          Lam [`User ["i"]] (Suc (Ap (Var (`User ["ih"])) [Var (`User ["i"])])),
          Qed (Suc (Var (`User ["y"])))
        ))
      ))
    }

-----------------------------------------------------
-- Example 8: V Types
-----------------------------------------------------

piece VTypeExamples

  -- def v-test (r : ð•€) (A : type) : type :=
  --   V r A A
  --     [ x => x
  --     , x =>
  --       [ [x, _ => x]
  --       , p i =>
  --         let aux := hfill A 1 {âˆ‚ i} {k => [ k=1 => x | i=1 => {snd p} k | i=0 => x ] } in
  --         [aux 0, aux]
  --       ]
  --     ]
  example "v_test_type":
    V (Var (`User ["r"])) 
      (Var (`User ["A"])) 
      (Var (`User ["A"]))
      -- equivalence witness (simplified)
      (Pair 
        (Lam [`User ["x"]] (Var (`User ["x"])))
        -- inverse + coherence (complex nested structure)
        (Lam [`User ["x"]] 
          (Pair 
            (Pair (Var (`User ["x"])) (Lam [`Anon] (Var (`User ["x"]))))
            -- ...
            (Underscore))))

  -- vproj t
  example "vproj":
    VProj (Var (`User ["t"]))

  -- cap t  
  example "cap":
    Cap (Var (`User ["t"]))

-----------------------------------------------------
-- Example 9: Abstract Definitions
-----------------------------------------------------

piece AbstractExamples

  -- abstract
  -- def +0L : (x : nat) â†’ path nat {+ 0 x} x :=
  --   x _ => x
  example "abstract_def":
    Def {
      abstract: true,
      shadowing: false,
      name: `User ["+0L"],
      args: [],
      def: Lam [`User ["x"], `Anon] (Var (`User ["x"])),
      tp: Pi [Cell {names: [`User ["x"]], tp: Nat}]
            (Ap (Var (`User ["path"])) [
              Nat,
              Ap (Var (`User ["+"])) [Lit 0, Var (`User ["x"])],
              Var (`User ["x"])
            ]),
      unfolding: []
    }

  -- unfold +
  -- abstract def +SL : (x y : nat) â†’ path nat {+ {suc x} y} {suc {+ x y}} :=
  --   x y _ => suc {+ x y}
  example "unfold_abstract":
    Def {
      abstract: true,
      shadowing: false,
      name: `User ["+SL"],
      args: [],
      def: Lam [`User ["x"], `User ["y"], `Anon] 
           (Suc (Ap (Var (`User ["+"])) [Var (`User ["x"]), Var (`User ["y"])])),
      tp: Pi [Cell {names: [`User ["x"], `User ["y"]], tp: Nat}]
            (Ap (Var (`User ["path"])) [
              Nat,
              Ap (Var (`User ["+"])) [Suc (Var (`User ["x"])), Var (`User ["y"])],
              Suc (Ap (Var (`User ["+"])) [Var (`User ["x"]), Var (`User ["y"])])
            ]),
      unfolding: [`User ["+"]]
    }

-----------------------------------------------------
-- Example 10: Imports
-----------------------------------------------------

piece ImportExamples

  -- import prelude
  example "import_simple":
    Import {shadowing: false, unitpath: ["prelude"], modifier: None}

  -- import cooltt-lib.data.bool
  example "import_path":
    Import {shadowing: false, unitpath: ["cooltt-lib", "data", "bool"], modifier: None}

  -- shadowing import prelude [path]
  example "import_modifier":
    Import {
      shadowing: true, 
      unitpath: ["prelude"], 
      modifier: Some (ModOnly ["path"])
    }

-----------------------------------------------------
-- Test Coverage Summary
-----------------------------------------------------

piece Coverage
  -- Terms covered:
  -- [x] Var, Underscore, Lit
  -- [x] Nat, Suc, Circle, Base, Loop
  -- [x] Type, Dim, Cof
  -- [x] Pi, Lam, Ap
  -- [x] Sg, Pair, Fst, Snd, Proj
  -- [x] Signature, Struct
  -- [x] Let, Ann
  -- [x] LamElim with patterns
  -- [x] Ext, Sub
  -- [x] CofEq, CofBoundary, CofSplit, Join, Meet, TopC, BotC
  -- [x] Coe, HCom, HFill, Com
  -- [x] V, VProj, Cap
  -- [x] Equations
  -- [x] Unfold, Generalize
  -- [x] Hole, BoundaryHole
  
  -- Declarations covered:
  -- [x] Def (with abstract, shadowing, unfolding)
  -- [x] Axiom
  -- [x] Import (with modifiers)
  -- [x] Print, NormalizeTerm
  -- [x] Section (with prefix, modifier)
  -- [x] View, Export, Repack
  -- [x] Fail, Debug, Quit

