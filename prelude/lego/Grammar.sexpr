(grammar
  (prod "Atom.char" (node char))
  (prod "Atom.chars" (star (node char)))
  (prod "Atom.ident" (node identifier))
  (prod "Atom.metavar" (seq (lit $) (ref Atom.ident)))
  (prod "Atom.number" (node digits))
  (prod "Atom.regex" (node regex))
  (prod "Atom.string" (node string))
  (prod "File.autocutDecl" (node DAutocut (seq (cut (lit @autocut)) (ref Atom.ident))))
  (prod "File.commentDecl" (node DComment (node comment (seq (lit --) (ref File.commentText)))))
  (prod "File.commentText" (star (node char)))
  (prod "File.defDecl" (node DDef (seq (cut (lit def)) (ref Atom.ident) (lit =) (ref Term.term))))
  (prod "File.emptyParents" (ref File.ε))
  (prod "File.fileDecl" (alt (ref File.langDecl) (ref File.importDecl) (ref File.grammarDecl) (ref File.pieceDecl) (ref File.ruleDecl) (ref File.testDecl) (ref File.lawDecl) (ref File.inheritDecl) (ref File.autocutDecl) (ref File.defDecl) (ref File.commentDecl)))
  (prod "File.fileDeclWithWs" (seq (ref File.fileDecl) (alt (ref File.whitespace) (empty))))
  (prod "File.grammarDecl" (seq (cut (lit grammar)) (lit :) (star (ref File.grammarProd))))
  (prod "File.grammarProd" (seq (alt (ref File.whitespace) (empty)) (ref Atom.ident) (lit ::=) (ref GrammarExpr.grammarExpr) (alt (ref File.whitespace) (empty))))
  (prod "File.importDecl" (node DImport (seq (cut (lit import)) (ref Atom.ident))))
  (prod "File.inheritDecl" (node DInherit (seq (cut (lit inherit)) (ref File.qualIdent))))
  (prod "File.langDecl" (node DLang (seq (cut (lit lang)) (ref Atom.ident) (ref File.langParentsOpt) (lit :=) (ref File.langDirectBody))))
  (prod "File.langDirectBody" (seq (alt (ref File.whitespace) (empty)) (star (ref File.langItemWithWs))))
  (prod "File.langItem" (alt (ref File.importDecl) (ref File.grammarDecl) (ref File.pieceDecl) (ref File.ruleDecl) (ref File.ruleStub) (ref File.testDecl) (ref File.lawDecl) (ref File.inheritDecl) (ref File.autocutDecl) (ref File.defDecl) (ref File.sectionMarker)))
  (prod "File.langItemWithWs" (seq (ref File.langItem) (alt (ref File.whitespace) (empty))))
  (prod "File.langParents" (seq (lit "(") (ref Atom.ident) (star (ref File.moreParents)) (lit ")")))
  (prod "File.langParentsOpt" (ref File.langParents))
  (prod "File.lawDecl" (node DLaw (seq (cut (lit law)) (ref Atom.string) (lit :) (ref Term.term) (ref File.lawOp) (ref Term.term))))
  (prod "File.lawOp" (alt (lit ≅) (lit ==)))
  (prod "File.legoFile" (seq (alt (ref File.whitespace) (empty)) (star (ref File.fileDeclWithWs))))
  (prod "File.moreParents" (seq (lit ,) (ref Atom.ident)))
  (prod "File.pieceDecl" (seq (cut (lit piece)) (ref Atom.ident) (alt (ref File.whitespace) (empty)) (star (ref File.pieceItem))))
  (prod "File.pieceItem" (ref File.productionWithWs))
  (prod "File.productionWithWs" (seq (ref GrammarExpr.production) (alt (ref File.whitespace) (empty))))
  (prod "File.qualIdent" (seq (ref Atom.ident) (star (seq (lit .) (ref Atom.ident)))))
  (prod "File.ruleDecl" (node DRule (seq (cut (lit rule)) (ref Atom.ident) (lit :) (alt (ref File.whitespace) (empty)) (ref Pattern.pattern) (lit ~>) (alt (ref File.whitespace) (empty)) (ref Template.template))))
  (prod "File.ruleStub" (seq (cut (lit rule)) (ref Atom.ident) (lit :)))
  (prod "File.sectionMarker" (seq (ref File.sectionName) (lit :)))
  (prod "File.sectionName" (alt (lit prelude) (lit code)))
  (prod "File.testDecl" (node DTest (seq (cut (lit test)) (ref Atom.string) (lit :) (ref Term.term) (alt (ref File.testExpected) (empty)) (alt (ref File.testOpts) (empty)))))
  (prod "File.testExpected" (alt (ref File.testExpectedArrow) (ref File.testExpectedDouble)))
  (prod "File.testExpectedArrow" (seq (alt (ref File.whitespace) (empty)) (lit ~~>) (alt (ref File.whitespace) (empty)) (ref Term.term)))
  (prod "File.testExpectedDouble" (seq (alt (ref File.whitespace) (empty)) (lit ==>) (alt (ref File.whitespace) (empty)) (ref Term.term)))
  (prod "File.testOpt" (alt (seq (lit via) (ref Atom.ident)) (seq (lit steps) (ref Atom.number)) (seq (lit error) (ref Atom.string))))
  (prod "File.testOpts" (seq (ref File.testOpt) (star (ref File.testOpt))))
  (prod "File.whitespace" (star (ref File.wsItem)))
  (prod "File.wsItem" (alt (node newline) (node indent)))
  (prod "GrammarExpr.altBranch" (seq (ref GrammarExpr.grammarSeq) (lit |) (ref GrammarExpr.grammarAlt)))
  (prod "GrammarExpr.grammarAlt" (alt (ref GrammarExpr.altBranch) (ref GrammarExpr.grammarSeq)))
  (prod "GrammarExpr.grammarAtom" (alt (node litAtom (ref Atom.string)) (node regexAtom (ref Atom.regex)) (node charAtom (ref Atom.char)) (node captureAtom (seq (lit $) (alt (ref Atom.ident) (ref Atom.string)))) (node namedStarAtom (seq (ref Atom.ident) (lit :) (star (ref Atom.ident)))) (node namedRefAtom (seq (ref Atom.ident) (lit :) (ref Atom.ident))) (node groupAtom (seq (lit "(") (ref GrammarExpr.grammarExpr) (lit ")"))) (node optGroupAtom (seq (lit [) (ref GrammarExpr.grammarExpr) (lit ]))) (node refAtom (ref Atom.ident)) (node specialAtom (seq (lit <) (ref Atom.ident) (lit >))) (node recAtom (seq (lit μ) (ref Atom.ident) (lit .) (ref GrammarExpr.grammarExpr))) (node emptyAtom (lit ε))))
  (prod "GrammarExpr.grammarExpr" (ref GrammarExpr.grammarAlt))
  (prod "GrammarExpr.grammarSeq" (alt (ref GrammarExpr.seqHead) (ref GrammarExpr.grammarSuffix)))
  (prod "GrammarExpr.grammarSuffix" (alt (node cutSuffix (cut (ref GrammarExpr.grammarAtom))) (node starSuffix (star (ref GrammarExpr.grammarAtom))) (node plusSuffix (seq (ref GrammarExpr.grammarAtom) (star (ref GrammarExpr.grammarAtom)))) (node optSuffix (alt (ref GrammarExpr.grammarAtom) (empty))) (ref GrammarExpr.grammarAtom)))
  (prod "GrammarExpr.grammarWhitespace" (star (alt (node newline) (node indent))))
  (prod "GrammarExpr.production" (seq (ref Atom.ident) (lit ::=) (ref GrammarExpr.grammarExpr)))
  (prod "GrammarExpr.seqHead" (seq (ref GrammarExpr.grammarSuffix) (ref GrammarExpr.grammarSeq)))
  (prod "Law.law" (alt (seq (lit law) (ref Atom.string) (lit :) (ref Term.term) (lit ≅) (ref Term.term)) (seq (lit law) (ref Atom.string) (lit :) (ref Term.term) (lit ==) (ref Term.term))))
  (prod "Pattern.pattern" (alt (node metavar (seq (lit $) (ref Atom.ident))) (node λᵢ (seq (lit "(") (lit λᵢ) (ref Pattern.pattern) (lit .) (ref Pattern.pattern) (lit ")"))) (node constructor (ref Pattern.pattern)) (node λᵢ (seq (lit λᵢ) (ref Pattern.pattern) (lit .) (ref Pattern.pattern))) (node pstr (ref Atom.string)) (node litIdent (ref Atom.ident))))
  (prod "Rule.backwardRule" (seq (ref Pattern.pattern) (lit <~) (ref Template.template) (alt (ref Rule.guard) (empty))))
  (prod "Rule.bidiRule" (seq (ref Pattern.pattern) (lit <~>) (ref Template.template) (alt (ref Rule.guard) (empty))))
  (prod "Rule.forwardRule" (seq (ref Pattern.pattern) (lit ~>) (ref Template.template) (alt (ref Rule.guard) (empty))))
  (prod "Rule.guard" (seq (lit when) (ref Term.term)))
  (prod "Rule.rule" (alt (ref Rule.forwardRule) (ref Rule.backwardRule) (ref Rule.bidiRule)))
  (prod "Template.template" (alt (node metavar (seq (lit $) (ref Atom.ident))) (node subst (seq (lit [) (ref Atom.ident) (lit :=) (ref Template.template) (lit ]) (ref Template.template))) (node λᵢ (seq (lit "(") (lit λᵢ) (ref Template.template) (lit .) (ref Template.template) (lit ")"))) (node lam (seq (lit "(") (lit λ) (ref Atom.ident) (lit .) (ref Template.template) (lit ")"))) (node constructor (ref Template.template)) (node λᵢ (seq (lit λᵢ) (ref Template.template) (lit .) (ref Template.template))) (node lam (seq (lit λ) (ref Atom.ident) (lit .) (ref Template.template))) (node tstr (ref Atom.string)) (node litIdent (ref Atom.ident))))
  (prod "Term.term" (alt (node metavar (seq (lit $) (ref Atom.ident))) (node hole (seq (lit ?) (ref Atom.ident))) (node proj (seq (lit .) (ref Atom.ident))) (node λᵢ (seq (lit "(") (lit λᵢ) (ref Atom.ident) (lit .) (ref Term.term) (lit ")"))) (node lam (seq (lit "(") (lit λ) (ref Atom.ident) (lit .) (ref Term.term) (lit ")"))) (node Π (seq (lit "(") (lit Π) (ref Term.typedBinder) (lit .) (ref Term.term) (lit ")"))) (node Σ (seq (lit "(") (lit Σ) (ref Term.typedBinder) (lit .) (ref Term.term) (lit ")"))) (node ∀ (seq (lit "(") (lit ∀) (ref Term.typedBinder) (lit .) (ref Term.term) (lit ")"))) (node constructor (ref Term.term)) (node λᵢ (seq (lit λᵢ) (ref Atom.ident) (lit .) (ref Term.term))) (node lam (seq (lit λ) (ref Atom.ident) (lit .) (ref Term.term))) (node str (ref Atom.string)) (node num (ref Atom.number)) (node var (ref Atom.ident))))
  (prod "Term.typedBinder" (node : (seq (lit "(") (ref Atom.ident) (lit :) (ref Term.term) (lit ")"))))
  (prod "Test.errorOption" (node error (seq (lit error) (ref Atom.string))))
  (prod "Test.fullTest" (seq (lit test) (ref Atom.string) (lit :) (ref Term.term) (lit ~~>) (ref Term.term) (alt (ref Test.testOptions) (empty))))
  (prod "Test.parseTest" (seq (lit test) (ref Atom.string) (lit :) (ref Term.term) (alt (ref Test.testOptions) (empty))))
  (prod "Test.stepsOption" (node steps (seq (lit steps) (ref Atom.number))))
  (prod "Test.test" (alt (ref Test.fullTest) (ref Test.parseTest)))
  (prod "Test.testOption" (alt (ref Test.viaOption) (ref Test.stepsOption) (ref Test.errorOption)))
  (prod "Test.testOptions" (seq (ref Test.testOption) (star (ref Test.testOption))))
  (prod "Test.viaOption" (node via (seq (lit via) (ref Atom.ident))))
)
