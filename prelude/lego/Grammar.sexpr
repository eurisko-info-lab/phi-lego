(grammar
  (prod "Atom.char" (node char))
  (prod "Atom.chars" (star (node char)))
  (prod "Atom.ident" (node ident))
  (prod "Atom.metavar" (seq (lit $) (ref Atom.ident)))
  (prod "Atom.number" (node digits))
  (prod "Atom.regex" (node regex))
  (prod "Atom.reserved" (node reserved))
  (prod "Atom.string" (node string))
  (prod "File.autocutDecl" (node DAutocut (seq (lit @autocut) (ref Atom.ident))))
  (prod "File.commentDecl" (node comment (seq (lit --) (ref File.commentText))))
  (prod "File.commentText" (star (ref Atom.chars)))
  (prod "File.defDecl" (node DDef (seq (lit def) (ref Atom.ident) (lit =)) (ref Term.term)))
  (prod "File.fileDecl" (alt (ref File.langDecl) (ref File.importDecl) (ref File.grammarDecl) (ref File.pieceDecl) (ref File.ruleDecl) (ref File.testDecl) (ref File.lawDecl) (ref File.inheritDecl) (ref File.autocutDecl) (ref File.defDecl) (ref File.commentDecl)))
  (prod "File.fileDeclWithWs" (node decl (ref File.fileDecl) (alt (ref File.whitespace) (empty))))
  (prod "File.grammarDecl" (seq (lit grammar) (lit :) (star (ref File.grammarProd))))
  (prod "File.grammarProd" (seq (alt (ref File.whitespace) (empty)) (bind name (ref Atom.ident)) (lit ::=) (bind rhs (ref GrammarExpr.grammarExprFull)) (alt (ref File.whitespace) (empty))))
  (prod "File.importDecl" (node DImport (seq (lit import) (ref Atom.ident))))
  (prod "File.inheritDecl" (node DInherit (seq (lit inherit) (ref File.qualIdent))))
  (prod "File.langDecl" (node DLang (seq (lit lang) (ref Atom.ident)) (ref File.langParentsOpt) (seq (lit :=) (ref File.langDirectBody))))
  (prod "File.langDirectBody" (seq (alt (ref File.whitespace) (empty)) (node body (star (ref File.langItemWithWs)))))
  (prod "File.langItem" (alt (ref File.importDecl) (ref File.grammarDecl) (ref File.pieceDecl) (ref File.ruleDecl) (ref File.ruleStub) (ref File.testDecl) (ref File.lawDecl) (ref File.inheritDecl) (ref File.autocutDecl) (ref File.defDecl) (ref File.sectionMarker)))
  (prod "File.langItemWithWs" (node item (ref File.langItem) (alt (ref File.whitespace) (empty))))
  (prod "File.langParent" (ref Atom.ident))
  (prod "File.langParents" (node parents (seq (lit "(") (ref Atom.ident)) (star (seq (lit ,) (ref Atom.ident))) (lit ")")))
  (prod "File.langParentsOpt" (alt (ref File.langParents) (node parents)))
  (prod "File.lawDecl" (node DLaw (seq (lit law) (ref Atom.string) (lit :)) (ref Term.term) (ref File.lawOp) (ref Term.term)))
  (prod "File.lawOp" (alt (lit "≅") (lit ==)))
  (prod "File.legoFile" (seq (alt (ref File.whitespace) (empty)) (bind decls (star (ref File.fileDeclWithWs)))))
  (prod "File.pieceDecl" (seq (lit piece) (node DPiece (ref Atom.ident) (alt (ref File.whitespace) (empty)) (star (ref File.pieceItem)))))
  (prod "File.pieceItem" (alt (ref File.productionWithWs) (ref File.pieceRuleDecl) (ref File.pieceTestDecl) (ref File.pieceTypeDecl) (ref File.pieceSectionMarker) (ref File.commentDecl)))
  (prod "File.pieceRuleDecl" (seq (ref File.ruleDecl) (alt (ref File.whitespace) (empty))))
  (prod "File.pieceTestDecl" (seq (ref File.testDecl) (alt (ref File.whitespace) (empty))))
  (prod "File.pieceTypeDecl" (node DType (seq (lit type) (ref Atom.ident) (lit :)) (ref Term.term) (alt (ref File.typeWhen) (empty)) (alt (ref File.whitespace) (empty))))
  (prod "File.typeWhen" (seq (lit when) (ref File.typeConditions)))
  (prod "File.typeConditions" (seq (ref Term.term) (star (seq (lit ,) (ref Term.term)))))
  (prod "File.pieceSectionMarker" (seq (ref File.sectionMarker) (alt (ref File.whitespace) (empty))))
  (prod "File.productionWithWs" (node prodWrap (ref GrammarExpr.productionNode) (alt (ref File.whitespace) (empty))))
  (prod "File.qualIdent" (seq (ref Atom.ident) (star (seq (lit .) (ref Atom.ident)))))
  (prod "File.ruleDecl" (node DRule (seq (lit rule) (ref Atom.ident) (lit :)) (seq (alt (ref File.whitespace) (empty)) (ref Pattern.pattern)) (ref File.ruleArrow) (seq (alt (ref File.whitespace) (empty)) (ref Template.template))))
  (prod "File.ruleArrow" (alt (node forward (lit ~>)) (node backward (lit <~)) (node bidi (lit <~>))))
  (prod "File.ruleStub" (node DRuleStub (seq (lit rule) (ref Atom.ident) (lit :))))
  (prod "File.sectionMarker" (node section (seq (alt (lit prelude) (lit code)) (lit :))))
  (prod "File.testDecl" (node DTest (seq (lit test) (ref Atom.string) (lit :)) (ref Term.term) (alt (ref File.testExpected) (empty)) (alt (ref File.testOpts) (empty))))
  (prod "File.testExpected" (alt (seq (alt (ref File.whitespace) (empty)) (lit ~~>) (alt (ref File.whitespace) (empty)) (ref Term.term)) (seq (alt (ref File.whitespace) (empty)) (lit ==>) (alt (ref File.whitespace) (empty)) (ref Term.term))))
  (prod "File.testOpts" (seq (ref File.testOpt) (star (ref File.testOpt))))
  (prod "File.testOpt" (alt (node via (seq (lit via) (ref Atom.ident))) (node steps (seq (lit steps) (ref Atom.number))) (node error (seq (lit error) (ref Atom.string)))))
  (prod "File.whitespace" (star (alt (node newline) (node indent))))
  (prod "GrammarExpr.altContinuation" (seq (alt (ref GrammarExpr.grammarWhitespace) (empty)) (lit |) (alt (ref GrammarExpr.grammarWhitespace) (empty)) (bind alt2 (ref GrammarExpr.grammarAlt))))
  (prod "GrammarExpr.grammarAlt" (alt (seq (bind alt1 (ref GrammarExpr.grammarSeq)) (ref GrammarExpr.altContinuation)) (ref GrammarExpr.grammarSeq)))
  (prod "GrammarExpr.grammarAltTerm" (alt (node alt (ref GrammarExpr.grammarSeqTerm) (seq (alt (ref GrammarExpr.grammarWhitespace) (empty)) (lit |) (alt (ref GrammarExpr.grammarWhitespace) (empty))) (ref GrammarExpr.grammarAltTerm)) (ref GrammarExpr.grammarSeqTerm)))
  (prod "GrammarExpr.grammarAtom" (alt (bind s (ref Atom.string)) (bind res (ref Atom.reserved)) (bind r (ref Atom.regex)) (bind c (ref Atom.char)) (node lit (ref Atom.char)) (node regex (ref Atom.regex)) (node char (ref Atom.char)) (seq (lit $) (bind x (alt (ref Atom.ident) (ref Atom.string)))) (seq (bind x (ref Atom.ident)) (lit :) (bind t (ref Atom.ident)) (lit *)) (seq (bind x (ref Atom.ident)) (lit :) (bind t (ref Atom.ident))) (seq (lit "(") (bind g (ref GrammarExpr.grammarExpr)) (lit ")")) (seq (lit [) (bind g (ref GrammarExpr.grammarExpr)) (lit ])) (node ref (ref Atom.ident)) (seq (lit <) (bind k (ref Atom.ident)) (lit >)) (seq (lit μ) (bind x (ref Atom.ident)) (lit .) (bind g (ref GrammarExpr.grammarExpr))) (lit ε)))
  (prod "GrammarExpr.grammarAtomTerm" (alt (ref Atom.string) (ref Atom.reserved) (ref Atom.regex) (ref Atom.char) (node bind (seq (lit $) (alt (ref Atom.ident) (ref Atom.string)))) (seq (lit "(") (ref GrammarExpr.grammarExprTerm) (lit ")")) (seq (lit [) (node opt (ref GrammarExpr.grammarExprTerm)) (lit ])) (ref Atom.ident) (node special (seq (lit <) (ref Atom.ident) (lit >))) (seq (lit ε) (node empty))))
  (prod "GrammarExpr.grammarExpr" (ref GrammarExpr.grammarAlt))
  (prod "GrammarExpr.grammarExprFull" (bind rhs (ref GrammarExpr.grammarExpr)))
  (prod "GrammarExpr.grammarExprTerm" (ref GrammarExpr.grammarAltTerm))
  (prod "GrammarExpr.grammarSeq" (seq (bind seq1 (ref GrammarExpr.grammarSuffix)) (star (bind seq2 (ref GrammarExpr.grammarSuffix)))))
  (prod "GrammarExpr.grammarSeqTerm" (alt (node seq (ref GrammarExpr.grammarSuffixTerm) (ref GrammarExpr.grammarSeqTerm)) (ref GrammarExpr.grammarSuffixTerm)))
  (prod "GrammarExpr.grammarSuffix" (alt (node cut (seq (lit !) (ref GrammarExpr.grammarAtom))) (seq (bind g (ref GrammarExpr.grammarAtom)) (lit *)) (seq (bind g (ref GrammarExpr.grammarAtom)) (lit +)) (seq (bind g (ref GrammarExpr.grammarAtom)) (lit ?)) (ref GrammarExpr.grammarAtom)))
  (prod "GrammarExpr.grammarSuffixTerm" (alt (node cut (seq (lit !) (ref GrammarExpr.grammarAtomTerm))) (node star (seq (ref GrammarExpr.grammarAtomTerm) (lit *))) (node plus (seq (ref GrammarExpr.grammarAtomTerm) (lit +))) (node opt (seq (ref GrammarExpr.grammarAtomTerm) (lit ?))) (ref GrammarExpr.grammarAtomTerm)))
  (prod "GrammarExpr.grammarWhitespace" (star (alt (node newline) (node indent))))
  (prod "GrammarExpr.production" (seq (bind name (ref Atom.ident)) (lit ::=) (bind rhs (ref GrammarExpr.grammarExpr))))
  (prod "GrammarExpr.productionNode" (node DGrammar (seq (ref Atom.ident) (lit ::=)) (ref GrammarExpr.grammarExprTerm)))
  (prod "Pattern.pattern" (alt (node metavar) (node λᵢ (seq (lit "(") (lit λᵢ) (ref Pattern.pattern)) (seq (lit .) (ref Pattern.pattern) (lit ")"))) (node constructor (ref Pattern.pattern)) (node λᵢ (seq (lit λᵢ) (ref Pattern.pattern)) (seq (lit .) (ref Pattern.pattern))) (bind pstr (ref Atom.string)) (node litident)))
  (prod "Rule.guard" (seq (lit when) (bind c (ref Term.term))))
  (prod "Rule.rule" (alt (seq (bind p (ref Pattern.pattern)) (lit ~>) (bind t (ref Template.template)) (alt (ref Rule.guard) (empty))) (seq (bind p (ref Pattern.pattern)) (lit <~) (bind t (ref Template.template)) (alt (ref Rule.guard) (empty))) (seq (bind p (ref Pattern.pattern)) (lit <~>) (bind t (ref Template.template)) (alt (ref Rule.guard) (empty)))))
  (prod "Template.template" (alt (node metavar) (node subst (seq (lit [) (ref Atom.ident) (lit :=)) (ref Template.template) (seq (lit ]) (ref Template.template))) (node λᵢ (seq (lit "(") (lit λᵢ) (ref Template.template)) (seq (lit .) (ref Template.template) (lit ")"))) (node lam (seq (lit "(") (lit λ) (ref Atom.ident)) (seq (lit .) (ref Template.template) (lit ")"))) (node constructor (ref Template.template)) (node lam (seq (lit λ) (ref Atom.ident)) (seq (lit .) (ref Template.template))) (node λᵢ (seq (lit λᵢ) (ref Template.template)) (seq (lit .) (ref Template.template))) (bind tstr (ref Atom.string)) (node litident)))
  (prod "Term.term" (alt (seq (lit $) (bind metavar (ref Atom.ident))) (node ? (seq (lit ?) (ref Atom.ident))) (node . (seq (lit .) (ref Atom.ident))) (node λᵢ (seq (lit "(") (lit λᵢ) (ref Atom.ident)) (seq (lit .) (ref Term.term) (lit ")"))) (node lam (seq (lit "(") (lit λ) (ref Atom.ident)) (seq (lit .) (ref Term.term) (lit ")"))) (node Π (seq (lit "(") (lit Π) (ref Term.typedBinder)) (seq (lit .) (ref Term.term) (lit ")"))) (node Σ (seq (lit "(") (lit Σ) (ref Term.typedBinder)) (seq (lit .) (ref Term.term) (lit ")"))) (node ∀ (seq (lit "(") (lit ∀) (ref Term.typedBinder)) (seq (lit .) (ref Term.term) (lit ")"))) (node constructor (ref Term.term)) (node lam (seq (lit λ) (ref Atom.ident)) (seq (lit .) (ref Term.term))) (node λᵢ (seq (lit λᵢ) (ref Atom.ident)) (seq (lit .) (ref Term.term))) (bind str (ref Atom.string)) (bind num (ref Atom.number)) (bind var (ref Atom.ident))))
  (prod "Term.typedBinder" (node : (seq (lit "(") (ref Atom.ident) (lit :)) (seq (ref Term.term) (lit ")"))))
  (prod "Test.test" (alt (seq (lit test) (bind name (ref Atom.string)) (lit :) (bind input (ref Term.term)) (lit ~~>) (bind expected (ref Term.term)) (alt (ref Test.testOptions) (empty))) (seq (lit test) (bind name (ref Atom.string)) (lit :) (bind input (ref Term.term)) (alt (ref Test.testOptions) (empty)))))
  (prod "Test.testOptions" (seq (ref Test.testOption) (star (ref Test.testOption))))
  (prod "Test.testOption" (alt (node via (seq (lit via) (ref Atom.ident))) (node steps (seq (lit steps) (ref Atom.number))) (node error (seq (lit error) (ref Atom.string)))))
)
