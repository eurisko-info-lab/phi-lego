-- Lego Grammar: Declarative syntax definition
-- 
-- SOURCE OF TRUTH: This file defines the grammar. GrammarDef.hs is generated from it.
-- Run: cabal run gen-grammar-def -- lego/prelude/lego/Grammar.lego > lego/interpreter/Lego/GrammarDef.hs
--
-- Syntax: grammar "$ nodeName" specifies the AST node constructor
--   "(" "λ" ident "." term ")" $ lam   -- produces node "lam" [...]
--   Without $ annotation, production name is the node name
--
-- Grammar.lego → gen-grammar-def → GrammarDef.hs → GrammarInterp.hs

lang LegoGrammar :=

-----------------------------------------------------
-- PIECE 1: Atoms
-- Identifiers, literals, and basic tokens
-----------------------------------------------------

piece Atom
  ident   ::= <identifier>
  string  ::= <string>
  regex   ::= <regex>
  char    ::= <char>
  number  ::= <digits>
  metavar ::= "$" ident
  chars   ::= <char>*

-----------------------------------------------------
-- PIECE 2: Term
-- S-expression terms with variables and literals
-----------------------------------------------------

piece Term
  term ::= "$" ident                       $ metavar  -- metavariable
         | "?" ident                       $ hole     -- hole
         | "." ident                       $ proj     -- projection
         | "(" "λᵢ" ident "." term ")"     $ λᵢ       -- path abstraction (paren)
         | "(" "λ" ident "." term ")"      $ lam      -- lambda (paren)
         | "(" "Π" typedBinder "." term ")" $ Π       -- dependent Pi
         | "(" "Σ" typedBinder "." term ")" $ Σ       -- dependent Sigma
         | "(" "∀" typedBinder "." term ")" $ ∀       -- universal quantification
         | "(" ident term* ")"             $ constr   -- constructor
         | "λᵢ" ident "." term             $ λᵢ       -- path abstraction (bare)
         | "λ" ident "." term              $ lam      -- lambda (bare)
         | string                          $ str      -- string literal
         | number                          $ num      -- number literal
         | ident                           $ var      -- variable
  
  -- Typed binder for Π/Σ/∀: (x : A)
  typedBinder ::= "(" ident ":" term ")" $ ":"

-----------------------------------------------------
-- PIECE 3: Pattern
-- Patterns for matching in rules
-----------------------------------------------------

piece Pattern
  pattern ::= "$" ident                         $ metavar
            | "(" "λᵢ" pattern "." pattern ")"  $ λᵢ
            | "(" ident pattern* ")"            $ constr
            | "λᵢ" pattern "." pattern          $ λᵢ
            | string                            $ pstr
            | ident                             $ litIdent

-----------------------------------------------------
-- PIECE 4: Template  
-- Templates for rule right-hand sides
-----------------------------------------------------

piece Template
  template ::= "$" ident                          $ metavar
             | "[" ident ":=" template "]" template $ subst
             | "(" "λᵢ" template "." template ")" $ λᵢ
             | "(" "λ" ident "." template ")"     $ lam
             | "(" ident template* ")"            $ constr
             | "λᵢ" template "." template         $ λᵢ
             | "λ" ident "." template             $ lam
             | string                             $ tstr
             | ident                              $ litIdent

-----------------------------------------------------
-- PIECE 5: GrammarExpr
-- Grammar expressions (the meta-language)
-----------------------------------------------------

piece GrammarExpr  
  production ::= ident "::=" grammarExpr
  
  grammarExpr ::= grammarAlt
  
  grammarAlt ::= altBranch | grammarSeq
  altBranch ::= grammarSeq "|" grammarAlt
  
  grammarSeq ::= seqHead | grammarSuffix
  seqHead ::= grammarSuffix grammarSeq
  
  grammarSuffix ::= "!" grammarAtom         $ cutSuffix   -- cut (commit point)
                  | grammarAtom "*"         $ starSuffix
                  | grammarAtom "+"         $ plusSuffix
                  | grammarAtom "?"         $ optSuffix
                  | grammarAtom
  
  grammarAtom ::= string                    $ litAtom
                | regex                     $ regexAtom
                | char                      $ charAtom
                | "$" (ident | string)      $ captureAtom
                | ident ":" ident "*"       $ namedStarAtom
                | ident ":" ident           $ namedRefAtom
                | "(" grammarExpr ")"       $ groupAtom
                | "[" grammarExpr "]"       $ optGroupAtom
                | ident                     $ refAtom
                | "<" ident ">"             $ specialAtom
                | "μ" ident "." grammarExpr $ recAtom
                | "ε"                       $ emptyAtom
  
  -- Whitespace in grammar expressions (for multi-line grammars)
  grammarWhitespace ::= (<newline> | <indent>)*
  
-----------------------------------------------------
-- PIECE 6: Rule
-- Rewrite rules
-----------------------------------------------------

piece Rule
  rule ::= forwardRule | backwardRule | bidiRule
  
  forwardRule ::= pattern "~>" template guard?
  backwardRule ::= pattern "<~" template guard?
  bidiRule ::= pattern "<~>" template guard?
  
  guard ::= "when" term

-----------------------------------------------------
-- PIECE 7: Test
-- Test declarations with extended syntax
-----------------------------------------------------

piece Test
  test ::= fullTest | parseTest
  
  fullTest ::= "test" string ":" term "~~>" term testOptions?
  parseTest ::= "test" string ":" term testOptions?
  
  -- Extended test options
  testOptions ::= testOption+
  testOption ::= viaOption | stepsOption | errorOption
  viaOption ::= "via" ident                       $ via      -- must use this rule
  stepsOption ::= "steps" number                  $ steps    -- exact step count
  errorOption ::= "error" string                  $ error    -- expect error

-----------------------------------------------------
-- PIECE 8: Law
-- Algebraic law declarations
-----------------------------------------------------

piece Law
  law ::= "law" string ":" term "≅" term 
        | "law" string ":" term "==" term  -- ASCII alternative

-----------------------------------------------------
-- PIECE 9: File
-- Complete file structure  
-----------------------------------------------------

piece File
  legoFile ::= whitespace? fileDeclWithWs*
  
  fileDeclWithWs ::= fileDecl whitespace?
  
  whitespace ::= wsItem*
  wsItem ::= <newline> | <indent>
  
  fileDecl ::= langDecl
             | importDecl
             | grammarDecl
             | pieceDecl
             | ruleDecl
             | testDecl
             | lawDecl
             | inheritDecl
             | autocutDecl
             | defDecl
             | commentDecl
  
  -- Comment declaration
  commentDecl ::= "--" commentText          $ comment
  commentText ::= <char>*

  -- Language declaration with direct body (with cut after "lang")
  langDecl ::= !"lang" ident langParentsOpt ":=" langDirectBody
  
  langParentsOpt ::= langParents
  emptyParents ::= ε
  langParents ::= "(" ident moreParents* ")"
  moreParents ::= "," ident
  
  langDirectBody ::= whitespace? langItemWithWs*
  
  langItemWithWs ::= langItem whitespace?
  
  langItem ::= importDecl
             | grammarDecl
             | pieceDecl
             | ruleDecl
             | ruleStub
             | testDecl
             | lawDecl
             | inheritDecl
             | autocutDecl
             | defDecl
             | sectionMarker

  -- Section markers (prelude:, code:)
  sectionMarker ::= sectionName ":"
  sectionName ::= "prelude" | "code"
  
  -- Grammar declarations (with cut after "grammar")
  grammarDecl ::= !"grammar" ":" grammarProd*
  grammarProd ::= whitespace? ident "::=" grammarExpr whitespace?
  
  -- Import declaration (with cut after "import")
  importDecl ::= !"import" ident
  
  -- Piece declaration (with cut after "piece")
  pieceDecl ::= !"piece" ident whitespace? pieceItem*
  pieceItem ::= productionWithWs
  productionWithWs ::= production whitespace?
  
  -- Rule declaration (with cut after "rule")
  ruleDecl ::= !"rule" ident ":" whitespace? pattern "~>" whitespace? template
  
  -- Rule stub (empty rule declaration)
  ruleStub ::= !"rule" ident ":"
  
  -- Test declaration with extended options (with cut after "test")
  testDecl ::= !"test" string ":" term testExpected? testOpts?
  testExpected ::= testExpectedArrow | testExpectedDouble
  testExpectedArrow ::= whitespace? "~~>" whitespace? term
  testExpectedDouble ::= whitespace? "==>" whitespace? term
  -- Extended test options
  testOpts ::= testOpt+
  testOpt ::= "via" ident | "steps" number | "error" string
  
  -- Law declaration (with cut after "law")
  lawDecl ::= !"law" string ":" term lawOp term
  lawOp ::= "≅" | "=="  -- isomorphism or equality
  
  -- Inherit declaration (with cut after "inherit")
  inheritDecl ::= !"inherit" qualIdent
  qualIdent ::= ident ("." ident)*
  
  -- Autocut annotation (with cut after "@autocut")
  autocutDecl ::= !"@autocut" ident
  
  -- Def declaration (with cut after "def")
  defDecl ::= !"def" ident "=" term
