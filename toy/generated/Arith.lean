/-
  Generated from Arith.lego

  This module was automatically generated by ToLean.
  It should be structurally equivalent to hand-written Bootstrap.lean.
-/

import Lego.Algebra
import Lego.Interp
import Lego.Bootstrap

namespace Lego.Arith

open GrammarExpr

/-! ## Grammar Pieces -/

/-- Term piece -/
def termPiece : Piece := {
  name := "Term"
  grammar := [
    ("Term.term", ((ref "Term.zero").alt ((ref "Term.succ").alt ((ref "Term.add").alt ((ref "Term.mul").alt (ref "Term.pred")))))),
    ("Term.zero", (((lit "(").seq (lit "Z")).seq (lit ")"))),
    ("Term.succ", ((((lit "(").seq (lit "S")).seq (ref "Term.term")).seq (lit ")"))),
    ("Term.add", (((((lit "(").seq (lit "add")).seq (ref "Term.term")).seq (ref "Term.term")).seq (lit ")"))),
    ("Term.mul", (((((lit "(").seq (lit "mul")).seq (ref "Term.term")).seq (ref "Term.term")).seq (lit ")"))),
    ("Term.pred", ((((lit "(").seq (lit "pred")).seq (ref "Term.term")).seq (lit ")")))
  ]
  rules := []
}

/-- Rec piece -/
def recPiece : Piece := {
  name := "Rec"
  grammar := [
    ("Rec.rec", ((ref "Rec.fib").alt (ref "Rec.fact"))),
    ("Rec.fib", ((((lit "(").seq (lit "fib")).seq (ref "Term.term")).seq (lit ")"))),
    ("Rec.fact", ((((lit "(").seq (lit "fact")).seq (ref "Term.term")).seq (lit ")")))
  ]
  rules := []
}

/-! ## Language Definition -/

/-- The complete Arith language -/
def grammar : Language := {
  name := "Arith"
  pieces := [termPiece, recPiece]
}

/-- Build the interpreter -/
def interp : LangInterp := grammar.toInterp "Term.term"

/-! ## Tokenizer -/

/-- Default tokenizer (uses Bootstrap tokenizer) -/
def tokenize : String â†’ TokenStream := Lego.Bootstrap.tokenize

/-- Parse input -/
def parse (content : String) : Option Term :=
  interp.parse (tokenize content)

/-! ## Rewrite Rules -/

/-- Rule: add_zero -/
def rule_add_zero : Rule := {
  name := "add_zero"
  pattern := .con "add" [.con "Z" [], .var "$n"]
  template := .var "$n"
}

/-- Rule: add_succ -/
def rule_add_succ : Rule := {
  name := "add_succ"
  pattern := .con "add" [.con "S" [.var "$m"], .var "$n"]
  template := .con "S" [.con "add" [.var "$m", .var "$n"]]
}

/-- Rule: mul_zero -/
def rule_mul_zero : Rule := {
  name := "mul_zero"
  pattern := .con "mul" [.con "Z" [], .var "$n"]
  template := .con "Z" []
}

/-- Rule: mul_succ -/
def rule_mul_succ : Rule := {
  name := "mul_succ"
  pattern := .con "mul" [.con "S" [.var "$m"], .var "$n"]
  template := .con "add" [.var "$n", .con "mul" [.var "$m", .var "$n"]]
}

/-- Rule: pred_zero -/
def rule_pred_zero : Rule := {
  name := "pred_zero"
  pattern := .con "pred" [.con "Z" []]
  template := .con "Z" []
}

/-- Rule: pred_succ -/
def rule_pred_succ : Rule := {
  name := "pred_succ"
  pattern := .con "pred" [.con "S" [.var "$n"]]
  template := .var "$n"
}

/-- Rule: fib_zero -/
def rule_fib_zero : Rule := {
  name := "fib_zero"
  pattern := .con "fib" [.con "Z" []]
  template := .con "Z" []
}

/-- Rule: fib_one -/
def rule_fib_one : Rule := {
  name := "fib_one"
  pattern := .con "fib" [.con "S" [.con "Z" []]]
  template := .con "S" [.con "Z" []]
}

/-- Rule: fib_succ -/
def rule_fib_succ : Rule := {
  name := "fib_succ"
  pattern := .con "fib" [.con "S" [.con "S" [.var "$n"]]]
  template := .con "add" [.con "fib" [.con "S" [.var "$n"]], .con "fib" [.var "$n"]]
}

/-- Rule: fact_zero -/
def rule_fact_zero : Rule := {
  name := "fact_zero"
  pattern := .con "fact" [.con "Z" []]
  template := .con "S" [.con "Z" []]
}

/-- Rule: fact_succ -/
def rule_fact_succ : Rule := {
  name := "fact_succ"
  pattern := .con "fact" [.con "S" [.var "$n"]]
  template := .con "mul" [.con "S" [.var "$n"], .con "fact" [.var "$n"]]
}

/-- All rules for this language -/
def allRules : List Rule := [rule_add_zero, rule_add_succ, rule_mul_zero, rule_mul_succ, rule_pred_zero, rule_pred_succ, rule_fib_zero, rule_fib_one, rule_fib_succ, rule_fact_zero, rule_fact_succ]

/-- Combined interpreter from all rules -/
def ruleInterp : Iso Term Term := Language.combineRules allRules

/-- Apply rules to normalize a term -/
partial def normalize (t : Term) : Term :=
  match ruleInterp.forward t with
  | some t' => normalize t'
  | none =>
    match t with
    | .con c args => .con c (args.map normalize)
    | _ => t

end Lego.Arith

