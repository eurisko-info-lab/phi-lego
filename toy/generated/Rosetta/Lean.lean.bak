/-
  Generated from Lean.lego

  This module was automatically generated by ToLean.
  It should be structurally equivalent to hand-written Bootstrap.lean.
-/

import Lego.Algebra
import Lego.Interp
import Lego.Bootstrap

namespace Lego.Lean

open GrammarExpr

/-! ## Grammar Pieces -/

/-- Core piece -/
def corePiece : Piece := {
  name := "Core"
  grammar := [
    ("Core.coreAtom", ((node "trueLit" (lit "true")).alt ((node "falseLit" (lit "false")).alt ((node "noneLit" (lit "none")).alt ((node "someLit" ((lit "some").seq (ref "Core.coreAtom"))).alt ((node "funExpr" ((((lit "fun").seq (ref "Binders.binderSeq")).seq (lit "=>")).seq (ref "Core.coreTerm"))).alt ((node "lamExpr" ((((lit "λ").seq (ref "Binders.binderSeq")).seq (lit "=>")).seq (ref "Core.coreTerm"))).alt ((node "forall" ((((lit "∀").seq (ref "Binders.binderSeq")).seq (lit ",")).seq (ref "Core.coreTerm"))).alt ((node "piType" ((((lit "Π").seq (ref "Binders.binderSeq")).seq (lit ",")).seq (ref "Core.coreTerm"))).alt ((node "sigmaType" ((((lit "Σ").seq (ref "Binders.binderSeq")).seq (lit ",")).seq (ref "Core.coreTerm"))).alt ((node "typeUniv" ((lit "Type").seq ((ref "Core.levelSpec").alt empty))).alt ((node "propUniv" (lit "Prop")).alt ((node "sortUniv" ((lit "Sort").seq ((ref "Core.levelSpec").alt empty))).alt ((node "optionType" ((lit "Option").seq (ref "Core.coreAtom"))).alt ((node "listType" ((lit "List").seq (ref "Core.coreAtom"))).alt ((node "arrayType" ((lit "Array").seq (ref "Core.coreAtom"))).alt ((node "matchExpr" ((((lit "match").seq (ref "Core.termList")).seq (lit "with")).seq ((ref "Match.coreAlt").star))).alt ((node "ifLetExpr" (((((((((lit "if").seq (lit "let")).seq (ref "Match.corePattern")).seq (lit ":=")).seq (ref "Core.coreTerm")).seq (lit "then")).seq (ref "Core.coreTerm")).seq (lit "else")).seq (ref "Core.coreTerm"))).alt ((node "ifExpr" ((((((lit "if").seq (ref "Core.coreTerm")).seq (lit "then")).seq (ref "Core.coreTerm")).seq (lit "else")).seq (ref "Core.coreTerm"))).alt ((node "letRecExpr" ((((((((lit "let").seq (lit "rec")).seq (ref "TOKEN.ident")).seq ((ref "Binders.typeAnn").alt empty)).seq (lit ":=")).seq (ref "Core.coreTerm")).seq ((lit "in").alt empty)).seq (ref "Core.coreTerm"))).alt ((node "letExpr" (((((((lit "let").seq (ref "TOKEN.ident")).seq ((ref "Binders.typeAnn").alt empty)).seq (lit ":=")).seq (ref "Core.coreTerm")).seq ((lit "in").alt empty)).seq (ref "Core.coreTerm"))).alt ((node "haveExpr" (((((((lit "have").seq ((ref "TOKEN.ident").alt empty)).seq (lit ":")).seq (ref "Core.coreTerm")).seq (lit ":=")).seq (ref "Core.coreTerm")).seq (ref "Core.coreAtom"))).alt ((node "doBlock" ((lit "do").seq ((ref "DoNotation.doElem").seq ((ref "DoNotation.doElem").star)))).alt ((node "byTactic" ((lit "by").seq (ref "Proofs.tacticSeq"))).alt ((node "rflTerm" (lit "rfl")).alt ((node "coeUp" ((lit "↑").seq (ref "Core.coreAtom"))).alt ((node "notOp" ((lit "!").seq (ref "Core.coreAtom"))).alt ((node "negOp" ((lit "-").seq (ref "Core.coreAtom"))).alt ((node "arrayLit" ((((lit "#").seq (lit "[")).seq (ref "Core.termList")).seq (lit "]"))).alt ((node "anonCtor" (((lit "⟨").seq (ref "Core.termList")).seq (lit "⟩"))).alt ((node "interpStr" ((lit "s!").seq (ref "TOKEN.string"))).alt ((node "unitLit" ((lit "(").seq (lit ")"))).alt ((node "tuple" (((((lit "(").seq (ref "Core.coreTerm")).seq (lit ",")).seq (ref "Core.coreTerm")).seq (lit ")"))).alt ((node "paren" (((lit "(").seq (ref "Core.coreTerm")).seq (lit ")"))).alt ((node "listLit" (((lit "[").seq (ref "Core.termList")).seq (lit "]"))).alt ((node "structLit" (((lit "{").seq (ref "Core.fieldAssigns")).seq (lit "}"))).alt ((node "hole" (lit "_")).alt ((node "numLit" (ref "TOKEN.number")).alt ((node "strLit" (ref "TOKEN.string")).alt (node "var" (ref "TOKEN.ident"))))))))))))))))))))))))))))))))))))))))),
    ("Core.coreTerm", (node "expr" ((ref "Core.coreAtom").seq ((ref "Core.coreArg").star)))),
    ("Core.coreArg", ((node "appArg" ((lit "@").seq (ref "Core.coreAtom"))).alt ((node "projArg" ((lit ".").seq (ref "TOKEN.ident"))).alt ((node "projNumArg" ((lit ".").seq (ref "TOKEN.number"))).alt ((node "consArg" (((lit ":").seq (lit ":")).seq (ref "Core.coreTerm"))).alt ((node "pipeRightArg" (((lit "|").seq (lit ">")).seq (ref "Core.coreTerm"))).alt ((node "pipeLeftArg" (((lit "<").seq (lit "|")).seq (ref "Core.coreTerm"))).alt ((node "eqArg" (((lit "=").seq (lit "=")).seq (ref "Core.coreTerm"))).alt ((node "neArg" (((lit "!").seq (lit "=")).seq (ref "Core.coreTerm"))).alt ((node "leArg" (((lit "<").seq (lit "=")).seq (ref "Core.coreTerm"))).alt ((node "geArg" (((lit ">").seq (lit "=")).seq (ref "Core.coreTerm"))).alt ((node "andArg" (((lit "&").seq (lit "&")).seq (ref "Core.coreTerm"))).alt ((node "orArg" (((lit "|").seq (lit "|")).seq (ref "Core.coreTerm"))).alt ((node "appendArg" (((lit "+").seq (lit "+")).seq (ref "Core.coreTerm"))).alt ((node "arrowArg" ((lit "→").seq (ref "Core.coreTerm"))).alt ((node "prodArg" ((lit "×").seq (ref "Core.coreTerm"))).alt ((node "dollarArg" ((lit "$").seq (ref "Core.coreTerm"))).alt ((node "addArg" ((lit "+").seq (ref "Core.coreTerm"))).alt ((node "subArg" ((lit "-").seq (ref "Core.coreTerm"))).alt ((node "mulArg" ((lit "*").seq (ref "Core.coreTerm"))).alt ((node "divArg" ((lit "/").seq (ref "Core.coreTerm"))).alt ((node "modArg" ((lit "%").seq (ref "Core.coreTerm"))).alt ((node "ltArg" ((lit "<").seq (ref "Core.coreTerm"))).alt ((node "gtArg" ((lit ">").seq (ref "Core.coreTerm"))).alt ((node "whereArg" ((lit "where").seq ((ref "Binders.letDecl").seq ((ref "Binders.letDecl").star)))).alt ((node "withArg" ((lit "with").seq (ref "Records.fieldUpdates"))).alt (node "substArg" (((((lit "[").seq (ref "TOKEN.ident")).seq (lit ":=")).seq (ref "Core.coreTerm")).seq (lit "]"))))))))))))))))))))))))))))),
    ("Core.termList", (node "termList" ((ref "Core.termListItem").star))),
    ("Core.termListItem", ((node "termItem" (ref "Core.coreTerm")).alt (node "termComma" (lit ",")))),
    ("Core.fieldAssigns", (node "fieldAssigns" ((ref "Core.fieldAssign").star))),
    ("Core.fieldAssign", (node "fieldAssign" (((ref "TOKEN.ident").seq (lit ":=")).seq (ref "Core.coreTerm")))),
    ("Core.levelSpec", (node "levelSpec" (ref "TOKEN.number")))
  ]
  rules := []
}

/-- Binders piece -/
def bindersPiece : Piece := {
  name := "Binders"
  grammar := [
    ("Binders.binderSeq", (node "binderSeq" ((ref "Binders.binder").seq ((ref "Binders.binder").star)))),
    ("Binders.binder", ((node "simpleBind" (ref "TOKEN.ident")).alt ((node "typedBind" (((((lit "(").seq (ref "TOKEN.ident")).seq (lit ":")).seq (ref "Core.coreTerm")).seq (lit ")"))).alt ((node "implicitBind" (((((lit "{").seq (ref "TOKEN.ident")).seq (lit ":")).seq (ref "Core.coreTerm")).seq (lit "}"))).alt ((node "instBind" (((((lit "[").seq (ref "TOKEN.ident")).seq (lit ":")).seq (ref "Core.coreTerm")).seq (lit "]"))).alt (node "parenBind" (((lit "(").seq (ref "TOKEN.ident")).seq (lit ")")))))))),
    ("Binders.typeAnn", (node "typeAnn" ((lit ":").seq (ref "Core.coreTerm")))),
    ("Binders.letDecl", (node "letDecl" (((ref "TOKEN.ident").seq (lit ":=")).seq (ref "Core.coreTerm"))))
  ]
  rules := []
}

/-- Match piece -/
def matchPiece : Piece := {
  name := "Match"
  grammar := [
    ("Match.coreAlt", (node "coreAlt" ((((lit "|").seq (ref "Match.patternList")).seq (lit "=>")).seq (ref "Core.coreTerm")))),
    ("Match.patternList", (node "patternList" ((ref "Match.corePattern").seq ((ref "Match.patternTail").star)))),
    ("Match.patternTail", (node "patternTail" ((lit ",").seq (ref "Match.corePattern")))),
    ("Match.patternAtom", ((node "patVar" (ref "TOKEN.ident")).alt ((node "patWild" (lit "_")).alt ((node "patCtor" ((lit ".").seq (ref "TOKEN.ident"))).alt ((node "patNum" (ref "TOKEN.number")).alt ((node "patStr" (ref "TOKEN.string")).alt ((node "patAnon" (((lit "⟨").seq (ref "Match.patternList")).seq (lit "⟩"))).alt (node "patTuple" (((lit "(").seq (ref "Match.patternList")).seq (lit ")")))))))))),
    ("Match.corePattern", (node "corePattern" ((ref "Match.patternAtom").seq ((ref "Match.patternArg").star)))),
    ("Match.patternArg", ((node "patConsArg" (((lit ":").seq (lit ":")).seq (ref "Match.corePattern"))).alt (node "patSuccArg" ((lit "+").seq (ref "TOKEN.number")))))
  ]
  rules := []
}

/-- Declarations piece -/
def declarationsPiece : Piece := {
  name := "Declarations"
  grammar := [
    ("Declarations.decl", ((node "inductiveDecl" (((((lit "inductive").seq (ref "TOKEN.ident")).seq ((ref "Declarations.params").alt empty)).seq ((ref "Declarations.whereConstrs").alt empty)).seq ((ref "Declarations.derivingClause").alt empty))).alt ((node "structureDecl" (((((((lit "structure").seq (ref "TOKEN.ident")).seq ((ref "Declarations.params").alt empty)).seq ((ref "Declarations.extendsClause").alt empty)).seq (lit "where")).seq ((ref "Declarations.fieldDecls").alt empty)).seq ((ref "Declarations.derivingClause").alt empty))).alt ((node "classDecl" ((((((lit "class").seq (ref "TOKEN.ident")).seq ((ref "Declarations.params").alt empty)).seq ((ref "Declarations.extendsClause").alt empty)).seq (lit "where")).seq ((ref "Declarations.fieldDecls").alt empty))).alt ((node "instanceDecl" ((((((lit "instance").seq ((ref "Declarations.instName").alt empty)).seq (lit ":")).seq (ref "Core.coreTerm")).seq (lit "where")).seq ((ref "Declarations.fieldDefs").alt empty))).alt ((node "defDecl" (((((((lit "def").seq (ref "TOKEN.ident")).seq ((ref "Declarations.params").alt empty)).seq ((ref "Binders.typeAnn").alt empty)).seq ((ref "Declarations.whereClause").alt empty)).seq (lit ":=")).seq (ref "Core.coreTerm"))).alt ((node "partialDefDecl" (((((((lit "partial").seq (lit "def")).seq (ref "TOKEN.ident")).seq ((ref "Declarations.params").alt empty)).seq ((ref "Binders.typeAnn").alt empty)).seq (lit ":=")).seq (ref "Core.coreTerm"))).alt ((node "theoremDecl" (((((((lit "theorem").seq (ref "TOKEN.ident")).seq ((ref "Declarations.params").alt empty)).seq (lit ":")).seq (ref "Core.coreTerm")).seq (lit ":=")).seq (ref "Core.coreTerm"))).alt ((node "lemmaDecl" (((((((lit "lemma").seq (ref "TOKEN.ident")).seq ((ref "Declarations.params").alt empty)).seq (lit ":")).seq (ref "Core.coreTerm")).seq (lit ":=")).seq (ref "Core.coreTerm"))).alt ((node "exampleDecl" (((((lit "example").seq (lit ":")).seq (ref "Core.coreTerm")).seq (lit ":=")).seq (ref "Core.coreTerm"))).alt ((node "abbrevDecl" ((((((lit "abbrev").seq (ref "TOKEN.ident")).seq ((ref "Declarations.params").alt empty)).seq ((ref "Binders.typeAnn").alt empty)).seq (lit ":=")).seq (ref "Core.coreTerm"))).alt ((node "namespaceDecl" (((((lit "namespace").seq (ref "TOKEN.ident")).seq ((ref "Declarations.decl").star)).seq (lit "end")).seq (ref "TOKEN.ident"))).alt ((node "sectionDecl" (((((lit "section").seq ((ref "TOKEN.ident").alt empty)).seq ((ref "Declarations.decl").star)).seq (lit "end")).seq ((ref "TOKEN.ident").alt empty))).alt ((node "importDecl" ((lit "import").seq (ref "Declarations.modulePath"))).alt ((node "openDecl" (((lit "open").seq (ref "Declarations.modulePath")).seq ((ref "Declarations.inClause").alt empty))).alt ((node "variableDecl" ((lit "variable").seq (ref "Declarations.varDecls"))).alt (node "attributeDecl" ((lit "attribute").seq (ref "Declarations.attrSpec"))))))))))))))))))),
    ("Declarations.params", (node "params" ((ref "Declarations.param").seq ((ref "Declarations.param").star)))),
    ("Declarations.param", ((node "param" (((((lit "(").seq (ref "TOKEN.ident")).seq (lit ":")).seq (ref "Core.coreTerm")).seq (lit ")"))).alt ((node "implicitParam" (((((lit "{").seq (ref "TOKEN.ident")).seq (lit ":")).seq (ref "Core.coreTerm")).seq (lit "}"))).alt ((node "instParam" (((((lit "[").seq (ref "TOKEN.ident")).seq (lit ":")).seq (ref "Core.coreTerm")).seq (lit "]"))).alt (node "simpleParam" (ref "TOKEN.ident")))))),
    ("Declarations.whereClause", (node "whereClause" ((lit "where").seq ((ref "Binders.letDecl").star)))),
    ("Declarations.whereConstrs", (node "whereConstrs" ((lit "where").seq ((ref "Declarations.constr").star)))),
    ("Declarations.constr", (node "constr" (((((lit "|").seq (ref "TOKEN.ident")).seq ((ref "Declarations.constrParams").alt empty)).seq (lit ":")).seq (ref "Core.coreTerm")))),
    ("Declarations.constrParams", (node "constrParams" ((ref "Declarations.param").seq ((ref "Declarations.param").star)))),
    ("Declarations.derivingClause", (node "derivingClause" ((lit "deriving").seq (ref "TOKEN.ident")))),
    ("Declarations.fieldDecls", (node "fieldDecls" ((ref "Declarations.fieldDecl").star))),
    ("Declarations.fieldDecl", (node "fieldDecl" ((((ref "TOKEN.ident").seq (lit ":")).seq (ref "Core.coreTerm")).seq ((ref "Declarations.defaultVal").alt empty)))),
    ("Declarations.fieldDefs", (node "fieldDefs" ((ref "Declarations.fieldDef").star))),
    ("Declarations.fieldDef", (node "fieldDef" (((ref "TOKEN.ident").seq (lit ":=")).seq (ref "Core.coreTerm")))),
    ("Declarations.defaultVal", (node "defaultVal" ((lit ":=").seq (ref "Core.coreTerm")))),
    ("Declarations.extendsClause", (node "extendsClause" ((lit "extends").seq (ref "Core.coreTerm")))),
    ("Declarations.instName", (node "instName" (ref "TOKEN.ident"))),
    ("Declarations.modulePath", (node "modulePath" (ref "TOKEN.ident"))),
    ("Declarations.inClause", (node "inClause" ((lit "in").seq (ref "Core.coreTerm")))),
    ("Declarations.varDecls", (node "varDecls" ((ref "Declarations.varDecl").seq ((ref "Declarations.varDecl").star)))),
    ("Declarations.varDecl", ((node "varDecl" (((((lit "(").seq (ref "TOKEN.ident")).seq (lit ":")).seq (ref "Core.coreTerm")).seq (lit ")"))).alt (node "implicitVarDecl" (((((lit "{").seq (ref "TOKEN.ident")).seq (lit ":")).seq (ref "Core.coreTerm")).seq (lit "}"))))),
    ("Declarations.attrSpec", (node "attrSpec" ((((lit "[").seq (ref "TOKEN.ident")).seq (lit "]")).seq (ref "TOKEN.ident"))))
  ]
  rules := []
}

/-- DoNotation piece -/
def doNotationPiece : Piece := {
  name := "DoNotation"
  grammar := [
    ("DoNotation.doElem", ((node "doLet" ((((lit "let").seq (ref "TOKEN.ident")).seq (lit "←")).seq (ref "Core.coreTerm"))).alt ((node "doLetPure" ((((lit "let").seq (ref "TOKEN.ident")).seq (lit ":=")).seq (ref "Core.coreTerm"))).alt ((node "doBind" (((ref "TOKEN.ident").seq (lit "←")).seq (ref "Core.coreTerm"))).alt ((node "doIf" ((((((lit "if").seq (ref "Core.coreTerm")).seq (lit "then")).seq ((ref "DoNotation.doElem").seq ((ref "DoNotation.doElem").star))).seq ((lit "else").alt empty)).seq ((ref "DoNotation.doElem").star))).alt ((node "doFor" ((((((lit "for").seq (ref "TOKEN.ident")).seq (lit "in")).seq (ref "Core.coreTerm")).seq (lit "do")).seq ((ref "DoNotation.doElem").seq ((ref "DoNotation.doElem").star)))).alt ((node "doReturn" ((lit "return").seq (ref "Core.coreTerm"))).alt ((node "doPure" ((lit "pure").seq (ref "Core.coreTerm"))).alt (node "doExpr" (ref "Core.coreTerm"))))))))))
  ]
  rules := []
}

/-- Proofs piece -/
def proofsPiece : Piece := {
  name := "Proofs"
  grammar := [
    ("Proofs.tacticSeq", (node "tacticSeq" ((ref "Proofs.tactic").star))),
    ("Proofs.tactic", ((node "rfl" (lit "rfl")).alt ((node "sorry" (lit "sorry")).alt ((node "trivial" (lit "trivial")).alt ((node "decide" (lit "decide")).alt ((node "assumption" (lit "assumption")).alt ((node "intro" ((lit "intro").seq ((ref "TOKEN.ident").star))).alt ((node "exact" ((lit "exact").seq (ref "Core.coreTerm"))).alt ((node "apply" ((lit "apply").seq (ref "Core.coreTerm"))).alt ((node "simp" ((lit "simp").seq ((ref "Proofs.simpArgs").alt empty))).alt ((node "cases" ((lit "cases").seq (ref "Core.coreTerm"))).alt ((node "induction" ((((lit "induction").seq (ref "Core.coreTerm")).seq (lit "with")).seq (ref "Proofs.inductionAlts"))).alt ((node "constructor" (lit "constructor")).alt ((node "rewrite" ((((lit "rw").seq (lit "[")).seq (ref "Proofs.rwRules")).seq (lit "]"))).alt ((node "first" ((((lit "first").seq (lit "[")).seq (ref "Proofs.tacticSeq")).seq (lit "]"))).alt ((node "repeat" ((lit "repeat").seq (ref "Proofs.tactic"))).alt ((node "tacticApp" ((ref "TOKEN.ident").seq ((ref "Core.coreTerm").star))).alt (node "tacticIdent" (ref "TOKEN.ident"))))))))))))))))))),
    ("Proofs.simpArgs", (node "simpArgs" (((lit "[").seq ((ref "Proofs.simpRule").star)).seq (lit "]")))),
    ("Proofs.simpRule", (node "simpRule" (ref "Core.coreTerm"))),
    ("Proofs.inductionAlts", (node "inductionAlts" ((ref "Proofs.inductionAlt").star))),
    ("Proofs.inductionAlt", (node "inductionAlt" (((((lit "|").seq (ref "TOKEN.ident")).seq ((ref "TOKEN.ident").star)).seq (lit "=>")).seq (ref "Proofs.tacticSeq")))),
    ("Proofs.rwRules", (node "rwRules" ((ref "Proofs.rwRule").star))),
    ("Proofs.rwRule", (node "rwRule" (((lit "←").alt empty).seq (ref "Core.coreTerm"))))
  ]
  rules := []
}

/-- Records piece -/
def recordsPiece : Piece := {
  name := "Records"
  grammar := [
    ("Records.fieldUpdates", (node "fieldUpdates" (((lit "{").seq ((ref "Records.fieldUpdate").seq ((ref "Records.fieldUpdate").star))).seq (lit "}")))),
    ("Records.fieldUpdate", (node "fieldUpdate" (((ref "TOKEN.ident").seq (lit ":=")).seq (ref "Core.coreTerm"))))
  ]
  rules := []
}

/-! ## Language Definition -/

/-- The complete Lean language -/
def grammar : Language := {
  name := "Lean"
  pieces := [corePiece, bindersPiece, matchPiece, declarationsPiece, doNotationPiece, proofsPiece, recordsPiece]
}

/-- Build the interpreter -/
def interp : LangInterp := grammar.toInterp "Core.coreAtom"

/-! ## Tokenizer -/

/-- Default tokenizer (uses Bootstrap tokenizer) -/
def tokenize : String → TokenStream := Lego.Bootstrap.tokenize

/-- Parse input -/
def parse (content : String) : Option Term :=
  interp.parse (tokenize content)



end Lego.Lean
