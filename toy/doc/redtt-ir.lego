-- Redtt IR Analysis
-- ==================
--
-- This documents the internal representations used by redtt and
-- the transformation pipeline: Surface Syntax → Elaborated → Core → Domain
--
-- Architecture Overview:
-- ----------------------
--
--   .red file
--      │
--      ▼ (Grammar.mly → Lex.mll)
--   ML.econ (elaboration terms - surface AST with locations)
--      │
--      ▼ (Elaborator.ml - bidirectional type checking)
--   Tm.tm (core terms - de Bruijn indexed)
--      │
--      ▼ (Domain.ml/Val.ml - evaluation)
--   DomainData.value (semantic values - closures, neutrals)
--      │
--      ▼ (Quote.ml - quotation/readback)
--   Tm.tm (normalized core terms)
--
--
-- Key Insight: The elaborator is BIDIRECTIONAL
-- ---------------------------------------------
-- Two modes:
--   elab_chk : eterm → goal → Tm.tm M.m   (checking mode)
--   elab_inf : eterm → (Tm.tm × Tm.cmd) M.m (inference mode)
--
-- goal = {ty : Tm.tm; sys : system}  -- expected type + constraints
--
--
-- 1. Surface Syntax (ML.econ)
-- ---------------------------
-- Located in: frontend/ML.ml
--
-- econ = expression constructor (surface syntax)
--   | Guess of eterm                              -- ?name{tm}
--   | Hole of string option * eterm option        -- ?name
--   | Hope                                        -- _ (wildcard)
--   | Lam of einvpat list * eterm                 -- λ pats → body
--   | Tuple of eterm list                         -- (a, b, ...)
--   | Type of Kind.t * Lvl.t                      -- type pre/kan ^n
--   | Quo of (ResEnv.t → Tm.tm)                   -- `term (quoted)
--   | Let of {pat; sch; tm; body}                 -- let pat : sch = tm in body
--   | Elim of {mot; scrut; clauses}               -- elim scrut [with mot] cases
--   | ElimFun of {clauses}                        -- elim cases (lambda elim)
--   | Pi of etele * eterm                         -- (x : A) → B
--   | Sg of etele * eterm                         -- (x : A) × B
--   | Ext of string list * eterm * esys           -- [i j] A sys
--   | Coe of {r; r'; fam; tm}                     -- coe r r' fam tm
--   | HCom of {r; r'; cap; sys}                   -- hcom r r' cap sys
--   | Com of {r; r'; fam; cap; sys}               -- com r r' fam cap sys
--   | V of {x; ty0; ty1; equiv}                   -- V x ty0 ty1 equiv
--   | Box of {cap; sys}                           -- box cap sys
--   | Cut of eterm * frame list                   -- head spine
--   | Refl                                        -- refl
--   | Var of {name; ushift}                       -- x or x^n
--   | Num of int                                  -- 0, 1, ...
--   | RunML of mlcmd                              -- ⟨cmd⟩
--
-- frame = application/projection
--   | App of eterm      -- f x
--   | Fst               -- .fst
--   | Snd               -- .snd
--   | VProj             -- .vproj
--   | Cap               -- .cap
--   | Open              -- (restrict force)
--
--
-- 2. Core Terms (Tm.tmf / TmData.ml)
-- ----------------------------------
-- Located in: core/TmData.ml, core/Tm.ml
--
-- De Bruijn indexed, locally nameless representation.
-- 'a tmf = term functor (parameterized for recursion)
--
-- TYPE FORMERS:
--   | Univ of {kind; lvl}           -- type kind ^lvl
--   | Pi of 'a * 'a bnd             -- (x : A) → B
--   | Sg of 'a * 'a bnd             -- (x : A) × B
--   | Ext of ('a * sys) nbnd        -- extension types [i] A [sys]
--   | Restrict of face              -- restriction types
--   | V of {r; ty0; ty1; equiv}     -- V-types (univalence)
--   | Data of {lbl; params}         -- inductive data type
--
-- INTRODUCTION FORMS:
--   | Lam of 'a bnd                 -- λ x. e
--   | ExtLam of 'a nbnd             -- λ [i]. e
--   | Cons of 'a * 'a               -- (a, b)
--   | RestrictThunk of face         -- restriction intro
--   | VIn of {r; tm0; tm1}          -- V-type intro
--   | Box of {r; r'; cap; sys}      -- box (comp intro)
--   | Intro of lbl * clbl * args    -- data constructor
--   | Dim0 | Dim1                   -- interval endpoints
--
-- ELIMINATION FORMS (via cmd = head * spine):
--   head:
--     | Var of {name; twin; ushift} -- named variable
--     | Ix of int * twin            -- de Bruijn index
--     | Meta of {name; ushift}      -- metavariable
--     | Down of {ty; tm}            -- type annotation
--     | DownX of 'a                 -- implicit annotation
--     | Coe of {r; r'; ty; tm}      -- coercion
--     | HCom of {r; r'; ty; cap; sys} -- homogeneous composition
--     | Com of {r; r'; ty; cap; sys}  -- heterogeneous composition
--     | GHCom / GCom                -- generalized versions
--
--   frame (spine element):
--     | Fst | Snd                   -- projections
--     | FunApp of 'a                -- function application
--     | ExtApp of 'a list           -- dimension application
--     | VProj of {r; ty0; ty1; func} -- V projection
--     | Cap of {r; r'; ty; sys}     -- cap (comp elim)
--     | RestrictForce              -- restriction elimination
--     | Elim of {dlbl; params; mot; clauses} -- data eliminator
--
-- SPECIAL:
--   | FHCom of {r; r'; cap; sys}    -- fibrant hcom
--   | Up of 'a cmd                  -- neutral term
--   | Let of 'a cmd * 'a bnd        -- let binding
--   | FortyTwo                      -- error/placeholder
--
--
-- 3. Semantic Domain (DomainData.value)
-- -------------------------------------
-- Located in: core/DomainData.ml
--
-- Evaluated/semantic values for normalization by evaluation (NbE).
--
-- value = Node of {con; action}
--   where action is a dimension substitution
--
-- con (value constructor):
--   TYPE FORMERS:
--     | Univ of {kind; lvl}
--     | Pi of {dom; cod : clo}
--     | Sg of {dom; cod : clo}
--     | Ext of ext_abs
--     | Restrict of val_face
--     | V of {x; ty0; ty1; equiv}
--     | Data of {lbl; params}
--
--   VALUES:
--     | Lam of clo                  -- closure
--     | ExtLam of nclo              -- n-ary closure
--     | Cons of value * value
--     | RestrictThunk of val_face
--     | VIn of {x; el0; el1}
--     | Box of {dir; cap; sys}
--     | Intro of {dlbl; clbl; args; sys}
--
--   NEUTRALS:
--     | Up of {ty; neu; sys}        -- neutral with type annotation
--
--   KAN OPERATIONS:
--     | Coe of {dir; abs; el}       -- stuck coercion
--     | HCom of {dir; ty; cap; sys} -- stuck hcom
--     | GHCom / FHCom               -- variants
--
-- neu (neutral terms):
--   | Lvl of name * int             -- de Bruijn level
--   | Var of {name; twin; ushift}
--   | Meta of {name; ushift}
--   | FunApp of neu * nf
--   | ExtApp of neu * dim list
--   | Fst of neu | Snd of neu
--   | Elim of {dlbl; params; mot; neu; clauses}
--   | VProj of {x; func; neu}
--   | Cap of {dir; ty; sys; neu}
--   | RestrictForce of neu
--   | NCoe / NHComAtType / etc.     -- stuck compositions
--
--
-- 4. Transformation Rules for Lego
-- ---------------------------------
--
-- To bring parsed AST to IR level, we need bidirectional rules:
--
-- PHASE 1: Surface → Core (elaboration)
--   • Name resolution: Var "x" → Ix n
--   • Type inference/checking
--   • Implicit argument insertion
--   • Pattern compilation
--
-- PHASE 2: Core → Core (reduction)
--   • β-reduction: (λx.e) v → e[v/x]
--   • η-expansion for types
--   • Kan operations computation
--   • Datatype elimination
--
-- PHASE 3: Core ↔ Domain (NbE)
--   • eval : Tm.tm → env → value
--   • quote : value → ty → Tm.tm
--
--
-- Key Rewrite Rules Needed:
-- -------------------------
--
-- -- Application
-- rule app-beta: (app (lam $x $body) $arg) ~> (subst $body $x $arg) ;
--
-- -- Projections  
-- rule fst-cons: (fst (cons $a $b)) ~> $a ;
-- rule snd-cons: (snd (cons $a $b)) ~> $b ;
--
-- -- Let binding
-- rule let-subst: (let $x $val $body) ~> (subst $body $x $val) ;
--
-- -- Dimension operations
-- rule dim-app-0: (extapp (extlam $i $body) dim0) ~> (subst $body $i dim0) ;
-- rule dim-app-1: (extapp (extlam $i $body) dim1) ~> (subst $body $i dim1) ;
--
-- -- Coercion
-- rule coe-refl: (coe $r $r $ty $tm) ~> $tm ;  -- when r = r'
--
-- -- HCom
-- rule hcom-refl: (hcom $r $r $ty $cap $sys) ~> $cap ;
--
-- -- V-types
-- rule vproj-vin: (vproj (vin $r $tm0 $tm1)) ~> ...  -- depends on r
--
-- -- Data elimination
-- rule elim-intro: (elim (intro $dlbl $clbl $args) $mot $clauses) ~>
--   (apply-clause (lookup $clbl $clauses) $args) ;


-- Implementation Plan:
-- --------------------
--
-- 1. Add Core IR types to Lego (Term.lean)
--    - Explicit de Bruijn indices
--    - Binders with optional names
--    - Commands (head + spine)
--
-- 2. Add elaboration rules (Redtt.lego)
--    - Surface syntax patterns
--    - Core IR templates
--    - Bidirectional typing
--
-- 3. Add reduction rules
--    - β-reduction
--    - Kan operations
--    - Data elimination
--
-- 4. Add validation
--    - Scope checking
--    - Kind checking
--    - Universe checking
