<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Music.lego IDE</title>
    <style>
        :root {
            --bg-dark: #1e1e2e;
            --bg-panel: #262637;
            --bg-editor: #1a1a2a;
            --bg-hover: #313145;
            --accent: #7c3aed;
            --accent-light: #a78bfa;
            --accent-green: #22c55e;
            --accent-red: #ef4444;
            --accent-yellow: #eab308;
            --text: #e2e8f0;
            --text-dim: #94a3b8;
            --border: #3f3f5a;
        }
        
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: 'SF Mono', 'Fira Code', Consolas, monospace;
            background: var(--bg-dark);
            color: var(--text);
            height: 100vh;
            overflow: hidden;
        }
        
        .ide {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        /* Toolbar */
        .toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem 1rem;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            height: 48px;
        }
        
        .toolbar-left, .toolbar-center, .toolbar-right {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .logo {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--accent-light);
        }
        
        .example-select {
            padding: 0.4rem 0.75rem;
            background: var(--bg-dark);
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: 4px;
            font-family: inherit;
            font-size: 0.85rem;
            cursor: pointer;
        }
        
        .example-select:focus { outline: none; border-color: var(--accent); }
        
        .btn-play, .btn-stop {
            padding: 0.5rem 1.5rem;
            border: none;
            border-radius: 4px;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-play {
            background: var(--accent-green);
            color: white;
        }
        
        .btn-play:hover { filter: brightness(1.1); }
        
        .btn-stop {
            background: var(--accent-red);
            color: white;
        }
        
        .btn-toggle {
            padding: 0.4rem 0.75rem;
            background: transparent;
            color: var(--text-dim);
            border: 1px solid var(--border);
            border-radius: 4px;
            font-family: inherit;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-toggle:hover { background: var(--bg-hover); }
        .btn-toggle.active { background: var(--accent); color: white; border-color: var(--accent); }
        
        /* Main Area */
        .ide-main {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        /* Editor Pane */
        .editor-pane {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 400px;
            border-right: 1px solid var(--border);
        }
        
        .editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            font-size: 0.8rem;
            color: var(--text-dim);
        }
        
        .parse-status .status-ok { color: var(--accent-green); }
        .parse-status .status-err { color: var(--accent-red); }
        
        .code-editor {
            flex: 1;
            width: 100%;
            padding: 1rem;
            background: var(--bg-editor);
            color: var(--text);
            border: none;
            font-family: 'SF Mono', 'Fira Code', Consolas, monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            resize: none;
            tab-size: 2;
        }
        
        .code-editor:focus { outline: none; }
        
        /* Sidebar */
        .sidebar {
            width: 380px;
            display: flex;
            flex-direction: column;
            background: var(--bg-panel);
            overflow-y: auto;
        }
        
        .panel-header {
            padding: 0.75rem 1rem;
            font-size: 0.75rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--accent-light);
            border-bottom: 1px solid var(--border);
        }
        
        /* Diagram Panel */
        .diagram-panel {
            border-bottom: 1px solid var(--border);
        }
        
        .diagram-content {
            padding: 1rem;
            font-size: 0.8rem;
            max-height: 250px;
            overflow-y: auto;
        }
        
        .diagram-error {
            color: var(--accent-red);
        }
        
        .ast-tree {
            font-family: 'SF Mono', monospace;
        }
        
        .ast-con-name {
            color: var(--accent-light);
            font-weight: bold;
        }
        
        .ast-var { color: var(--accent-yellow); }
        .ast-num { color: var(--accent-green); }
        .ast-lit { color: #f472b6; }
        
        .ast-con-args {
            padding-left: 1rem;
            border-left: 1px solid var(--border);
            margin-left: 0.5rem;
        }
        
        /* Tutorial Panel */
        .tutorial-panel {
            border-bottom: 1px solid var(--border);
            max-height: 50vh;
            display: flex;
            flex-direction: column;
        }
        
        .tutorial-content {
            padding: 1rem;
            font-size: 0.85rem;
            overflow-y: auto;
            flex: 1;
            line-height: 1.6;
        }
        
        .tutorial-markdown h3 {
            color: var(--accent);
            font-size: 1.1rem;
            margin: 0 0 0.75rem 0;
            border-bottom: 1px solid var(--border);
            padding-bottom: 0.5rem;
        }
        
        .tutorial-markdown h4 {
            color: var(--accent-light);
            font-size: 0.95rem;
            margin: 1rem 0 0.5rem 0;
        }
        
        .tutorial-markdown p {
            margin: 0.5rem 0;
            color: var(--text);
        }
        
        .tutorial-markdown li {
            margin: 0.25rem 0;
            padding-left: 0.5rem;
            color: var(--text-dim);
        }
        
        .tutorial-markdown .table-row {
            font-size: 0.75rem;
            background: var(--bg-editor);
            padding: 0.1rem 0.5rem;
            margin: 0;
            border-radius: 2px;
            color: var(--text-dim);
        }
        
        .tutorial-markdown code {
            background: var(--bg-editor);
            padding: 0.1rem 0.3rem;
            border-radius: 3px;
            color: var(--accent-yellow);
            font-size: 0.85em;
        }
        
        .tutorial-markdown strong {
            color: var(--accent-light);
        }
        
        /* Controls Panel */
        .controls-panel {
            flex: 1;
        }
        
        .controls-content {
            padding: 1rem;
        }
        
        .slider-control {
            margin-bottom: 0.75rem;
        }
        
        .slider-control label {
            display: block;
            font-size: 0.75rem;
            color: var(--text-dim);
            margin-bottom: 0.25rem;
        }
        
        .slider-control input[type="range"] {
            width: calc(100% - 50px);
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            appearance: none;
            cursor: pointer;
        }
        
        .slider-control input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }
        
        .slider-value {
            display: inline-block;
            width: 45px;
            text-align: right;
            font-size: 0.75rem;
            color: var(--text-dim);
        }
        
        .control-group {
            margin: 1rem 0;
        }
        
        .control-group label {
            display: block;
            font-size: 0.75rem;
            color: var(--text-dim);
            margin-bottom: 0.5rem;
        }
        
        .waveform-buttons {
            display: flex;
            gap: 0.5rem;
        }
        
        .waveform-btn {
            width: 40px;
            height: 40px;
            background: var(--bg-dark);
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 1.25rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .waveform-btn:hover { border-color: var(--accent); }
        .waveform-btn.active { background: var(--accent); border-color: var(--accent); }
        
        .adsr-label {
            font-size: 0.75rem;
            font-weight: bold;
            color: var(--accent-light);
            margin: 1rem 0 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px solid var(--border);
        }
        
        /* Score Visualization */
        .score-panel {
            height: 280px;
            background: var(--bg-dark);
            border-top: 2px solid var(--accent);
            position: relative;
        }
        
        .score-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.3rem 1rem;
            background: var(--bg-panel);
            font-size: 0.8rem;
            color: var(--accent);
        }
        
        .score-toggle {
            background: transparent;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            font-size: 1rem;
        }
        
        .score-playhead {
            position: absolute;
            left: 90px;
            top: 28px;
            width: 3px;
            height: calc(100% - 28px);
            background: var(--accent);
            z-index: 10;
            box-shadow: 0 0 10px var(--accent);
        }
        
        .score-voices {
            padding: 0.25rem 0.5rem;
            height: calc(100% - 28px);
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        .score-voice {
            display: flex;
            align-items: center;
            height: 32px;
            margin-bottom: 2px;
        }
        
        .score-instrument {
            width: 80px;
            font-size: 0.7rem;
            color: var(--text-dim);
            padding-right: 8px;
            text-align: right;
            flex-shrink: 0;
        }
        
        .score-notes {
            display: flex;
            gap: 2px;
            transition: transform 0.15s ease-out;
        }
        
        .score-note {
            min-width: 32px;
            height: 26px;
            padding: 0 2px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.6rem;
            font-weight: 700;
            color: #1a1a2e;
            opacity: 0.35;
            flex-shrink: 0;
            white-space: nowrap;
        }
        
        .score-note.active {
            opacity: 1;
            transform: scale(1.15);
            box-shadow: 0 0 12px currentColor;
            z-index: 5;
        }
        
        /* Console */
        .console {
            height: 120px;
            background: var(--bg-dark);
            border-top: 1px solid var(--border);
        }
        
        .console-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            background: var(--bg-panel);
            font-size: 0.75rem;
            color: var(--text-dim);
        }
        
        .console-clear {
            padding: 0.2rem 0.5rem;
            background: transparent;
            color: var(--text-dim);
            border: 1px solid var(--border);
            border-radius: 3px;
            font-size: 0.7rem;
            cursor: pointer;
        }
        
        .console-clear:hover { background: var(--bg-hover); }
        
        .console-output {
            padding: 0.5rem 1rem;
            height: calc(100% - 32px);
            overflow-y: auto;
            font-size: 0.8rem;
        }
        
        .console-line {
            padding: 0.15rem 0;
            color: var(--text-dim);
        }
        
        /* Responsive */
        @media (max-width: 900px) {
            .sidebar { width: 250px; }
        }
        
        @media (max-width: 700px) {
            .sidebar { display: none; }
            .toolbar-right { display: none; }
        }
    </style>
</head>
<body>
    <div id="app"></div>
    <script src="elm.js"></script>
    <script>
        // Initialize Elm app with ports
        var app = Elm.Main.init({
            node: document.getElementById('app')
        });
        
        // ==========================================
        // EVALUATOR: Handle let bindings and functions
        // ==========================================
        
        function evaluate(ast, env = {}) {
            if (!ast) return ast;
            
            // Handle Program (multiple expressions)
            if (ast.type === 'con' && ast.name === 'Program') {
                let result = null;
                let currentEnv = { ...env };
                
                for (const expr of ast.args) {
                    const evaluated = evaluate(expr, currentEnv);
                    // If it's a let binding, update env
                    if (expr.type === 'con' && expr.name === 'let') {
                        const name = expr.args[0]?.name;
                        if (name) {
                            currentEnv[name] = evaluated;
                        }
                    } else {
                        result = evaluated;
                    }
                }
                return result;
            }
            
            // Handle let binding: (let name value)
            if (ast.type === 'con' && ast.name === 'let') {
                const name = ast.args[0]?.name;
                const value = evaluate(ast.args[1], env);
                // Return the value (caller updates env)
                return value;
            }
            
            // Handle fn (lambda): (fn (params...) body) or (fn param body)
            if (ast.type === 'con' && ast.name === 'fn') {
                // Get params - could be (fn (x y) body) or (fn x body)
                let params = [];
                const paramArg = ast.args[0];
                if (paramArg?.type === 'con') {
                    // Multiple params in a list
                    params = paramArg.args?.map(a => a.name || a.value) || [];
                } else if (paramArg?.type === 'var') {
                    // Single param
                    params = [paramArg.name];
                } else if (paramArg?.type === 'num') {
                    params = [String(paramArg.value)];
                }
                
                return {
                    type: 'closure',
                    params: params,
                    body: ast.args[1],
                    env: { ...env }
                };
            }
            
            // Handle arithmetic: (+, -, *, %)
            if (ast.type === 'con' && ['+', '-', '*', '%'].includes(ast.name)) {
                const a = toNumber(evaluate(ast.args[0], env));
                const b = toNumber(evaluate(ast.args[1], env));
                let result;
                switch (ast.name) {
                    case '+': result = a + b; break;
                    case '-': result = a - b; break;
                    case '*': result = a * b; break;
                    case '%': result = ((a % b) + b) % b; break; // Proper modulo
                }
                return { type: 'num', value: result };
            }
            
            // Handle variable reference
            if (ast.type === 'var') {
                if (env.hasOwnProperty(ast.name)) {
                    return env[ast.name];
                }
                return ast; // Return as-is if not bound
            }
            
            // Handle function application
            if (ast.type === 'con') {
                // Check if the constructor name is a bound function
                if (env.hasOwnProperty(ast.name)) {
                    const fn = env[ast.name];
                    if (fn && fn.type === 'closure') {
                        // Apply function
                        const newEnv = { ...fn.env };
                        fn.params.forEach((param, i) => {
                            newEnv[param] = evaluate(ast.args[i], env);
                        });
                        return evaluate(fn.body, newEnv);
                    } else {
                        // It's a value, not a function - return it
                        return fn;
                    }
                }
                
                // Recursively evaluate arguments
                return {
                    type: 'con',
                    name: ast.name,
                    args: ast.args.map(arg => evaluate(arg, env))
                };
            }
            
            return ast;
        }
        
        function toNumber(ast) {
            if (!ast) return 0;
            if (ast.type === 'num') return ast.value;
            if (ast.type === 'var') return parseInt(ast.name) || 0;
            return 0;
        }
        
        // ==========================================
        // WebAudio Synthesizer
        // ==========================================
        
        let audioCtx = null;
        let activeOscillators = [];
        let activeGains = [];
        let playbackTimeout = null;
        let noteTimeouts = [];  // Track all scheduled note timeouts
        
        // Orchestral instrument presets - refined for better sound
        const instruments = {
            'Flute': {
                waveform: 'sine',
                adsr: { attack: 0.12, decay: 0.15, sustain: 0.6, release: 0.25 },
                vibrato: { rate: 5.5, depth: 2 },
                filterFreq: 6000,
                filterQ: 0.3,
                gain: 0.35
            },
            'Clarinet': {
                waveform: 'triangle',  // Softer than square
                adsr: { attack: 0.08, decay: 0.12, sustain: 0.65, release: 0.18 },
                vibrato: { rate: 4.5, depth: 1.5 },
                filterFreq: 2000,
                filterQ: 1.5,
                gain: 0.3
            },
            'Oboe': {
                waveform: 'triangle',
                adsr: { attack: 0.06, decay: 0.1, sustain: 0.55, release: 0.15 },
                vibrato: { rate: 5.2, depth: 2.5 },
                filterFreq: 2800,
                filterQ: 2.5,
                gain: 0.28
            },
            'Bassoon': {
                waveform: 'triangle',
                adsr: { attack: 0.1, decay: 0.18, sustain: 0.6, release: 0.25 },
                vibrato: { rate: 4, depth: 1.5 },
                filterFreq: 1000,
                filterQ: 1.2,
                gain: 0.35
            },
            'Trumpet': {
                waveform: 'sawtooth',
                adsr: { attack: 0.04, decay: 0.08, sustain: 0.7, release: 0.12 },
                vibrato: { rate: 5.5, depth: 2 },
                filterFreq: 2500,
                filterQ: 0.8,
                gain: 0.25
            },
            'Saxophone': {
                waveform: 'triangle',
                adsr: { attack: 0.06, decay: 0.15, sustain: 0.65, release: 0.2 },
                vibrato: { rate: 5, depth: 3 },
                filterFreq: 2400,
                filterQ: 2,
                gain: 0.32
            },
            'Strings': {
                waveform: 'sawtooth',
                adsr: { attack: 0.4, decay: 0.3, sustain: 0.7, release: 0.6 },
                vibrato: { rate: 5.5, depth: 3 },
                filterFreq: 3000,
                filterQ: 0.5,
                gain: 0.22
            },
            'Piano': {
                waveform: 'triangle',
                adsr: { attack: 0.005, decay: 0.4, sustain: 0.2, release: 0.4 },
                vibrato: null,
                filterFreq: 4500,
                filterQ: 0.3,
                gain: 0.4
            }
        };
        
        // Play a note with a specific instrument and stereo panning
        function playInstrumentNote(midi, instrumentName, volume, duration = 1, pan = 0) {
            const ctx = getAudioContext();
            const inst = instruments[instrumentName] || instruments['Piano'];
            const now = Math.max(0, ctx.currentTime);
            const freq = midiToFreq(midi);
            
            // Stereo panner (-1 = left, 0 = center, 1 = right)
            const panner = ctx.createStereoPanner();
            panner.pan.value = Math.max(-1, Math.min(1, pan));
            
            // Main oscillator
            const osc = ctx.createOscillator();
            osc.type = inst.waveform;
            osc.frequency.value = freq;
            
            // Vibrato LFO
            if (inst.vibrato) {
                const lfo = ctx.createOscillator();
                const lfoGain = ctx.createGain();
                lfo.frequency.value = inst.vibrato.rate;
                lfoGain.gain.value = inst.vibrato.depth;
                lfo.connect(lfoGain);
                lfoGain.connect(osc.frequency);
                lfo.start(now);
                lfo.stop(now + duration + 0.1);
            }
            
            // Filter for timbre
            const filter = ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = inst.filterFreq;
            filter.Q.value = inst.filterQ;
            
            // Gain envelope
            const gain = ctx.createGain();
            const { attack, decay, sustain, release } = inst.adsr;
            const vol = volume * inst.gain;
            
            // Ensure timing is valid (all values must be >= now)
            const safeNow = Math.max(0, now);
            const sustainEnd = Math.max(safeNow, safeNow + duration - release);
            
            gain.gain.setValueAtTime(0, safeNow);
            gain.gain.linearRampToValueAtTime(vol, safeNow + attack);
            gain.gain.linearRampToValueAtTime(vol * sustain, safeNow + attack + decay);
            gain.gain.setValueAtTime(vol * sustain, sustainEnd);
            gain.gain.linearRampToValueAtTime(0, safeNow + duration);
            
            // Connect: osc -> filter -> gain -> panner -> output
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(panner);
            panner.connect(ctx.destination);
            
            osc.start(safeNow);
            osc.stop(safeNow + duration + 0.1);
            
            activeOscillators.push(osc);
            activeGains.push(gain);
            
            return osc;
        }
        
        // Play sequence with specific instrument
        function playInstrumentSequence(notes, instrumentName, volume, tempo) {
            const noteDuration = 60 / tempo;
            notes.forEach((midi, i) => {
                setTimeout(() => {
                    playInstrumentNote(midi, instrumentName, volume, noteDuration * 0.98);
                }, i * noteDuration * 1000);
            });
        }
        
        // Chord intervals by type
        const chordIntervals = {
            'Major': [0, 4, 7],
            'Minor': [0, 3, 7],
            'Dim': [0, 3, 6],
            'Aug': [0, 4, 8],
            'Maj7': [0, 4, 7, 11],
            'Min7': [0, 3, 7, 10],
            'Dom7': [0, 4, 7, 10],
            '7': [0, 4, 7, 10],
            'Sus2': [0, 2, 7],
            'Sus4': [0, 5, 7],
        };
        
        function buildChord(rootPC, chordType, octave) {
            const intervals = chordIntervals[chordType] || chordIntervals['Major'];
            const baseMidi = rootPC + (octave + 1) * 12;
            return intervals.map(i => baseMidi + i);
        }
        
        function getAudioContext() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            return audioCtx;
        }
        
        function midiToFreq(midi) {
            return 440 * Math.pow(2, (midi - 69) / 12);
        }
        
        function stopAll() {
            if (playbackTimeout) {
                clearTimeout(playbackTimeout);
                playbackTimeout = null;
            }
            // Clear all scheduled note timeouts
            noteTimeouts.forEach(t => clearTimeout(t));
            noteTimeouts = [];
            
            activeOscillators.forEach(osc => {
                try { osc.stop(); } catch(e) {}
            });
            activeOscillators = [];
            activeGains = [];
        }
        
        function scheduleFinish(durationMs) {
            if (playbackTimeout) clearTimeout(playbackTimeout);
            playbackTimeout = setTimeout(() => {
                app.ports.audioFinished.send(null);
            }, durationMs);
        }
        
        function playNote(midi, waveform, adsr, volume, duration = 1) {
            const ctx = getAudioContext();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            
            osc.connect(gain);
            gain.connect(ctx.destination);
            
            osc.frequency.value = midiToFreq(midi);
            osc.type = waveform;
            
            const now = ctx.currentTime;
            const { attack, decay, sustain, release } = adsr;
            
            // ADSR envelope
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(volume, now + attack);
            gain.gain.linearRampToValueAtTime(volume * sustain, now + attack + decay);
            gain.gain.setValueAtTime(volume * sustain, now + duration - release);
            gain.gain.linearRampToValueAtTime(0, now + duration);
            
            osc.start(now);
            osc.stop(now + duration + 0.1);
            
            activeOscillators.push(osc);
            activeGains.push(gain);
            
            return osc;
        }
        
        function playChord(notes, waveform, adsr, volume, duration = 1) {
            // Slight strum effect - stagger note starts by 30ms each
            notes.forEach((midi, i) => {
                setTimeout(() => {
                    playNote(midi, waveform, adsr, volume * 0.5, duration);
                }, i * 30);
            });
        }
        
        function playSequence(notes, waveform, adsr, volume, tempo) {
            const noteDuration = 60 / tempo;
            notes.forEach((midi, i) => {
                setTimeout(() => {
                    playNote(midi, waveform, adsr, volume, noteDuration * 0.98);
                }, i * noteDuration * 1000);
            });
        }
        
        // Standard guitar tuning MIDI values (open strings)
        const guitarTuning = {
            6: 40,  // Low E
            5: 45,  // A
            4: 50,  // D
            3: 55,  // G
            2: 59,  // B
            1: 64   // High E
        };
        
        // Parse note shorthand like C5, Fs4, Bb3
        function parseNoteShorthand(name) {
            const noteMap = {
                'C': 0, 'Cs': 1, 'Db': 1,
                'D': 2, 'Ds': 3, 'Eb': 3,
                'E': 4, 'Fb': 4,
                'F': 5, 'Es': 5, 'Fs': 6, 'Gb': 6,
                'G': 7, 'Gs': 8, 'Ab': 8,
                'A': 9, 'As': 10, 'Bb': 10,
                'B': 11, 'Cb': 11
            };
            
            // Match note name + octave: C5, Fs4, Bb3
            const match = name.match(/^([A-G][sb]?)(\d)$/);
            if (match) {
                const noteName = match[1];
                const octave = parseInt(match[2]);
                if (noteMap.hasOwnProperty(noteName)) {
                    const pc = noteMap[noteName];
                    return pc + (octave + 1) * 12;
                }
            }
            return null;
        }
        
        // Extract notes from AST
        function extractNotes(ast, octaveOffset = 0) {
            if (!ast) return [];
            
            if (ast.type === 'con') {
                // Check for note shorthand first (C5, Fs4, etc.)
                const shorthandMidi = parseNoteShorthand(ast.name);
                if (shorthandMidi !== null) {
                    return [shorthandMidi + octaveOffset * 12];
                }
                
                switch (ast.name) {
                    case 'Note':
                        const pc = extractPC(ast.args[0]);
                        const oct = extractOct(ast.args[1]) + octaveOffset;
                        return [pc + (oct + 1) * 12];
                    
                    case 'String':
                        // Guitar string: (String stringNum fret)
                        const stringNum = extractNum(ast.args[0]);
                        const fret = extractNum(ast.args[1]);
                        const openString = guitarTuning[stringNum] || 64;
                        return [openString + fret];
                    
                    case 'Tab':
                        // Guitar tab: (Tab tuning String1 String2 ...)
                        // Skip first arg (tuning name), extract all String children
                        return ast.args.slice(1).flatMap(arg => extractNotes(arg, octaveOffset));
                    
                    case 'Chord':
                        // Check if shorthand: (Chord (PC n) Type) vs full: (Chord (Note...) ...)
                        if (ast.args.length >= 1 && ast.args[0]?.type === 'con' && ast.args[0]?.name === 'PC') {
                            // Shorthand chord notation
                            const rootPC = extractPC(ast.args[0]);
                            const chordType = ast.args[1]?.name || 'Major';
                            return buildChord(rootPC, chordType, 4 + octaveOffset);
                        }
                        // Full notation with Note children
                        return ast.args.flatMap(arg => extractNotes(arg, octaveOffset));
                    
                    case 'Sequence':
                    case 'Arpeggio':
                        return ast.args.flatMap(arg => extractNotes(arg, octaveOffset));
                    
                    case 'Repeat':
                        // (Repeat n melody) - repeat melody n times
                        const repeatCount = extractNum(ast.args[0]);
                        const repeatMelody = ast.args[1];
                        const repeatNotes = extractNotes(repeatMelody, octaveOffset);
                        let result = [];
                        for (let i = 0; i < repeatCount; i++) {
                            result = result.concat(repeatNotes);
                        }
                        return result;
                    
                    case 'Progression':
                        // For progression, flatten all chords into one array
                        return ast.args.flatMap(arg => extractNotes(arg, octaveOffset));
                    
                    case 'Voice':
                        // (Voice Instrument melody) - extract notes from melody
                        return ast.args.slice(1).flatMap(arg => extractNotes(arg, octaveOffset));
                    
                    case 'Score':
                        // (Score voice1 voice2 ...) - extract from all voices
                        return ast.args.flatMap(arg => extractNotes(arg, octaveOffset));
                    
                    case 'PC':
                        return [];
                    
                    case 'Oct':
                        return [];
                    
                    default:
                        return ast.args.flatMap(arg => extractNotes(arg, octaveOffset));
                }
            }
            return [];
        }
        
        // Extract voices with instruments from Score (with orchestration info)
        function extractVoices(ast, octaveOffset = 0) {
            if (!ast) return [];
            
            if (ast.type === 'con') {
                if (ast.name === 'Voice') {
                    const instrument = ast.args[0]?.name || 'Piano';
                    const melody = ast.args[1];
                    const { notes, entry, crescendoStart, crescendoEnd, pan } = extractOrchestration(melody, octaveOffset);
                    return [{ instrument, notes, entry, crescendoStart, crescendoEnd, pan }];
                }
                if (ast.name === 'Score') {
                    return ast.args.flatMap(arg => extractVoices(arg, octaveOffset));
                }
            }
            return [];
        }
        
        // Extract notes with orchestration metadata (Entry, Crescendo, Pan)
        function extractOrchestration(ast, octaveOffset = 0) {
            let entry = 0;
            let crescendoStart = 1.0;
            let crescendoEnd = 1.0;
            let pan = 0;  // -1 = left, 0 = center, 1 = right
            let currentAst = ast;
            
            // Unwrap orchestration constructs
            while (currentAst && currentAst.type === 'con') {
                if (currentAst.name === 'Entry') {
                    entry = extractNum(currentAst.args[0]);
                    currentAst = currentAst.args[1];
                } else if (currentAst.name === 'Crescendo') {
                    crescendoStart = extractNum(currentAst.args[0]) || 0.3;
                    crescendoEnd = extractNum(currentAst.args[1]) || 1.0;
                    currentAst = currentAst.args[2];
                } else if (currentAst.name === 'Pan') {
                    pan = extractNum(currentAst.args[0]) || 0;
                    currentAst = currentAst.args[1];
                } else {
                    break;
                }
            }
            
            const notes = extractNotes(currentAst, octaveOffset);
            return { notes, entry, crescendoStart, crescendoEnd, pan };
        }
        
        // Orchestrator: controls instrument entry and dynamics based on DSL
        function orchestrate(voice, noteIndex, maxNotes, baseVolume, notesPerSection) {
            const entryNote = voice.entry * notesPerSection;
            
            if (noteIndex < entryNote) {
                return 0; // Not yet entered
            }
            
            // Calculate crescendo based on DSL values
            const progress = (noteIndex - entryNote) / (maxNotes - entryNote);
            const crescendo = voice.crescendoStart + (progress * (voice.crescendoEnd - voice.crescendoStart));
            
            // Fade in when entering
            const notesSinceEntry = noteIndex - entryNote;
            const fadeIn = Math.min(1, notesSinceEntry / 8); // 8 notes to fade in
            
            return baseVolume * crescendo * fadeIn;
        }
        
        // Play a score with multiple voices/instruments
        function playScore(voices, volume, tempo) {
            if (voices.length === 0) {
                scheduleFinish(100);
                return;
            }
            
            const noteDuration = 60 / tempo;
            let maxNotes = Math.max(...voices.map(v => v.notes.length));
            const totalDuration = maxNotes * noteDuration * 1000;
            
            // Calculate notes per section (for Entry timing)
            // Assume theme is ~27 notes, so each Entry unit = 27 notes
            const notesPerSection = 27;
            
            // Prepare score data for visualization
            const scoreData = voices.map(v => ({
                instrument: v.instrument,
                notes: v.notes
            }));
            
            // Send initial score update
            if (app && app.ports && app.ports.scoreUpdate) {
                app.ports.scoreUpdate.send({
                    voices: scoreData,
                    position: 0
                });
            }
            
            // Clear any previous note timeouts
            noteTimeouts = [];
            
            voices.forEach((voice) => {
                voice.notes.forEach((midi, i) => {
                    const timeout = setTimeout(() => {
                        // Use DSL-based orchestrator for dynamic volume
                        const dynamicVolume = orchestrate(voice, i, maxNotes, volume, notesPerSection);
                        if (dynamicVolume > 0) {
                            playInstrumentNote(midi, voice.instrument, dynamicVolume, noteDuration * 0.98, voice.pan || 0);
                        }
                        // Update playhead position
                        if (app && app.ports && app.ports.scoreUpdate) {
                            app.ports.scoreUpdate.send({
                                voices: scoreData,
                                position: i
                            });
                        }
                    }, i * noteDuration * 1000);
                    noteTimeouts.push(timeout);
                });
            });
            
            scheduleFinish(totalDuration + 500);
        }
        
        function extractPC(ast) {
            if (ast && ast.type === 'con' && ast.name === 'PC' && ast.args[0]) {
                if (ast.args[0].type === 'num') return ast.args[0].value;
                if (ast.args[0].type === 'var') return parseInt(ast.args[0].name) || 0;
            }
            return 0;
        }
        
        function extractOct(ast) {
            if (ast && ast.type === 'con' && ast.name === 'Oct' && ast.args[0]) {
                if (ast.args[0].type === 'num') return ast.args[0].value;
                if (ast.args[0].type === 'var') return parseInt(ast.args[0].name) || 4;
            }
            return 4;
        }
        
        function extractNum(ast) {
            if (!ast) return 0;
            if (ast.type === 'num') return ast.value;
            if (ast.type === 'var') return parseInt(ast.name) || 0;
            return 0;
        }
        
        function getPlayMode(ast) {
            if (!ast || ast.type !== 'con') return 'note';
            switch (ast.name) {
                case 'Score': return 'score';  // Multiple voices/instruments
                case 'Voice': return 'voice';  // Single instrument
                case 'Chord': return 'chord';
                case 'Sequence': return 'sequence';
                case 'Arpeggio': return 'arpeggio';
                case 'Progression': return 'progression';
                case 'Tab': return 'chord';  // Guitar tab plays as chord
                case 'Pattern': return 'pattern';  // Drum pattern
                default: return 'note';
            }
        }
        
        // Drum sound MIDI mappings (General MIDI drum map)
        const drumSounds = {
            'Kick': 36,
            'Snare': 38,
            'HiHat': 42,
            'OpenHat': 46,
            'Crash': 49,
            'Ride': 51,
            'Tom': 45,
            'TomHigh': 50,
            'TomLow': 41,
            'Clap': 39,
            'Rim': 37
        };
        
        // Extract beats from drum pattern
        function extractBeats(ast) {
            if (!ast || ast.type !== 'con' || ast.name !== 'Pattern') return [];
            
            const tempo = extractNum(ast.args[0]);
            const beats = [];
            
            for (let i = 1; i < ast.args.length; i++) {
                const beat = ast.args[i];
                if (beat && beat.type === 'con' && beat.name === 'Beat') {
                    const beatTime = extractNum(beat.args[0]);
                    const drumName = beat.args[1]?.name || 'Kick';
                    const drumMidi = drumSounds[drumName] || 36;
                    beats.push({ time: beatTime, midi: drumMidi, name: drumName });
                }
            }
            
            return { tempo, beats };
        }
        
        function playDrumPattern(patternData, volume) {
            const { tempo, beats } = patternData;
            if (!beats || beats.length === 0) {
                scheduleFinish(100);
                return;
            }
            
            const beatDuration = 60 / tempo; // seconds per beat
            const maxBeat = Math.max(...beats.map(b => b.time));
            const totalDuration = (maxBeat + 1) * beatDuration * 1000;
            
            beats.forEach(beat => {
                setTimeout(() => {
                    // Use noise-based synthesis for drums
                    playDrumSound(beat.midi, beat.name, volume);
                }, (beat.time - 1) * beatDuration * 1000);
            });
            
            scheduleFinish(totalDuration + 500);
        }
        
        function playDrumSound(midi, name, volume) {
            const ctx = getAudioContext();
            const now = ctx.currentTime;
            
            if (name === 'Kick') {
                // Kick drum: sine wave pitch drop
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
                gain.gain.setValueAtTime(volume, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            } else if (name === 'Snare') {
                // Snare: noise burst + tone
                const noise = ctx.createBufferSource();
                const noiseBuffer = ctx.createBuffer(1, ctx.sampleRate * 0.2, ctx.sampleRate);
                const data = noiseBuffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
                noise.buffer = noiseBuffer;
                
                const noiseGain = ctx.createGain();
                noise.connect(noiseGain);
                noiseGain.connect(ctx.destination);
                noiseGain.gain.setValueAtTime(volume * 0.5, now);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                noise.start(now);
                
                const osc = ctx.createOscillator();
                const oscGain = ctx.createGain();
                osc.connect(oscGain);
                oscGain.connect(ctx.destination);
                osc.frequency.value = 180;
                oscGain.gain.setValueAtTime(volume * 0.3, now);
                oscGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (name === 'HiHat' || name === 'OpenHat') {
                // Hi-hat: filtered noise
                const noise = ctx.createBufferSource();
                const noiseBuffer = ctx.createBuffer(1, ctx.sampleRate * 0.1, ctx.sampleRate);
                const data = noiseBuffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
                noise.buffer = noiseBuffer;
                
                const filter = ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 7000;
                
                const gain = ctx.createGain();
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(ctx.destination);
                
                const decay = name === 'OpenHat' ? 0.3 : 0.05;
                gain.gain.setValueAtTime(volume * 0.3, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + decay);
                noise.start(now);
            } else {
                // Generic percussion: short tone
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.frequency.value = midiToFreq(midi);
                gain.gain.setValueAtTime(volume * 0.5, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            }
        }
        
        // Extract chords for progression (array of note arrays)
        function extractChords(ast, octaveOffset = 0) {
            if (!ast) return [];
            if (ast.type === 'con' && ast.name === 'Progression') {
                return ast.args.map(arg => extractNotes(arg, octaveOffset));
            }
            return [extractNotes(ast, octaveOffset)];
        }
        
        function playProgression(chords, waveform, adsr, volume, tempo) {
            const chordDuration = 60 / tempo * 2; // 2 beats per chord
            const totalDuration = chords.length * chordDuration * 1000;
            chords.forEach((notes, i) => {
                if (notes.length > 0) {
                    setTimeout(() => {
                        playChord(notes, waveform, adsr, volume, chordDuration * 0.9);
                    }, i * chordDuration * 1000);
                }
            });
            scheduleFinish(totalDuration + 500);
        }
        
        // Handle play command from Elm
        app.ports.playAudio.subscribe(function(data) {
            stopAll();
            
            const { ast: rawAst, volume, tempo, octave, waveform, adsr } = data;
            
            // Evaluate the AST (expand let bindings, apply functions)
            const ast = evaluate(rawAst);
            console.log('Evaluated AST:', ast);
            
            if (!ast) {
                console.log('No playable expression after evaluation');
                scheduleFinish(100);
                return;
            }
            
            const mode = getPlayMode(ast);
            
            // Handle Score with multiple instruments
            if (mode === 'score') {
                const voices = extractVoices(ast, octave - 4);
                console.log('Playing score:', voices);
                if (voices.length > 0) {
                    playScore(voices, volume, tempo);
                } else {
                    console.log('No voices to play');
                    scheduleFinish(100);
                }
                return;
            }
            
            // Handle single Voice with instrument
            if (mode === 'voice') {
                const voices = extractVoices(ast, octave - 4);
                console.log('Playing voice:', voices);
                if (voices.length > 0) {
                    playScore(voices, volume, tempo);
                } else {
                    console.log('No voice to play');
                    scheduleFinish(100);
                }
                return;
            }
            
            if (mode === 'progression') {
                const chords = extractChords(ast, octave - 4);
                console.log('Playing progression:', chords);
                if (chords.length > 0 && chords.some(c => c.length > 0)) {
                    playProgression(chords, waveform, adsr, volume, tempo);
                } else {
                    console.log('No chords to play');
                    scheduleFinish(100);
                }
                return;
            }
            
            if (mode === 'pattern') {
                const patternData = extractBeats(ast);
                console.log('Playing drum pattern:', patternData);
                playDrumPattern(patternData, volume);
                return;
            }
            
            const notes = extractNotes(ast, octave - 4);
            console.log('Playing:', mode, notes);
            
            if (notes.length === 0) {
                console.log('No notes to play');
                scheduleFinish(100);
                return;
            }
            
            switch (mode) {
                case 'chord':
                    playChord(notes, waveform, adsr, volume, 2);
                    scheduleFinish(2500);
                    break;
                case 'sequence':
                case 'arpeggio':
                    const seqDuration = notes.length * (60 / tempo) * 1000;
                    playSequence(notes, waveform, adsr, volume, tempo);
                    scheduleFinish(seqDuration + 500);
                    break;
                default:
                    if (notes.length === 1) {
                        playNote(notes[0], waveform, adsr, volume, 1);
                        scheduleFinish(1500);
                    } else {
                        const defaultDuration = notes.length * (60 / tempo) * 1000;
                        playSequence(notes, waveform, adsr, volume, tempo);
                        scheduleFinish(defaultDuration + 500);
                    }
            }
        });
        
        // Handle stop command from Elm
        app.ports.stopAudio.subscribe(function() {
            stopAll();
        });
    </script>
</body>
</html>
