-----------------------------------------------------
-- RosettaMath: Algebraically-Founded Intermediate Language
--
-- Rosetta redesigned from first principles:
-- Every construct corresponds to a mathematical structure.
-- No arbitrary primitives - only derived from algebra.
--
-- The 8 Layers:
--   1. Initial Algebras   (terms, recursion)
--   2. Functors           (traversals, mapping)
--   3. Limits/Colimits    (products, sums, pushouts)
--   4. Monads             (effects, handlers)
--   5. Profunctors        (optics, bidirectional)
--   6. Adjunctions        (free/forgetful)
--   7. Kan Extensions     (universal constructions)
--   8. Operads            (multi-arity composition)
--
-- Target leverage: 100-200x
-----------------------------------------------------

lang RosettaMath :=

-----------------------------------------------------
-- Layer 0: Universe Hierarchy
-- The categorical foundation: presheaves over a base
-----------------------------------------------------

piece Universe
  -- Universe levels (predicative)
  level ::= "â„“" number                          â†’ lconst      -- Constant level
          | "â„“" ident                           â†’ lvar        -- Level variable
          | level "âŠ”" level                     â†’ lmax        -- Maximum
          | level "+" number                    â†’ lsuc ;      -- Successor

  -- Universes indexed by level
  term ::= "Type" level                         â†’ univ        -- Type â„“
         | "Prop"                               â†’ prop ;      -- Prop (impredicative)

  -- Level polymorphism
  decl ::= "universe" ident+ ";" â†’ DUniverse ;

-----------------------------------------------------
-- Layer 1: Initial Algebras (F-Algebras)
-- The foundation: Î¼F = F(Î¼F)
-----------------------------------------------------

piece InitialAlgebra
  -- Functor declaration: F : Type â†’ Type
  decl ::= "functor" ident params? "=" functorBody ";" â†’ DFunctor ;
  params ::= "(" (ident ":" term)+ ")" â†’ params ;
  functorBody ::= "|" functorCase ("|" functorCase)* â†’ functorCases
                | functorCase ;
  functorCase ::= ident ":" term â†’ functorCase ;

  -- Initial algebra: Î¼F
  term ::= "Î¼" ident                            â†’ mu ;        -- Least fixpoint

  -- Catamorphism: the ONLY explicit recursion
  decl ::= "cata" ident "for" ident "with" cataBody ";" â†’ DCata ;
  cataBody ::= "{" cataCase+ "}" ;
  cataCase ::= ident "=>" template ";" â†’ cataCase ;

  -- Anamorphism: unfold
  decl ::= "ana" ident "for" ident "with" anaBody ";" â†’ DAna ;
  anaBody ::= "{" anaCase+ "}" ;
  anaCase ::= ident "=>" template ";" â†’ anaCase ;

  -- Hylomorphism: ana ; cata (no intermediate data structure)
  decl ::= "hylo" ident "=" ident ";" ident ";" â†’ DHylo ;

  -- Smart constructors (introduction)
  term ::= "In" term                            â†’ inF         -- In : F(Î¼F) â†’ Î¼F
         | "Out" term                           â†’ outF ;      -- Out : Î¼F â†’ F(Î¼F)

-----------------------------------------------------
-- Layer 1b: Terminal Coalgebras (F-Coalgebras)
-- The dual: Î½F = F(Î½F)
-----------------------------------------------------

piece TerminalCoalgebra
  -- Terminal coalgebra: Î½F (greatest fixpoint)
  term ::= "Î½" ident                            â†’ nu ;        -- Greatest fixpoint

  -- Corecursion: anamorphism to Î½
  term ::= "Unfold" term                        â†’ unfoldF     -- Unfold : Î½F â†’ F(Î½F)
         | "Fold" term                          â†’ foldF ;     -- Fold : F(Î½F) â†’ Î½F

  -- Bisimulation: equality for coalgebras
  decl ::= "bisim" ident ":" ident "~" ident "with" bisimBody ";" â†’ DBisim ;
  bisimBody ::= "{" cataCase+ "}" ;

-----------------------------------------------------
-- Layer 2: Natural Transformations (Polymorphism)
-- Î± : F âŸ¹ G means âˆ€X. F X â†’ G X
-----------------------------------------------------

piece NaturalTransformation
  -- Natural transformation declaration
  decl ::= ident ":" ident "âŸ¹" ident "=" ntBody ";" â†’ DNatTrans ;
  ntBody ::= "Î»" ident "." template â†’ ntLam
           | template ;

  -- Dinatural transformation (profunctors)
  decl ::= ident ":" ident "â¤‡" ident "=" template ";" â†’ DDinat ;

  -- Extranatural transformation
  decl ::= ident ":" ident "âŸ¾" ident "=" template ";" â†’ DExtranat ;

  -- Parametric polymorphism as naturality
  term ::= "âˆ€" "(" ident ":" term ")" "." term  â†’ forall
         | "[" ident "]" term                   â†’ tyApp ;     -- Type application

-----------------------------------------------------
-- Layer 3: Limits and Colimits
-- Products, sums, equalizers, and their duals
-----------------------------------------------------

piece Limits
  -- Product (limit of discrete diagram)
  term ::= term "Ã—" term                        â†’ prod
         | "(" term "," term ")"                â†’ pair
         | "Ï€â‚" term                            â†’ fst
         | "Ï€â‚‚" term                            â†’ snd ;

  rule fstBeta: (Ï€â‚ ($a, $b)) ~~> $a ;
  rule sndBeta: (Ï€â‚‚ ($a, $b)) ~~> $b ;
  rule pairEta: (($a, $b)) ~~> ($a, $b) when $p = ($a, $b), $a = (Ï€â‚ $p), $b = (Ï€â‚‚ $p) ;

  -- Dependent product (Î )
  term ::= "Î " "(" ident ":" term ")" "." term  â†’ pi
         | "Î»" ident "." term                   â†’ lam
         | term term                            â†’ app ;

  rule beta: ((Î» $x . $body) $arg) ~~> (subst $x $arg $body) ;

  -- Equalizer
  term ::= "Eq" term term term                  â†’ eq          -- Eq A f g
         | "eq" term                            â†’ eqIn ;      -- eq a : Eq A f g (when f a = g a)

piece Colimits
  -- Coproduct (colimit of discrete diagram)
  term ::= term "+" term                        â†’ coprod
         | "inl" term                           â†’ inl
         | "inr" term                           â†’ inr
         | "case" term term term                â†’ caseSum ;

  rule caseInl: (case (inl $a) $f $g) ~~> ($f $a) ;
  rule caseInr: (case (inr $b) $f $g) ~~> ($g $b) ;

  -- Dependent sum (Î£)
  term ::= "Î£" "(" ident ":" term ")" "." term  â†’ sigma
         | "âŸ¨" term "," term "âŸ©"                â†’ dpair
         | "prâ‚" term                           â†’ dfst
         | "prâ‚‚" term                           â†’ dsnd ;

  -- Coequalizer (quotient)
  term ::= "Coeq" term term term                â†’ coeq
         | "quot" term                          â†’ quotIn ;

  -- Initial and terminal
  term ::= "ðŸ˜"                                  â†’ initial     -- Initial object (Void)
         | "ðŸ™"                                  â†’ terminal    -- Terminal object (Unit)
         | "â˜…"                                  â†’ star ;      -- The element of ðŸ™

  rule initElim: (abort $e) ~~> (abort $e) ;   -- No Î² for Void
  rule termEta: $t ~~> â˜… when $t : ðŸ™ ;

-----------------------------------------------------
-- Layer 3b: Pushouts and Pullbacks
-- The key for language composition
-----------------------------------------------------

piece Pushouts
  -- Pushout: gluing along a shared part
  -- Given A â† C â†’ B, pushout is A âŠ•_C B
  decl ::= "pushout" ident ident ident "along" ident ident ";" â†’ DPushout ;

  term ::= ident "âŠ•" ident                      â†’ pushout     -- A âŠ•_C B
         | "Î¹â‚" term                            â†’ pushInl     -- Î¹â‚ : A â†’ A âŠ•_C B
         | "Î¹â‚‚" term                            â†’ pushInr     -- Î¹â‚‚ : B â†’ A âŠ•_C B
         | "glue" term                          â†’ pushGlue ;  -- glue : âˆ€c. Î¹â‚(f c) = Î¹â‚‚(g c)

  -- Universal property
  decl ::= "pushout-rec" ident ":" ident "with" pushRecBody ";" â†’ DPushoutRec ;
  pushRecBody ::= "{" "left" "=>" template ";"
                      "right" "=>" template ";"
                      "glue" "=>" template ";" "}" ;

piece Pullbacks
  -- Pullback: fiber product
  -- Given A â†’ C â† B, pullback is A Ã—_C B
  decl ::= "pullback" ident ident ident "over" ident ident ";" â†’ DPullback ;

  term ::= ident "Ã—" ident "over" ident         â†’ pullback
         | "pb" term term term                  â†’ pbPair ;    -- pb : (a,b,p) : A Ã—_C B

-----------------------------------------------------
-- Layer 4: Monads and Effects
-- T : C â†’ C with Î· : Id âŸ¹ T, Î¼ : Tâˆ˜T âŸ¹ T
-----------------------------------------------------

piece Monad
  -- Monad declaration from specification
  decl ::= "monad" ident "=" monadSpec ";" â†’ DMonad ;
  monadSpec ::= "Free" ident                    â†’ freeMonad
              | "State" ident                   â†’ stateMonad
              | "Reader" ident                  â†’ readerMonad
              | "Writer" ident                  â†’ writerMonad
              | "Error" ident                   â†’ errorMonad
              | "Cont" ident                    â†’ contMonad
              | monadSpec "âˆ˜" monadSpec         â†’ monadTrans
              | monadSpec "Ã—" monadSpec         â†’ monadProd ;

  -- Monad operations
  term ::= "pure" term                          â†’ mPure       -- Î· : A â†’ T A
         | term ">>=" term                      â†’ mBind       -- Î¼ âˆ˜ T f
         | "join" term                          â†’ mJoin ;     -- Î¼ : T(T A) â†’ T A

  rule bindPure: ((pure $a) >>= $f) ~~> ($f $a) ;
  rule pureUnit: ($m >>= pure) ~~> $m ;
  rule bindAssoc: (($m >>= $f) >>= $g) ~~> ($m >>= (Î» $x . ($f $x >>= $g))) ;

piece Comonad
  -- Comonad: dual of monad
  decl ::= "comonad" ident "=" comonadSpec ";" â†’ DComonad ;
  comonadSpec ::= "Cofree" ident                â†’ cofreeComonad
                | "Store" ident ident           â†’ storeComonad
                | "Env" ident                   â†’ envComonad
                | "Traced" ident                â†’ tracedComonad ;

  -- Comonad operations
  term ::= "extract" term                       â†’ wExtract    -- Îµ : W A â†’ A
         | "extend" term term                   â†’ wExtend     -- Î´ âˆ˜ W f
         | "duplicate" term                     â†’ wDup ;      -- Î´ : W A â†’ W(W A)

-----------------------------------------------------
-- Layer 4b: Algebraic Effects
-- More structured than monads
-----------------------------------------------------

piece Effects
  -- Effect signature
  decl ::= "effect" ident "{" effectOp* "}" â†’ DEffect ;
  effectOp ::= "op" ident ":" term "â†’" term ";" â†’ DEffectOp ;

  -- Effect handler
  decl ::= "handler" ident "for" ident "{" handlerCase* "}" â†’ DHandler ;
  handlerCase ::= "return" ident "=>" template ";" â†’ returnCase
                | ident ident ident "=>" template ";" â†’ opCase ;

  -- Effect terms
  term ::= "perform" ident term                 â†’ perform     -- Invoke operation
         | "handle" term "with" ident           â†’ handle ;    -- Handle effects

-----------------------------------------------------
-- Layer 5: Profunctors and Optics
-- P : C^op Ã— C â†’ Set
-----------------------------------------------------

piece Profunctor
  -- Profunctor declaration
  decl ::= "profunctor" ident ":" ident "â†›" ident "=" profBody ";" â†’ DProfunctor ;
  profBody ::= "Hom" â†’ homProf
             | ident "âˆ˜" ident â†’ composeProf
             | "Const" ident â†’ constProf ;

  -- Profunctor operations
  term ::= "dimap" term term term               â†’ dimap ;     -- dimap f g p

piece Optics
  -- Lens: get/set pair
  decl ::= "lens" ident ":" ident "âŸ·" ident "=" lensBody ";" â†’ DLens ;
  lensBody ::= "{" "get" "=" template ";" "set" "=" template ";" "}" ;

  -- Prism: match/build pair
  decl ::= "prism" ident ":" ident "âŸ·" ident "=" prismBody ";" â†’ DPrism ;
  prismBody ::= "{" "match" "=" template ";" "build" "=" template ";" "}" ;

  -- Iso: invertible function
  decl ::= "iso" ident ":" ident "â‰…" ident "=" isoBody ";" â†’ DIso ;
  isoBody ::= "{" "to" "=" template ";" "from" "=" template ";" "}" ;

  -- Traversal: focus on multiple targets
  decl ::= "traversal" ident ":" ident "âŸ¿" ident "=" template ";" â†’ DTraversal ;

  -- Optic operations
  term ::= "view" ident term                    â†’ view        -- view l s
         | "over" ident term term               â†’ over        -- over l f s
         | "set" ident term term                â†’ setOp ;     -- set l b s

-----------------------------------------------------
-- Layer 6: Adjunctions
-- F âŠ£ G means Hom(F A, B) â‰… Hom(A, G B)
-----------------------------------------------------

piece Adjunction
  -- Adjunction declaration
  decl ::= ident "âŠ£" ident ":" ident "â‡„" ident ";" â†’ DAdjunction ;

  -- Free/Forgetful adjunction
  decl ::= "free" ident "for" ident ";" â†’ DFreeAdj
         | "forgetful" ident ":" ident "â†’" ident ";" â†’ DForgetful ;

  -- Unit and counit
  term ::= "unit" ident term                    â†’ adjUnit     -- Î·_A : A â†’ GF A
         | "counit" ident term                  â†’ adjCounit ; -- Îµ_A : FG A â†’ A

  -- Transpose
  term ::= "transpose" ident term               â†’ transpose   -- Hom isomorphism
         | "cotranspose" ident term             â†’ cotransp ;

-----------------------------------------------------
-- Layer 7: Kan Extensions
-- "All concepts are Kan extensions" - Mac Lane
-----------------------------------------------------

piece KanExtension
  -- Left Kan extension: Lan_K F
  decl ::= "lan" ident "along" ident "=" lanBody ";" â†’ DLan ;
  lanBody ::= "âˆ«" ident "." term "Ã—" term       â†’ lanCoend    -- Coend formula
            | template ;

  -- Right Kan extension: Ran_K F
  decl ::= "ran" ident "along" ident "=" ranBody ";" â†’ DRan ;
  ranBody ::= "âˆ«" ident "." term "â†’" term       â†’ ranEnd      -- End formula
            | template ;

  -- Special cases
  decl ::= "yoneda" ident ";" â†’ DYoneda                       -- Yoneda: C â†’ [C^op, Set]
         | "coYoneda" ident ";" â†’ DCoYoneda                   -- CoYoneda: C â†’ [C, Set]^op
         | "codensity" ident ";" â†’ DCodensity                 -- Ran_G G
         | "density" ident ";" â†’ DDensity ;                   -- Lan_G G

  -- Universal property terms
  term ::= "Lan" ident ident                    â†’ lan         -- Lan_K F X
         | "Ran" ident ident                    â†’ ran         -- Ran_K F X
         | "lanUnit" ident term                 â†’ lanU        -- Î· : F âŸ¹ Lan_K F âˆ˜ K
         | "ranCounit" ident term               â†’ ranCo ;     -- Îµ : Ran_K F âˆ˜ K âŸ¹ F

-----------------------------------------------------
-- Layer 8: Operads and Higher Structure
-- Multi-arity composition
-----------------------------------------------------

piece Operad
  -- Operad declaration
  decl ::= "operad" ident "{" operadSpec+ "}" â†’ DOperad ;
  operadSpec ::= "colors" ":" ident+ ";" â†’ operadColors
               | "O" "(" ident+ ";" ident ")" "=" term ";" â†’ operadOps
               | "âˆ˜" ":" template ";" â†’ operadCompose
               | "id" ":" template ";" â†’ operadId ;

  -- Algebra over operad
  decl ::= "algebra" ident "over" ident "{" algOp* "}" â†’ DOperadAlg ;
  algOp ::= ident "=>" template ";" â†’ algOp ;

  -- Operadic terms
  term ::= "op" ident "(" term* ")"             â†’ opCall      -- Call operation
         | "âˆ˜" ident term term*                 â†’ opCompose ; -- Compose operations

-----------------------------------------------------
-- Derived: Recursion Schemes from Functors
-- All traversals are cata/ana/hylo/para
-----------------------------------------------------

piece RecursionSchemes
  -- Derive traversal from functor
  decl ::= "derive" deriveKind "for" ident deriveWith? ";" â†’ DDerive ;
  deriveKind ::= "subst" â†’ DSubst
               | "shift" â†’ DShift
               | "map" â†’ DMap
               | "fold" â†’ DFold
               | "cata" â†’ DCata
               | "ana" â†’ DAna
               | "hylo" â†’ DHylo
               | "para" â†’ DPara
               | "normalize" â†’ DNormalize
               | "conv" â†’ DConv
               | "infer" â†’ DInfer
               | "check" â†’ DCheck ;
  deriveWith ::= "with" deriveMod ("," deriveMod)* ;
  deriveMod  ::= "binders" "=" "[" ident ("," ident)* "]" â†’ binderList
               | "fuel" "=" number â†’ fuelMod
               | "algebra" "=" ident â†’ algebraMod ;

-----------------------------------------------------
-- Meta: Code Generation Annotations
-- Control how constructs map to targets
-----------------------------------------------------

piece Annotations
  -- Target-specific hints
  decl ::= "[@" ident ":" term "]" â†’ DAnnotation
         | "[@" "inline" "]" â†’ DInline
         | "[@" "opaque" "]" â†’ DOpaque
         | "[@" "derive" ident+ "]" â†’ DDeriveHint ;

  -- Source locations
  term ::= "{-# LOC" number number "#-}" term   â†’ withLoc ;

-----------------------------------------------------
-- Rewrite Rules (Term Rewriting System)
-----------------------------------------------------

piece Rules
  decl ::= "rule" ident ":"? pattern "~~>" template ruleGuard? ";" â†’ DRule ;
  ruleGuard ::= "when" sideCondition ("," sideCondition)* ;
  sideCondition ::= pattern "=" pattern â†’ eq
                  | pattern ":" pattern â†’ hasType
                  | pattern "not" "free" "in" pattern â†’ notFree
                  | "bound" pattern ":" pattern â†’ bound ;

-----------------------------------------------------
-- Tests (Behavioral Verification)
-----------------------------------------------------

piece Tests
  decl ::= "test" string ":" term ("~~>" term)? ";" â†’ DTest
         | "property" string ":" "âˆ€" ident "." term ";" â†’ DProperty
         | "example" string ":" term "=" term ";" â†’ DExample ;

-----------------------------------------------------
-- Judgments (Type Rules)
-----------------------------------------------------

piece Judgments
  decl ::= "judgment" ident "{" judgmentRule* "}" â†’ DJudgment ;
  judgmentRule ::= ident ":" premises "âŠ¢" conclusion ";" â†’ JRule ;
  premises ::= (premise ",")* ;
  premise ::= pattern ":" term â†’ typePremise
            | "[" pattern ":" term "]" â†’ ctxPremise
            | pattern "=" pattern â†’ eqPremise ;
  conclusion ::= pattern ":" term â†’ typeConc ;

-----------------------------------------------------
-- Complete Example: Type Theory in ~50 lines
-----------------------------------------------------

-- Functor for type theory terms
functor TermF (A : Type) =
  | var : Nat â†’ A
  | lam : A â†’ A
  | app : A â†’ A â†’ A
  | pi  : A â†’ A â†’ A
  | univ : Nat â†’ A ;

-- Initial algebra
type Term = Î¼ TermF ;

-- Substitution via catamorphism + Kan extension
derive subst for Term with binders = [lam, pi] ;

-- Normalization via catamorphism
derive normalize for Term with fuel = 1000 ;

-- Typing is a natural transformation!
infer : Term âŸ¹ Maybe Type = Î» t .
  case (Out t)
    var => lookup
    lam => checkLam
    app => checkApp
    pi  => checkPi
    univ => pure (univ (n + 1)) ;

-- Free monad for effects
monad Elab = Free ElabEffect ;
effect ElabEffect {
  op fresh : Unit â†’ Nat ;
  op unify : Term â†’ Term â†’ Unit ;
  op error : String â†’ âŠ¥ ;
}

