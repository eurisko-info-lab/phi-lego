-----------------------------------------------------
-- Lean.lego: Minimal Lego Spec for Lean Grammar/AST
--
-- This is a minimal definition of Lean syntax in Lego format, covering only the
-- constructs generated by rosetta2lean.lego. It focuses on the AST nodes used in
-- the output, such as 'inductive', 'def', 'theorem', 'namespace', 'import',
-- 'fun', 'match', variables, applications, types, and basic literals.
-- This allows parsing/printing/validating the generated Lean code at AST level.
-- No full Lean semantics (e.g., no rules or types here, as it's for grammar only).
-- Pieces are modular to match Rosetta's structure.
-- Assumes basic identifiers, strings, etc., are handled.
-----------------------------------------------------
lang Lean :=

-----------------------------------------------------
-- Core
-- Basic terms: vars, apps, literals, parens.
-----------------------------------------------------
piece Core
  term ::= <ident> → var  -- x, Term, Type
         | term term → app  -- f a (implicit parens for multi-arg)
         | "(" term ")" → paren
         | <number> → numLit  -- 0, 1 (for examples if needed)
         | <string> → strLit  -- "string"
         ;

-----------------------------------------------------
-- Binders
-- Fun binders: fun x => body
-----------------------------------------------------
piece Binders
  term ::= "fun" bind* "=>" term → funExpr ;
  bind ::= <ident> → simpleBind
         | "(" <ident> ":" term ")" → typedBind ;

-----------------------------------------------------
-- Match
-- Match expressions: match t with | pat => repl | _ => default
-----------------------------------------------------
piece Match
  term ::= "match" term "with" alt* → matchExpr ;
  alt ::= "|" term "=>" term → alt ;

-----------------------------------------------------
-- Declarations
-- Top-level decls: inductive, def, theorem, namespace, import.
-----------------------------------------------------
piece Declarations
  decl ::= "inductive" <ident> "|" constr* → inductiveDecl
         | "def" <ident> param* ":" term ":=" term → defDecl
         | "theorem" <ident> ":" term ":=" term → theoremDecl
         | "namespace" <ident> decl* "end" <ident> → namespaceDecl
         | "import" <ident> → importDecl ;
  constr ::= <ident> ":" term → constr ;
  param ::= "(" <ident> ":" term ")" → param ;

-----------------------------------------------------
-- Types
-- Basic type constructs: ∀ vars, prop (used in theorems).
-----------------------------------------------------
piece Types
  term ::= "∀" bind* "," term → forall  -- ∀ x : A, B
         | term "→" term → arrow  -- A → B (sugar for forall)
         | "Type" → typeUniv  -- Universe
         | "Prop" → propUniv  -- For judgments
         ;

-----------------------------------------------------
-- Subst
-- Substitution in terms: body [x := t] (for transform)
-----------------------------------------------------
piece Subst
  term ::= term "[" <ident> ":=" term "]" → substExpr ;

-----------------------------------------------------
-- Proofs
-- Basic proofs: by rfl, by sorry (placeholders)
-----------------------------------------------------
piece Proofs
  term ::= "by" <ident> → tactic ;  -- by rfl

-----------------------------------------------------
-- Tests
-- Example validations (minimal, for coverage).
-----------------------------------------------------
test "inductiveEx": (inductive Term | Univ : Term) ;
test "defEx": (def reduce (t : Term) : Term := match t with | Fst (Pair a b) => a | _ => t) ;
test "theoremEx": (theorem univForm : Univ : Univ := by rfl) ;
test "namespaceEx": (namespace Core inductive Term | Univ : Term end Core) ;
test "importEx": (import Prelude) ;
test "funEx": (fun x => x) ;
test "forallEx": (∀ (x : Type), x → x) ;
