-----------------------------------------------------
-- Lean.lego: Complete Lean Grammar/AST for Rosetta
--
-- Comprehensive Lean 4 syntax specification in Lego format.
-- Supports the full range of constructs needed for the
-- Cubical type theory implementation files.
--
-- Structure:
-- - Core: basic terms, apps, literals
-- - Binders: lambda, function binders
-- - Types: Pi, Sigma, forall, arrow
-- - Match: pattern matching
-- - Declarations: inductive, def, structure, namespace
-- - Attributes: deriving, partial, where
-- - Tactics: by, rfl, sorry
-- - Monads: do notation, bind
-- - Records: structure, field access
-- - Instances: instance, class
-----------------------------------------------------
lang Lean :=

-----------------------------------------------------
-- Core
-- Basic terms: vars, apps, literals, parens.
-----------------------------------------------------
piece Core
  term ::= <ident> → var
         | term term → app
         | "(" term ")" → paren
         | "(" term "," term ")" → tuple
         | <number> → numLit
         | <string> → strLit
         | "true" → trueLit
         | "false" → falseLit
         | "none" → noneLit
         | "some" term → someLit
         | "#[" termList "]" → arrayLit
         | "[" termList "]" → listLit
         | "()" → unitLit
         | "_" → hole
         | term "." <ident> → proj
         | term "." <number> → projNum
         | "⟨" termList "⟩" → anonCtor
         | "{" fieldAssigns "}" → structLit
         | "s!" <string> → interpStr
         ;
  termList ::= term* → termList ;
  fieldAssigns ::= fieldAssign* → fieldAssigns ;
  fieldAssign ::= <ident> ":=" term → fieldAssign ;

-----------------------------------------------------
-- Binders
-- Fun binders, typed binders, implicit binders
-----------------------------------------------------
piece Binders
  term ::= "fun" binderSeq "=>" term → funExpr
         | "λ" binderSeq "=>" term → lamExpr
         | term "<|" term → pipeLeft
         | term "|>" term → pipeRight
         | term "$" term → dollar
         ;
  binderSeq ::= binder+ → binderSeq ;
  binder ::= <ident> → simpleBind
           | "(" <ident> ":" term ")" → typedBind
           | "{" <ident> ":" term "}" → implicitBind
           | "[" <ident> ":" term "]" → instBind
           | "(" <ident> ")" → parenBind
           ;

-----------------------------------------------------
-- Match
-- Match expressions, alternatives, patterns
-----------------------------------------------------
piece Match
  term ::= "match" termList "with" alt* → matchExpr
         | "if" term "then" term "else" term → ifExpr
         | "if" "let" pattern ":=" term "then" term "else" term → ifLetExpr
         ;
  alt ::= "|" patternList "=>" term → alt ;
  patternList ::= pattern → patternList ;
  pattern ::= <ident> → patVar
            | "_" → patWild
            | "." <ident> → patCtor
            | "(" patternList ")" → patTuple
            | pattern "::" pattern → patCons
            | <number> → patNum
            | <string> → patStr
            | "⟨" patternList "⟩" → patAnon
            | pattern "+" <number> → patSucc
            ;

-----------------------------------------------------
-- Declarations
-- Top-level decls: inductive, def, theorem, namespace
-----------------------------------------------------
piece Declarations
  decl ::= "inductive" <ident> params? whereConstrs? derivingClause? → inductiveDecl
         | "structure" <ident> params? extendsClause? "where" fieldDecls? derivingClause? → structureDecl
         | "class" <ident> params? extendsClause? "where" fieldDecls? → classDecl
         | "instance" instName? ":" term "where" fieldDefs? → instanceDecl
         | "def" <ident> params? typeAnn? whereClause? ":=" term → defDecl
         | "partial" "def" <ident> params? typeAnn? ":=" term → partialDefDecl
         | "theorem" <ident> params? ":" term ":=" term → theoremDecl
         | "lemma" <ident> params? ":" term ":=" term → lemmaDecl
         | "example" ":" term ":=" term → exampleDecl
         | "abbrev" <ident> params? typeAnn? ":=" term → abbrevDecl
         | "namespace" <ident> decl* "end" <ident> → namespaceDecl
         | "section" <ident>? decl* "end" <ident>? → sectionDecl
         | "import" modulePath → importDecl
         | "open" modulePath inClause? → openDecl
         | "variable" varDecls → variableDecl
         | "attribute" attrSpec → attributeDecl
         ;
  params ::= param+ → params ;
  param ::= "(" <ident> ":" term ")" → param
          | "{" <ident> ":" term "}" → implicitParam
          | "[" <ident> ":" term "]" → instParam
          | <ident> → simpleParam
          ;
  typeAnn ::= ":" term → typeAnn ;
  whereClause ::= "where" letDecl* → whereClause ;
  letDecl ::= <ident> ":=" term → letDecl ;
  whereConstrs ::= "where" constr* → whereConstrs ;
  constr ::= "|" <ident> constrParams? ":" term → constr ;
  constrParams ::= param+ → constrParams ;
  derivingClause ::= "deriving" <ident> → derivingClause ;
  fieldDecls ::= fieldDecl* → fieldDecls ;
  fieldDecl ::= <ident> ":" term defaultVal? → fieldDecl ;
  fieldDefs ::= fieldDef* → fieldDefs ;
  fieldDef ::= <ident> ":=" term → fieldDef ;
  defaultVal ::= ":=" term → defaultVal ;
  extendsClause ::= "extends" term → extendsClause ;
  instName ::= <ident> → instName ;
  modulePath ::= <ident> → modulePath ;
  inClause ::= "in" term → inClause ;
  varDecls ::= varDecl+ → varDecls ;
  varDecl ::= "(" <ident> ":" term ")" → varDecl
            | "{" <ident> ":" term "}" → implicitVarDecl
            ;
  attrSpec ::= "[" <ident> "]" <ident> → attrSpec ;

-----------------------------------------------------
-- Types
-- Type constructs: forall, arrow, Pi, Sigma
-----------------------------------------------------
piece Types
  term ::= "∀" binderSeq "," term → forall
         | "Π" binderSeq "," term → piType
         | "Σ" binderSeq "," term → sigmaType
         | term "→" term → arrow
         | term "×" term → prod
         | "Type" levelSpec? → typeUniv
         | "Prop" → propUniv
         | "Sort" levelSpec? → sortUniv
         | "Option" term → optionType
         | "List" term → listType
         | "Array" term → arrayType
         ;
  levelSpec ::= <number> → levelSpec ;

-----------------------------------------------------
-- Operators
-- Binary and unary operators
-----------------------------------------------------
piece Operators
  term ::= term "+" term → add
         | term "-" term → sub
         | term "*" term → mul
         | term "/" term → div
         | term "%" term → mod
         | term "==" term → eqOp
         | term "!=" term → neOp
         | term "<" term → ltOp
         | term ">" term → gtOp
         | term "<=" term → leOp
         | term ">=" term → geOp
         | term "&&" term → andOp
         | term "||" term → orOp
         | "!" term → notOp
         | "-" term → negOp
         | term "++" term → appendOp
         | term "::" term → consOp
         ;

-----------------------------------------------------
-- Let and Where
-- Local bindings
-----------------------------------------------------
piece LetWhere
  term ::= "let" <ident> typeAnn? ":=" term "in"? term → letExpr
         | "let" "rec" <ident> typeAnn? ":=" term "in"? term → letRecExpr
         | term "where" letDecl+ → whereExpr
         | "have" <ident>? ":" term ":=" term term → haveExpr
         ;

-----------------------------------------------------
-- Do Notation
-- Monadic do blocks
-----------------------------------------------------
piece DoNotation
  term ::= "do" doElem+ → doBlock ;
  doElem ::= "let" <ident> "←" term → doLet
           | "let" <ident> ":=" term → doLetPure
           | <ident> "←" term → doBind
           | term → doExpr
           | "if" term "then" doElem+ "else"? doElem* → doIf
           | "for" <ident> "in" term "do" doElem+ → doFor
           | "return" term → doReturn
           | "pure" term → doPure
           ;

-----------------------------------------------------
-- Proofs and Tactics
-- Basic proofs: by rfl, by sorry, intro, exact
-----------------------------------------------------
piece Proofs
  term ::= "by" tacticSeq → byTactic
         | "rfl" → rflTerm
         ;
  tacticSeq ::= tactic* → tacticSeq ;
  tactic ::= <ident> → tacticIdent
           | <ident> term* → tacticApp
           | "rfl" → rfl
           | "sorry" → sorry
           | "trivial" → trivial
           | "decide" → decide
           | "assumption" → assumption
           | "intro" <ident>* → intro
           | "exact" term → exact
           | "apply" term → apply
           | "simp" simpArgs? → simp
           | "cases" term → cases
           | "induction" term "with" inductionAlts → induction
           | "constructor" → constructor
           | "rw" "[" rwRules "]" → rewrite
           | "first" "[" tacticSeq "]" → first
           | "repeat" tactic → repeat
           ;
  simpArgs ::= "[" simpRule* "]" → simpArgs ;
  simpRule ::= term → simpRule ;
  inductionAlts ::= inductionAlt* → inductionAlts ;
  inductionAlt ::= "|" <ident> <ident>* "=>" tacticSeq → inductionAlt ;
  rwRules ::= rwRule* → rwRules ;
  rwRule ::= "←"? term → rwRule ;

-----------------------------------------------------
-- Records and Structures
-- Structure literals, field access, with
-----------------------------------------------------
piece Records
  term ::= term "with" fieldUpdates → withExpr
         ;
  fieldUpdates ::= "{" fieldUpdate+ "}" → fieldUpdates ;
  fieldUpdate ::= <ident> ":=" term → fieldUpdate ;

-----------------------------------------------------
-- Coercions and Casts
-- Type annotations, coercions
-----------------------------------------------------
piece Coercions
  term ::= "(" term ":" term ")" → annExpr
         | "↑" term → coeUp
         ;

-----------------------------------------------------
-- Subst (kept for compatibility)
-----------------------------------------------------
piece Subst
  term ::= term "[" <ident> ":=" term "]" → substExpr ;

-----------------------------------------------------
-- Tests
-- Example validations
-----------------------------------------------------
test "defEx": (def reduce (t : Term) : Term := match t with | Fst (Pair a b) => a | _ => t) ;
test "inductiveEx": (inductive Term where | Univ : Term | Lam : Term → Term) ;
test "structEx": (structure Point where x : Nat y : Nat) ;
test "namespaceEx": (namespace Core inductive Term where | Univ : Term end Core) ;
test "importEx": (import Prelude) ;
test "funEx": (fun x => x) ;
test "forallEx": (∀ (x : Type), x → x) ;
test "matchEx": (match x with | 0 => 1 | n + 1 => n) ;
test "doEx": (do let x ← getLine ; pure x) ;
test "tacticEx": (by intro x ; exact x) ;
