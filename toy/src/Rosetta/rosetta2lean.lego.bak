-----------------------------------------------------
-- rosetta2lean.lego: Translator from Rosetta to Lean
--
-- This file defines the translator in Lego syntax, leveraging meta-circularity.
-- We import the Rosetta language definition and a hypothetical 'Lean' language spec
-- (assumed to define Lean constructs like 'inductive', 'def', 'theorem', etc.).
-- The translator applies rewriting rules on Rosetta AST terms to produce Lean AST terms.
-- Focus: Transform 'adtDef' to 'inductive', 'rewriteRule' to 'def' with pattern matching,
-- 'judgeDecl' to 'def' or 'theorem' for typing judgments, 'testDecl' to 'example'.
-- Modules are transformed to 'namespace' for namespacing.
-- Transformation is contextual: Apply within modules, handling imports.
-- Entry: Use 'transform' on the full Rosetta lang AST to get Lean code.
-- Output is Lean syntax as strings or AST, ready for printing.
-- Assumptions: Lean spec includes constructs like (inductive name (constrs)), (def name : ty := body),
-- (match expr with | pat => repl), etc.
-----------------------------------------------------
import Rosetta
import Lean

lang RosettaToLean :=

-----------------------------------------------------
-- TransformPrimitives
-- Basic transformation: Rosetta terms to Lean exprs.
-- e.g., Univ → Type, Var x → x (as Lean var), Const 0 → 0.
-----------------------------------------------------
piece TransformPrimitives
  -- Transform term: Recurse.
  rule transformTermApp: (transform ($func $args)) ~~> ($func $transArgs)
    when $transArgs = (transform $args) ;  -- App f a → f a (Lean app)
  rule transformTermConst: (transform (Const $lit)) ~~> $lit ;  -- Const 0 → 0
  rule transformTermVar: (transform (Var $id)) ~~> $id ;
  rule transformTermLam: (transform (Lam $x . $body)) ~~> (fun $x => (transform $body)) ;
  rule transformTermDLam: (transform (DLam $i . $body)) ~~> (fun $i => (transform $body)) ;  -- Abstract dimension as fun
  rule transformTermSubst: (transform (Subst $x $t $body)) ~~> ((transform $body) [$x := (transform $t)]) ;  -- Lean subst notation
  -- Pattern transform similar, but for match arms: $pat ~> $repl → | pat => repl
  rule transformPat: (transformPat $pat) ~~> (transform $pat) ;

-----------------------------------------------------
-- AdtTransform
-- Transform 'adtDef name { constrs }' to 'inductive name | constrs'.
-- constr : ty → | name : ty (in Lean syntax).
-- Namespace: If in module Mod, inductive Mod.name.
-----------------------------------------------------
piece AdtTransform
  rule transformAdt: (transform (adtDef $name { $constrs })) ~~> (inductive $nsName | $transConstrs)
    when inModule $modName, $nsName = ($modName ++ "." ++ $name),
         $transConstrs = (forEach $c in $constrs: (transformConstr $c)) ;
  rule transformConstr: (transformConstr $cname : $ty) ~~> ($cname : (transformType $ty)) ;
  rule transformType: (transformType $t) ~~> (transform $t) ;  -- Recurse, e.g., Term → Term → Term → Term → Term → Term

-----------------------------------------------------
-- RewriteTransform
-- Transform 'rewriteRule name: pat ~> repl' to 'def name : ... := match ...'.
-- Create a reducer def: def reduce (t : Term) : Term := match t with | transPat => transRepl | _ => t
-- But for multiple rules, group into one reduce function per module.
-- For simplicity, each rule as a partial def, assume post-processing to combine.
-----------------------------------------------------
piece RewriteTransform
  rule transformRewrite: (transform (rewriteRule $name: $pat ~~> $repl)) ~~> (def $nsName (t : Term) : Term := match t with | (transformPat $pat) => (transform $repl) | _ => t)
    when inModule $modName, $nsName = ($modName ++ "." ++ $name ++ "Reduce") ;

-----------------------------------------------------
-- JudgeTransform
-- Transform 'judgeDecl name: term : ty when conds' to 'def nameCheck : ...'.
-- Use Lean's Prop for judgments: theorem name : ∀ (term : Term), (conds) → term : ty
-- Or def for checker function.
-- Here, use theorem for declarative style.
-----------------------------------------------------
piece JudgeTransform
  rule transformJudge: (transform (judgeDecl $name: $term : $ty when $conds)) ~~> (theorem $nsName : ∀ $vars, $premises → (transform $term) : (transform $ty)
    when inModule $modName, $nsName = ($modName ++ "." ++ $name),
         ($vars, $premises) = (extractVarsAndPremises $conds) ;
  -- Extract: cond a : b → a : b, ctxCond [binds] body : ty → ∀ binds, body : ty
  rule extractSimple: (extractVarsAndPremises (cond $lhs : $rhs)) ~~> ([], (transform $lhs) : (transform $rhs)) ;
  rule extractCtx: (extractVarsAndPremises (ctxCond $binds $body : $ty)) ~~> ($transBinds, (transform $body) : (transform $ty))
    when $transBinds = (forEach $b in $binds: ($b.x : (transform $b.ty))) ;

-----------------------------------------------------
-- TestTransform
-- Transform 'testDecl name: lhs ~~> rhs' to 'example : lhs = rhs := by sorry' or check.
-- Use theorem for equality after reduction.
-----------------------------------------------------
piece TestTransform
  rule transformTest: (transform (testDecl $name: $lhs ~~> $rhs)) ~~> (theorem $nsName : (reduce (transform $lhs)) = (transform $rhs) := by rfl)  -- Assume reduce normalizes
    when inModule $modName, $nsName = ($modName ++ "." ++ $name ++ "Test") ;

-----------------------------------------------------
-- ModuleTransform
-- Transform 'moduleDecl name { decls }' to 'namespace name ... end name'.
-- Apply transforms within namespace.
-----------------------------------------------------
piece ModuleTransform
  rule transformModule: (transform (moduleDecl $name { $decls })) ~~> (namespace $name $transDecls end $name)
    when pushContext (inModule $name), $transDecls = (forEach $decl in $decls: (transform $decl)), popContext ;
  rule transformImport: (transform (importDecl $mod)) ~~> (import $mod) ;

-----------------------------------------------------
-- LangTransform
-- Top-level: 'lang Name := contents' → Full Lean file with imports and namespaces.
-----------------------------------------------------
piece LangTransform
  rule transformLang: (transform (lang $name := $contents)) ~~> (import PreludeLean ; $transContents)
    when $transContents = (forEach $content in $contents: (transform $content)) ;  -- Add prelude import

-----------------------------------------------------
-- ContextHelpers
-- Meta-rules for context (inModule), string ops.
-----------------------------------------------------
piece ContextHelpers
  rule concat: ($a ++ $b) ~~> $combined ;
  rule forEach: (forEach $item in $list: $expr) ~~> $resultList ;
  rule extractVarsAndPremises: (extractVarsAndPremises $conds) ~~> ($vars $prems) ;

-----------------------------------------------------
-- Examples
-- Built-in tests for generic Rosetta transforms.
-----------------------------------------------------
test "transformAdtEx": transform (adtDef "Term" { Univ : Term }) ~~> (inductive Core.Term | Univ : Core.Term) when inModule "Core" ;
test "transformRewriteEx": transform (rewriteRule "fstPair": (Fst (Pair $a $b)) ~~> $a) ~~> (def Core.fstPairReduce (t : Term) : Term := match t with | Fst (Pair a b) => a | _ => t) ;
test "transformJudgeEx": transform (judgeDecl "univForm": Univ : Univ) ~~> (theorem Core.univForm : Univ : Univ) ;
