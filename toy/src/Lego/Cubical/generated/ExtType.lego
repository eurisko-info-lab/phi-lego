-----------------------------------------------------
-- ExtType.lego: Extension Types for Cubical Type Theory
--
-- Mathematical Structure:
-- - Extension types are like dependent products over the interval
-- - But with a partial element specified on the boundary (cofibration)
-- - Used for partial elements, higher-order paths, and fill operations
--
-- Extension types allow specifying types with boundary constraints:
--   ext n fam cof bdry : Type
-----------------------------------------------------

import Core ;

lang ExtType (Core) :=

-----------------------------------------------------
-- ExtInfo
-- Information about an extension type
-----------------------------------------------------
piece ExtInfo
  extInfo ::= "extInfo" "arity:" <number> "family:" <expr> "cof:" <expr> "boundary:" <expr> → extInfo ;
  
  rule extInfoArity: (extInfoArity (extInfo arity: $n family: $f cof: $c boundary: $b)) ~> $n ;
  rule extInfoFamily: (extInfoFamily (extInfo arity: $n family: $f cof: $c boundary: $b)) ~> $f ;
  rule extInfoCof: (extInfoCof (extInfo arity: $n family: $f cof: $c boundary: $b)) ~> $c ;
  rule extInfoBoundary: (extInfoBoundary (extInfo arity: $n family: $f cof: $c boundary: $b)) ~> $b ;
  
  rule extInfoFromExpr: (extInfoFromExpr (ext $n $fam $cof $bdry)) ~>
    (some (extInfo arity: $n family: $fam cof: $cof boundary: $bdry)) ;
  rule extInfoFromExprOther: (extInfoFromExpr $e) ~> none ;
  
  rule extInfoToExpr: (extInfoToExpr (extInfo arity: $n family: $f cof: $c boundary: $b)) ~>
    (ext $n $f $c $b) ;
  
  rule extInfoIsNullary: (extInfoIsNullary (extInfo arity: 0 family: $f cof: $c boundary: $b)) ~> true ;
  rule extInfoIsNullaryN: (extInfoIsNullary (extInfo arity: $n family: $f cof: $c boundary: $b)) ~> false ;
  
  rule extInfoHasTrivialBoundary: (extInfoHasTrivialBoundary (extInfo arity: $n family: $f cof: cof_bot boundary: $b)) ~> true ;
  rule extInfoHasTrivialBoundaryOther: (extInfoHasTrivialBoundary (extInfo arity: $n family: $f cof: $c boundary: $b)) ~> false ;

-----------------------------------------------------
-- ApplyDims
-- Apply dimensions to extension type components
-----------------------------------------------------
piece ApplyDims
  rule applyFamily: (applyFamily (extInfo arity: $n family: $f cof: $c boundary: $b) $dims) ~>
    (case (eq (length $dims) $n)
      true => (foldr (fun dim acc => (subst 0 dim acc)) $f $dims)
      false => $f) ;
  
  rule applyCof: (applyCof (extInfo arity: $n family: $f cof: $c boundary: $b) $dims) ~>
    (case (eq (length $dims) $n)
      true => (foldr (fun dim acc => (subst 0 dim acc)) $c $dims)
      false => $c) ;
  
  rule applyBoundary: (applyBoundary (extInfo arity: $n family: $f cof: $c boundary: $b) $dims) ~>
    (case (eq (length $dims) $n)
      true => (foldr (fun dim acc => (subst 0 dim acc)) $b $dims)
      false => $b) ;

-----------------------------------------------------
-- MkExt
-- Smart constructor for extension types
-----------------------------------------------------
piece MkExt
  rule mkExt: (mkExt $arity $fam $cof $bdry) ~>
    (case $cof
      cof_bot => (ext $arity $fam cof_bot $bdry)
      cof_top => (ext $arity $fam cof_top $bdry)
      _ => (ext $arity $fam $cof $bdry)) ;

-----------------------------------------------------
-- MkExtLam
-- Create extension lambda
-----------------------------------------------------
piece MkExtLam
  rule mkExtLam: (mkExtLam $arity $body) ~> (extLam $arity $body) ;

-----------------------------------------------------
-- MkExtApp
-- Create extension application with β-reduction
-----------------------------------------------------
piece MkExtApp
  rule mkExtApp: (mkExtApp (extLam $n $body) $dims) ~>
    (case (eq (length $dims) $n)
      true => (foldr (fun dim acc => (subst 0 dim acc)) $body $dims)
      false => (extApp (extLam $n $body) $dims)) ;
  rule mkExtAppOther: (mkExtApp $e $dims) ~> (extApp $e $dims) ;

-----------------------------------------------------
-- ReduceExt
-- Reduction rules for extension expressions
-----------------------------------------------------
piece ReduceExt
  rule reduceExtExpr: (reduceExtExpr (extApp (extLam $n $body) $dims)) ~>
    (case (eq (length $dims) $n)
      true => (some (foldr (fun dim acc => (subst 0 dim acc)) $body $dims))
      false => none) ;
  rule reduceExtExprOther: (reduceExtExpr $e) ~> none ;
  
  rule normalizeExt: (normalizeExt $fuel $e) ~> (normalizeExt' $fuel $e) ;
  rule normalizeExt'0: (normalizeExt' 0 $e) ~> $e ;
  rule normalizeExt': (normalizeExt' (suc $fuel) $e) ~>
    (case (reduceExtExpr $e)
      (some $e') => (normalizeExt' $fuel $e')
      none => $e) ;

-----------------------------------------------------
-- PathAsExt
-- Path types as extension types
-- Path A a b ≅ ext 1 (λ_. A) (∂i) (λi. [i=0 ↦ a, i=1 ↦ b])
-----------------------------------------------------
piece PathAsExt
  rule pathToExt: (pathToExt (path $A $a $b)) ~>
    (ext 1 (lam $A)
      (cof_or (cof_eq (ix 0) dim0) (cof_eq (ix 0) dim1))
      (lam (case (ix 0)
        dim0 => (shift 0 1 $a)
        dim1 => (shift 0 1 $b)))) ;
  
  rule extToPath: (extToPath (ext 1 (lam $A) $cof $bdry)) ~>
    (some (path $A (evalAtDim0 $bdry) (evalAtDim1 $bdry))) ;
  rule extToPathOther: (extToPath $e) ~> none ;
  
  rule evalAtDim0: (evalAtDim0 (lam $body)) ~> (subst 0 dim0 $body) ;
  rule evalAtDim1: (evalAtDim1 (lam $body)) ~> (subst 0 dim1 $body) ;

-----------------------------------------------------
-- HComExt
-- Homogeneous composition for extension types
-----------------------------------------------------
piece HComExt
  -- hcom for ext n fam cof bdry composes in each dimension
  rule hcomExt: (hcomExt $r $r' (ext $n $fam $cof $bdry) $φ $tubes $cap) ~>
    (extLam $n (hcom (mkExtApp $fam (dimVarsN $n))
      $r $r'
      (cof_or $φ (mkExtApp $cof (dimVarsN $n)))
      (lam (lam (case (meetsCof (ix 1) $φ)
        true => (mkExtApp (app (app (shift 0 2 $tubes) (ix 1)) (ix 0)) (dimVarsN $n))
        false => (mkExtApp (shift 0 2 $bdry) (dimVarsN $n)))))
      (mkExtApp $cap (dimVarsN $n)))) ;
  
  -- Generate n dimension variables
  rule dimVarsN: (dimVarsN $n) ~> (dimVarsN' $n ()) ;
  rule dimVarsN'0: (dimVarsN' 0 $acc) ~> $acc ;
  rule dimVarsN': (dimVarsN' (suc $n) $acc) ~> (dimVarsN' $n ((ix $n) $acc)) ;

-----------------------------------------------------
-- CoeExt
-- Coercion for extension types
-----------------------------------------------------
piece CoeExt
  -- coe for ext n fam cof bdry coerces in each dimension
  rule coeExt: (coeExt $r $r' (lam (ext $n $fam $cof $bdry)) $e) ~>
    (extLam $n (com (lam (mkExtApp $fam (dimVarsN $n)))
      $r $r'
      (mkExtApp $cof (dimVarsN $n))
      (lam (lam (mkExtApp (shift 0 2 $bdry) (dimVarsN $n))))
      (mkExtApp $e (dimVarsN $n)))) ;

-----------------------------------------------------
-- ExtCurry
-- Curry/uncurry for extension types
-----------------------------------------------------
piece ExtCurry
  -- Curry: ((i, j) → A) → (i → j → A)
  rule extCurry: (extCurry $n $m $e) ~>
    (extLam $n (extLam $m (mkExtApp $e (append (dimVarsN $n) (dimVarsN $m))))) ;
  
  -- Uncurry: (i → j → A) → ((i, j) → A)
  rule extUncurry: (extUncurry $n $m $e) ~>
    (extLam (plus $n $m) (mkExtApp (mkExtApp $e (takeN $n (dimVarsN (plus $n $m)))) 
                                    (dropN $n (dimVarsN (plus $n $m))))) ;

-----------------------------------------------------
-- ExtRestrict
-- Restrict extension type to a face
-----------------------------------------------------
piece ExtRestrict
  rule extRestrict: (extRestrict (ext $n $fam $cof $bdry) $dim $val) ~>
    (ext (minus $n 1)
      (lam (subst $dim $val $fam))
      (subst $dim $val $cof)
      (lam (subst $dim $val $bdry))) ;


-----------------------------------------------------
-- Derived Operations
-----------------------------------------------------

derive subst for term ;
derive normalize for term with fuel = 100 ;

