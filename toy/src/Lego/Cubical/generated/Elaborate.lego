-----------------------------------------------------
-- Elaborate.lego: Bidirectional Elaboration from Surface to Core
--
-- Mathematical Structure:
-- - Elaboration as partial function: Surface Ã— Ctx â†’ Core Ã— Type
-- - Bidirectionality: splitting into infer (â†‘) and check (â†“)
-- - Implicit arguments via unification constraints
--
-- Elaboration bridges surface syntax with names to core IR with de Bruijn.
-----------------------------------------------------

import Core ;
import GlobalEnv ;
import Unify ;
import Quote ;
import Datatype ;

lang Elaborate (Core, GlobalEnv, Unify, Quote, Datatype) :=

-----------------------------------------------------
-- Surface
-- Surface terms with names
-----------------------------------------------------
piece Surface
  -- Basic terms
  surfVar ::= "var" <symbol> â†’ surface ;
  surfLit ::= "lit" <string> â†’ surface ;
  surfLam ::= "Î»" <symbol> "." <surface> â†’ surface ;
  surfApp ::= "app" <surface> <surface> â†’ surface ;
  surfAppImpl ::= "appImpl" <surface> <surface> â†’ surface ;
  surfPi ::= "Î " "(" <symbol> ":" <surface> ")" <surface> â†’ surface ;
  surfPiImpl ::= "{" <symbol> ":" <surface> "}" "â†’" <surface> â†’ surface ;
  surfSigma ::= "Î£" "(" <symbol> ":" <surface> ")" <surface> â†’ surface ;
  surfPair ::= "âŸ¨" <surface> "," <surface> "âŸ©" â†’ surface ;
  surfFst ::= "fst" <surface> â†’ surface ;
  surfSnd ::= "snd" <surface> â†’ surface ;
  surfLetIn ::= "let" <symbol> ":" <surface> "=" <surface> "in" <surface> â†’ surface ;
  surfUniv ::= "Type" <number> â†’ surface ;
  surfHole ::= "?" <symbol>? â†’ surface ;
  surfAnn ::= "(" <surface> ":" <surface> ")" â†’ surface ;
  
  -- Cubical
  surfDim0 ::= "0" â†’ surface ;
  surfDim1 ::= "1" â†’ surface ;
  surfPath ::= "Path" <surface> <surface> <surface> â†’ surface ;
  surfPlam ::= "Î»" <symbol> "." <surface> â†’ surface ;
  surfPapp ::= <surface> "@" <surface> â†’ surface ;
  surfRefl ::= "refl" <surface> â†’ surface ;
  
  -- Datatypes
  surfData ::= "data" <symbol> <surface>* â†’ surface ;
  surfIntro ::= "intro" <symbol> "." <symbol> <surface>* â†’ surface ;
  surfElim ::= "elim" <surface> "motive" <surface> <elimClause>* â†’ surface ;
  elimClause ::= "|" <symbol> <symbol>* "=>" <surface> â†’ elimClause ;

-----------------------------------------------------
-- MetaEntry
-- Meta-variable info
-----------------------------------------------------
piece MetaEntry
  metaEntry ::= "meta" "ty:" <expr> "solution:" <expr>? â†’ metaEntry ;
  
  rule metaEntryTy: (metaEntryTy (meta ty: $ty solution: $sol)) ~> $ty ;
  rule metaEntrySol: (metaEntrySol (meta ty: $ty solution: $sol)) ~> $sol ;

-----------------------------------------------------
-- MetaCtx
-- Meta-variable context
-----------------------------------------------------
piece MetaCtx
  metaCtx ::= "metaCtx" <metaBinding>* â†’ metaCtx ;
  metaBinding ::= "(" <number> "â†¦" <metaEntry> ")" â†’ metaBinding ;
  
  rule metaCtxEmpty: metaCtxEmpty ~> (metaCtx ()) ;
  rule metaCtxLookup: (metaCtxLookup (metaCtx $bindings) $id) ~>
    (lookupMeta $bindings $id) ;
  rule metaCtxInsert: (metaCtxInsert (metaCtx $bindings) $id $entry) ~>
    (metaCtx ($bindings ($id â†¦ $entry))) ;

-----------------------------------------------------
-- LocalBinding
-- Local binding info
-----------------------------------------------------
piece LocalBinding
  localBinding ::= "local" "name:" <symbol> "ty:" <expr> "isDim:" <bool> â†’ localBinding ;
  
  rule localBindingName: (localBindingName (local name: $n ty: $ty isDim: $d)) ~> $n ;
  rule localBindingTy: (localBindingTy (local name: $n ty: $ty isDim: $d)) ~> $ty ;
  rule localBindingIsDim: (localBindingIsDim (local name: $n ty: $ty isDim: $d)) ~> $d ;

-----------------------------------------------------
-- ElabCtx
-- Elaboration context
-----------------------------------------------------
piece ElabCtx
  elabCtx ::= "elabCtx" "locals:" <localBinding>* "global:" <globalEnv> "meta:" <metaCtx> "nextMeta:" <number> â†’ elabCtx ;
  
  rule elabCtxEmpty: elabCtxEmpty ~>
    (elabCtx locals: () global: globalEnvEmpty meta: metaCtxEmpty nextMeta: 0) ;
  
  rule elabCtxWithGlobals: (elabCtxWithGlobals $env) ~>
    (elabCtx locals: () global: $env meta: metaCtxEmpty nextMeta: 0) ;
  
  rule elabCtxExtend: (elabCtxExtend (elabCtx locals: $locals global: $g meta: $m nextMeta: $n) $name $ty) ~>
    (elabCtx locals: ((local name: $name ty: $ty isDim: false) $locals) global: $g meta: $m nextMeta: $n) ;
  
  rule elabCtxExtendDim: (elabCtxExtendDim (elabCtx locals: $locals global: $g meta: $m nextMeta: $n) $name) ~>
    (elabCtx locals: ((local name: $name ty: (lit "ð•€") isDim: true) $locals) global: $g meta: $m nextMeta: $n) ;
  
  rule elabCtxLookupLocal: (elabCtxLookupLocal (elabCtx locals: $locals global: $g meta: $m nextMeta: $n) $name) ~>
    (lookupLocal $locals $name 0) ;
  
  rule lookupLocalNil: (lookupLocal () $name $idx) ~> none ;
  rule lookupLocalConsMatch: (lookupLocal ((local name: $name ty: $ty isDim: $d) $rest) $name $idx) ~>
    (some ($idx , $ty)) ;
  rule lookupLocalConsMiss: (lookupLocal ((local name: $n ty: $ty isDim: $d) $rest) $name $idx) ~>
    (lookupLocal $rest $name (suc $idx)) ;
  
  rule elabCtxDepth: (elabCtxDepth (elabCtx locals: $locals global: $g meta: $m nextMeta: $n)) ~>
    (length $locals) ;
  
  rule elabCtxFreshMeta: (elabCtxFreshMeta (elabCtx locals: $locals global: $g meta: $m nextMeta: $n) $ty) ~>
    (result: (elabCtx locals: $locals global: $g 
              meta: (metaCtxInsert $m $n (meta ty: $ty solution: none))
              nextMeta: (suc $n))
     meta: (lit (concat "meta." $n))) ;

-----------------------------------------------------
-- ElabResult
-- Elaboration result: core term and type
-----------------------------------------------------
piece ElabResult
  elabOk ::= "ok" "term:" <expr> "type:" <expr> "ctx:" <elabCtx> â†’ elabResult ;
  elabErr ::= "error" <string> â†’ elabResult ;
  
  rule elabResultTerm: (elabResultTerm (ok term: $t type: $ty ctx: $c)) ~> $t ;
  rule elabResultType: (elabResultType (ok term: $t type: $ty ctx: $c)) ~> $ty ;
  rule elabResultCtx: (elabResultCtx (ok term: $t type: $ty ctx: $c)) ~> $c ;

-----------------------------------------------------
-- Infer
-- Infer mode: elaborate and return type
-----------------------------------------------------
piece Infer
  -- Variable
  rule inferVar: (infer $ctx (var $name)) ~>
    (case (elabCtxLookupLocal $ctx $name)
      (some ($idx , $ty)) => (ok term: (ix $idx) type: $ty ctx: $ctx)
      none => (error (concat "Unknown variable: " $name))) ;
  
  -- Literal
  rule inferLit: (infer $ctx (lit $s)) ~> (ok term: (lit $s) type: (univ lzero) ctx: $ctx) ;
  
  -- Universe
  rule inferUniv: (infer $ctx (Type $n)) ~>
    (ok term: (univ (levelOfNat $n)) type: (univ (levelOfNat (suc $n))) ctx: $ctx) ;
  
  -- Pi type
  rule inferPi: (infer $ctx (Î  ($x : $dom) $cod)) ~>
    (case (infer $ctx $dom)
      (ok term: $domCore type: $domTy ctx: $ctx') =>
        (case (infer (elabCtxExtend $ctx' $x $domCore) $cod)
          (ok term: $codCore type: $codTy ctx: $ctx'') =>
            (ok term: (pi $domCore $codCore) 
                type: (univ (lmax (levelOf $domTy) (levelOf $codTy))) 
                ctx: $ctx'')
          $err => $err)
      $err => $err) ;
  
  -- Sigma type
  rule inferSigma: (infer $ctx (Î£ ($x : $dom) $cod)) ~>
    (case (infer $ctx $dom)
      (ok term: $domCore type: $domTy ctx: $ctx') =>
        (case (infer (elabCtxExtend $ctx' $x $domCore) $cod)
          (ok term: $codCore type: $codTy ctx: $ctx'') =>
            (ok term: (sigma $domCore $codCore) 
                type: (univ (lmax (levelOf $domTy) (levelOf $codTy))) 
                ctx: $ctx'')
          $err => $err)
      $err => $err) ;
  
  -- Application
  rule inferApp: (infer $ctx (app $f $x)) ~>
    (case (infer $ctx $f)
      (ok term: $fCore type: (pi $dom $cod) ctx: $ctx') =>
        (case (check $ctx' $x $dom)
          (ok term: $xCore type: _ ctx: $ctx'') =>
            (ok term: (app $fCore $xCore) type: (subst 0 $xCore $cod) ctx: $ctx'')
          $err => $err)
      (ok term: _ type: $ty ctx: _) => (error (concat "Expected function type, got " $ty))
      $err => $err) ;
  
  -- Pair (non-dependent)
  rule inferPair: (infer $ctx (âŸ¨ $a , $b âŸ©)) ~>
    (case (infer $ctx $a)
      (ok term: $aCore type: $aTy ctx: $ctx') =>
        (case (infer $ctx' $b)
          (ok term: $bCore type: $bTy ctx: $ctx'') =>
            (ok term: (pair $aCore $bCore) 
                type: (sigma $aTy (shift 0 1 $bTy)) 
                ctx: $ctx'')
          $err => $err)
      $err => $err) ;
  
  -- Fst projection
  rule inferFst: (infer $ctx (fst $p)) ~>
    (case (infer $ctx $p)
      (ok term: $pCore type: (sigma $dom $cod) ctx: $ctx') =>
        (ok term: (fst $pCore) type: $dom ctx: $ctx')
      (ok term: _ type: $ty ctx: _) => (error "Expected sigma type for fst")
      $err => $err) ;
  
  -- Snd projection
  rule inferSnd: (infer $ctx (snd $p)) ~>
    (case (infer $ctx $p)
      (ok term: $pCore type: (sigma $dom $cod) ctx: $ctx') =>
        (ok term: (snd $pCore) type: (subst 0 (fst $pCore) $cod) ctx: $ctx')
      (ok term: _ type: $ty ctx: _) => (error "Expected sigma type for snd")
      $err => $err) ;
  
  -- Annotation
  rule inferAnn: (infer $ctx (( $tm : $ty ))) ~>
    (case (infer $ctx $ty)
      (ok term: $tyCore type: _ ctx: $ctx') =>
        (case (check $ctx' $tm $tyCore)
          (ok term: $tmCore type: _ ctx: $ctx'') =>
            (ok term: $tmCore type: $tyCore ctx: $ctx'')
          $err => $err)
      $err => $err) ;
  
  -- Hole
  rule inferHole: (infer $ctx (? $name)) ~>
    (case (elabCtxFreshMeta $ctx (univ lzero))
      (result: $ctx' meta: $typeMeta) =>
        (case (elabCtxFreshMeta $ctx' $typeMeta)
          (result: $ctx'' meta: $termMeta) =>
            (ok term: $termMeta type: $typeMeta ctx: $ctx''))) ;
  
  -- Dimensions
  rule inferDim0: (infer $ctx 0) ~> (ok term: dim0 type: (lit "ð•€") ctx: $ctx) ;
  rule inferDim1: (infer $ctx 1) ~> (ok term: dim1 type: (lit "ð•€") ctx: $ctx) ;
  
  -- Path type
  rule inferPath: (infer $ctx (Path $A $a $b)) ~>
    (case (infer $ctx $A)
      (ok term: $ACore type: $ATy ctx: $ctx') =>
        (case (infer $ctx' $a)
          (ok term: $aCore type: _ ctx: $ctx'') =>
            (case (infer $ctx'' $b)
              (ok term: $bCore type: _ ctx: $ctx''') =>
                (ok term: (path $ACore $aCore $bCore) type: (univ (levelOf $ATy)) ctx: $ctx''')
              $err => $err)
          $err => $err)
      $err => $err) ;
  
  -- Path application
  rule inferPapp: (infer $ctx ($p @ $r)) ~>
    (case (infer $ctx $p)
      (ok term: $pCore type: (path $A $l $ep) ctx: $ctx') =>
        (case (infer $ctx' $r)
          (ok term: $rCore type: _ ctx: $ctx'') =>
            (ok term: (papp $pCore $rCore) type: $A ctx: $ctx'')
          $err => $err)
      (ok term: _ type: $ty ctx: _) => (error "Expected path type for @")
      $err => $err) ;
  
  -- Refl
  rule inferRefl: (infer $ctx (refl $a)) ~>
    (case (infer $ctx $a)
      (ok term: $aCore type: $aTy ctx: $ctx') =>
        (ok term: (refl $aCore) type: (path $aTy $aCore $aCore) ctx: $ctx')
      $err => $err) ;

-----------------------------------------------------
-- Check
-- Check mode: elaborate against expected type
-----------------------------------------------------
piece Check
  -- Lambda against Pi
  rule checkLam: (check $ctx (Î» $x . $body) (pi $dom $cod)) ~>
    (case (check (elabCtxExtend $ctx $x $dom) $body $cod)
      (ok term: $bodyCore type: _ ctx: $ctx') =>
        (ok term: (lam $bodyCore) type: (pi $dom $cod) ctx: $ctx')
      $err => $err) ;
  
  -- Path lambda against Path
  rule checkPlam: (check $ctx (Î» $i . $body) (path $A $l $r)) ~>
    (case (check (elabCtxExtendDim $ctx $i) $body $A)
      (ok term: $bodyCore type: _ ctx: $ctx') =>
        (ok term: (plam $bodyCore) type: (path $A $l $r) ctx: $ctx')
      $err => $err) ;
  
  -- Pair against Sigma
  rule checkPair: (check $ctx (âŸ¨ $a , $b âŸ©) (sigma $dom $cod)) ~>
    (case (check $ctx $a $dom)
      (ok term: $aCore type: _ ctx: $ctx') =>
        (let codSubst = (subst 0 $aCore $cod) in
         case (check $ctx' $b codSubst)
           (ok term: $bCore type: _ ctx: $ctx'') =>
             (ok term: (pair $aCore $bCore) type: (sigma $dom $cod) ctx: $ctx'')
           $err => $err)
      $err => $err) ;
  
  -- Let binding
  rule checkLet: (check $ctx (let $x : $ty = $val in $body) $expected) ~>
    (case (infer $ctx $ty)
      (ok term: $tyCore type: _ ctx: $ctx') =>
        (case (check $ctx' $val $tyCore)
          (ok term: $valCore type: _ ctx: $ctx'') =>
            (case (check (elabCtxExtend $ctx'' $x $tyCore) $body $expected)
              (ok term: $bodyCore type: _ ctx: $ctx''') =>
                (ok term: (letE $tyCore $valCore $bodyCore) type: $expected ctx: $ctx''')
              $err => $err)
          $err => $err)
      $err => $err) ;
  
  -- Hole: create meta of expected type
  rule checkHole: (check $ctx (? $name) $expected) ~>
    (case (elabCtxFreshMeta $ctx $expected)
      (result: $ctx' meta: $termMeta) =>
        (ok term: $termMeta type: $expected ctx: $ctx')) ;
  
  -- Refl against Path
  rule checkRefl: (check $ctx (refl $a) (path $A $l $r)) ~>
    (case (check $ctx $a $l)
      (ok term: $aCore type: _ ctx: $ctx') =>
        (ok term: (refl $aCore) type: (path $A $l $r) ctx: $ctx')
      $err => $err) ;
  
  -- Fallback: infer and convert
  rule checkFallback: (check $ctx $s $expected) ~>
    (case (infer $ctx $s)
      (ok term: $core type: $inferred ctx: $ctx') =>
        (case (conv $inferred $expected)
          true => (ok term: $core type: $expected ctx: $ctx')
          false => (error (concat "Type mismatch: expected " $expected ", got " $inferred)))
      $err => $err) ;

-----------------------------------------------------
-- Conv
-- Conversion checking (simple structural equality)
-----------------------------------------------------
piece Conv
  rule conv: (conv $t1 $t2) ~>
    (let t1' = (normalize 100 $t1) in
     let t2' = (normalize 100 $t2) in
     (eq t1' t2')) ;

-----------------------------------------------------
-- TopLevel
-- Top-level elaboration functions
-----------------------------------------------------
piece TopLevel
  rule elaborate: (elaborate $env $s $ty) ~>
    (case (check (elabCtxWithGlobals $env) $s $ty)
      (ok term: $result type: _ ctx: _) => (ok $result)
      (error $msg) => (error $msg)) ;
  
  rule elaborateInfer: (elaborateInfer $env $s) ~>
    (case (infer (elabCtxWithGlobals $env) $s)
      (ok term: $t type: $ty ctx: _) => (ok ($t , $ty))
      (error $msg) => (error $msg)) ;

-----------------------------------------------------
-- CheckType
-- Check that a surface term is a valid type
-----------------------------------------------------
piece CheckType
  rule checkType: (checkType $ctx $s) ~>
    (case (infer $ctx $s)
      (ok term: $tyCore type: (univ $level) ctx: $ctx') =>
        (ok (type: $tyCore level: $level ctx: $ctx'))
      (ok term: _ type: $ty ctx: _) => (error (concat "Expected a type, got " $ty))
      $err => $err) ;
  
  rule checkTypeAtLevel: (checkTypeAtLevel $ctx $s $expected) ~>
    (case (checkType $ctx $s)
      (ok (type: $tyCore level: $level ctx: $ctx')) =>
        (case (levelLeq $level $expected)
          true => (ok term: $tyCore ctx: $ctx')
          false => (error (concat "Universe level mismatch: expected â‰¤ " $expected ", got " $level)))
      $err => $err) ;

-----------------------------------------------------
-- Telescope
-- Telescopic elaboration
-----------------------------------------------------
piece Telescope
  teleEntry ::= "teleEntry" "name:" <symbol> "surface:" <surface> â†’ teleEntry ;
  
  rule checkTelescope: (checkTelescope $ctx ()) ~> (ok (tele: () ctx: $ctx)) ;
  rule checkTelescopeCons: (checkTelescope $ctx ((teleEntry name: $name surface: $s) $rest)) ~>
    (case (checkType $ctx $s)
      (ok (type: $tyCore level: _ ctx: $ctx')) =>
        (case (checkTelescope (elabCtxExtend $ctx' $name $tyCore) $rest)
          (ok (tele: $restTele ctx: $ctx'')) =>
            (ok (tele: (($name , $tyCore) $restTele) ctx: $ctx''))
          $err => $err)
      $err => $err) ;
  
  rule teleToPi: (teleToPi () $cod) ~> $cod ;
  rule teleToPiCons: (teleToPi (($x , $dom) $rest) $cod) ~>
    (pi $dom (teleToPi $rest $cod)) ;

-----------------------------------------------------
-- SurfaceExt
-- Extended surface syntax (cubical constructs)
-----------------------------------------------------
piece SurfaceExt
  surfExtBase ::= "base" <surface> â†’ surfaceExt ;
  surfCofEq ::= "cof_eq" <surfaceExt> <surfaceExt> â†’ surfaceExt ;
  surfCofAnd ::= "cof_and" <surfaceExt> <surfaceExt> â†’ surfaceExt ;
  surfCofOr ::= "cof_or" <surfaceExt> <surfaceExt> â†’ surfaceExt ;
  surfCofTop ::= "cof_top" â†’ surfaceExt ;
  surfCofBot ::= "cof_bot" â†’ surfaceExt ;
  surfBoundary ::= "boundary" <surfaceExt> â†’ surfaceExt ;
  surfCoe ::= "coe" <surfaceExt> <surfaceExt> <surfaceExt> <surfaceExt> â†’ surfaceExt ;
  surfHcom ::= "hcom" <surfaceExt> <surfaceExt> <surfaceExt> <surfaceExt> <surfaceExt> â†’ surfaceExt ;
  surfCom ::= "com" <surfaceExt> <surfaceExt> <surfaceExt> <sysEntry>* <surfaceExt> â†’ surfaceExt ;
  sysEntry ::= "[" <surfaceExt> "â†¦" <surfaceExt> "]" â†’ sysEntry ;
  surfVType ::= "V" <surfaceExt> <surfaceExt> <surfaceExt> <surfaceExt> â†’ surfaceExt ;
  surfVIn ::= "vin" <surfaceExt> <surfaceExt> <surfaceExt> â†’ surfaceExt ;
  surfVProj ::= "vproj" <surfaceExt> <surfaceExt> â†’ surfaceExt ;
  surfExt ::= "ext" <number> <surfaceExt> <surfaceExt> <surfaceExt> â†’ surfaceExt ;
  surfExtLam ::= "extLam" <number> <surfaceExt> â†’ surfaceExt ;
  surfExtApp ::= "extApp" <surfaceExt> <surfaceExt>* â†’ surfaceExt ;
  surfSub ::= "sub" <surfaceExt> <surfaceExt> <surfaceExt> â†’ surfaceExt ;
  surfSubIn ::= "subIn" <surfaceExt> â†’ surfaceExt ;
  surfSubOut ::= "subOut" <surfaceExt> â†’ surfaceExt ;

-----------------------------------------------------
-- Helpers
-- Convenience constructors
-----------------------------------------------------
piece Helpers
  rule mkPiNil: (mkPi () $cod) ~> $cod ;
  rule mkPiCons: (mkPi (($x , $ty) $rest) $cod) ~> (Î  ($x : $ty) (mkPi $rest $cod)) ;
  
  rule mkLamNil: (mkLam () $body) ~> $body ;
  rule mkLamCons: (mkLam ($x $rest) $body) ~> (Î» $x . (mkLam $rest $body)) ;
  
  rule mkAppsNil: (mkApps $f ()) ~> $f ;
  rule mkAppsCons: (mkApps $f ($a $rest)) ~> (mkApps (app $f $a) $rest) ;

-----------------------------------------------------
-- Examples
-- Sample surface terms
-----------------------------------------------------
piece Examples
  rule idSurface: idSurface ~> (Î» x . (var x)) ;
  rule idTypeSurface: idTypeSurface ~> (Î  (A : (Type 0)) (Î  (x : (var A)) (var A))) ;
  rule constSurface: constSurface ~> (Î» x . (Î» y . (var x))) ;
  rule flipSurface: flipSurface ~> (Î» f . (Î» x . (Î» y . (app (app (var f) (var y)) (var x))))) ;
  rule zeroSurface: zeroSurface ~> (intro Nat . zero ()) ;
  rule sucSurface: (sucSurface $n) ~> (intro Nat . suc ($n)) ;
  rule twoSurface: twoSurface ~> (sucSurface (sucSurface zeroSurface)) ;


-----------------------------------------------------
-- Derived Operations
-----------------------------------------------------

derive subst for term ;
derive normalize for term with fuel = 100 ;

