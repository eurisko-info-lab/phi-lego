-----------------------------------------------------
-- Unify.lego: Miller-Pattern Unification for Higher-Order Terms
--
-- Mathematical Structure:
-- - Unification finds substitution σ such that σ(t₁) ≡ σ(t₂)
-- - Meta-variables are existentially quantified unknowns
-- - Pattern fragment (distinct variable spines) ensures decidability
-- - Higher-order: metas can have function type, spine is arguments
--
-- Implements:
-- - Flex-rigid: ?α x₁...xₙ = t → ?α := λy₁...yₙ. t[xᵢ↦yᵢ]
-- - Flex-flex same: ?α x y = ?α y x → intersection of spines
-- - Flex-flex diff: ?α x = ?β y → create common meta
-- - Occurs check, scope checking, constraint solving loop
-----------------------------------------------------

import Core ;
import GlobalEnv ;
import Visitor ;

lang Unify (Core, GlobalEnv, Visitor) :=

-----------------------------------------------------
-- MetaInfo
-- A meta-variable with its context and type
-----------------------------------------------------
piece MetaInfo
  metaInfo ::= "metaInfo" "name:" <gname> "ctx:" <expr>* "ty:" <expr> "solution:" <expr>? → metaInfo ;
  
  rule metaInfoName: (metaInfoName (metaInfo name: $n ctx: $c ty: $t solution: $s)) ~> $n ;
  rule metaInfoCtx: (metaInfoCtx (metaInfo name: $n ctx: $c ty: $t solution: $s)) ~> $c ;
  rule metaInfoTy: (metaInfoTy (metaInfo name: $n ctx: $c ty: $t solution: $s)) ~> $t ;
  rule metaInfoSolution: (metaInfoSolution (metaInfo name: $n ctx: $c ty: $t solution: $s)) ~> $s ;

-----------------------------------------------------
-- UnifyState
-- Unification state
-----------------------------------------------------
piece UnifyState
  unifyState ::= "unifyState" "metas:" <metaInfo>* "nextId:" <number> "postponed:" <constraint>* → unifyState ;
  constraint ::= "(" <expr> "≡" <expr> ")" → constraint ;
  
  rule unifyStateEmpty: unifyStateEmpty ~> (unifyState metas: () nextId: 0 postponed: ()) ;
  
  rule unifyStateFreshMeta: (unifyStateFreshMeta (unifyState metas: $metas nextId: $n postponed: $p) $ctx $ty) ~>
    (let name = (gnameFresh "?" $n) in
     let info = (metaInfo name: name ctx: $ctx ty: $ty solution: none) in
     (result: (unifyState metas: (info $metas) nextId: (suc $n) postponed: $p) name: name)) ;
  
  rule unifyStateLookupMeta: (unifyStateLookupMeta (unifyState metas: $metas nextId: $n postponed: $p) $name) ~>
    (findMeta $metas $name) ;
  
  rule findMetaNil: (findMeta () $name) ~> none ;
  rule findMetaMatch: (findMeta ((metaInfo name: $name ctx: $c ty: $t solution: $s) $rest) $name) ~>
    (some (metaInfo name: $name ctx: $c ty: $t solution: $s)) ;
  rule findMetaMiss: (findMeta ($m $rest) $name) ~> (findMeta $rest $name) ;
  
  rule unifyStateSolveMeta: (unifyStateSolveMeta (unifyState metas: $metas nextId: $n postponed: $p) $name $sol) ~>
    (unifyState metas: (solveMeta $metas $name $sol) nextId: $n postponed: $p) ;
  
  rule solveMetaNil: (solveMeta () $name $sol) ~> () ;
  rule solveMetaMatch: (solveMeta ((metaInfo name: $name ctx: $c ty: $t solution: $old) $rest) $name $sol) ~>
    ((metaInfo name: $name ctx: $c ty: $t solution: (some $sol)) $rest) ;
  rule solveMetaMiss: (solveMeta ($m $rest) $name $sol) ~> ($m (solveMeta $rest $name $sol)) ;
  
  rule unifyStateIsSolved: (unifyStateIsSolved $st $name) ~>
    (case (unifyStateLookupMeta $st $name)
      (some (metaInfo name: _ ctx: _ ty: _ solution: (some _))) => true
      _ => false) ;
  
  rule unifyStateUnsolved: (unifyStateUnsolved (unifyState metas: $metas nextId: $n postponed: $p)) ~>
    (filter (fun m => (isNone (metaInfoSolution m))) $metas) ;
  
  rule unifyStatePostpone: (unifyStatePostpone (unifyState metas: $metas nextId: $n postponed: $p) $t1 $t2) ~>
    (unifyState metas: $metas nextId: $n postponed: (($t1 ≡ $t2) $p)) ;
  
  rule unifyStateTakePostponed: (unifyStateTakePostponed (unifyState metas: $metas nextId: $n postponed: $p)) ~>
    (result: (unifyState metas: $metas nextId: $n postponed: ()) constraints: $p) ;

-----------------------------------------------------
-- UnifyResult
-- Result of unification
-----------------------------------------------------
piece UnifyResult
  unifySuccess ::= "success" <unifyState> → unifyResult ;
  unifyFailure ::= "failure" <string> → unifyResult ;
  unifyStuck ::= "stuck" <unifyState> → unifyResult ;

-----------------------------------------------------
-- SpineElem
-- Spine element: term var, dim var, or other
-----------------------------------------------------
piece SpineElem
  spineTermVar ::= "termVar" <number> → spineElem ;
  spineDimVar ::= "dimVar" <number> → spineElem ;
  spineOther ::= "other" <expr> → spineElem ;
  
  rule classifySpineArg: (classifySpineArg (ix $n)) ~> (termVar $n) ;
  rule classifySpineArgDim: (classifySpineArg (dimVar $n)) ~> (dimVar $n) ;
  rule classifySpineArgOther: (classifySpineArg $e) ~> (other $e) ;

-----------------------------------------------------
-- Spine
-- Spine collection and pattern checking
-----------------------------------------------------
piece Spine
  rule collectSpine: (collectSpine $e) ~> (collectSpine' $e ()) ;
  rule collectSpine'App: (collectSpine' (app $f $a) $acc) ~> (collectSpine' $f ($acc $a)) ;
  rule collectSpine'Papp: (collectSpine' (papp $f $a) $acc) ~> (collectSpine' $f ($acc $a)) ;
  rule collectSpine'Other: (collectSpine' $e $acc) ~> ($e , $acc) ;
  
  rule isPatternSpine: (isPatternSpine $args) ~>
    (let elems = (map classifySpineArg $args) in
     let allVars = (all isSpineVar elems) in
     let distinct = (eq (length (eraseDups elems)) (length elems)) in
     (and allVars distinct)) ;
  
  rule isSpineVar: (isSpineVar (termVar $n)) ~> true ;
  rule isSpineVarDim: (isSpineVar (dimVar $n)) ~> true ;
  rule isSpineVarOther: (isSpineVar (other $e)) ~> false ;
  
  rule spineToVars: (spineToVars $args) ~>
    (filterMap extractVarIndex (map classifySpineArg $args)) ;
  
  rule extractVarIndex: (extractVarIndex (termVar $n)) ~> (some $n) ;
  rule extractVarIndexDim: (extractVarIndex (dimVar $n)) ~> (some $n) ;
  rule extractVarIndexOther: (extractVarIndex (other $e)) ~> none ;
  
  rule isMeta: (isMeta (lit $name)) ~>
    (case (startsWith $name "?")
      true => (some $name)
      false => none) ;
  rule isMetaOther: (isMeta $e) ~> none ;

-----------------------------------------------------
-- Invert
-- Miller pattern inversion
-----------------------------------------------------
piece Invert
  rule invertTerm: (invertTerm $spineVars $term) ~>
    (invertTerm' $spineVars $term 0 (length $spineVars)) ;
  
  -- Variables: remap through spine
  rule invertTerm'Ix: (invertTerm' $spineVars (ix $n) $depth $len) ~>
    (case (findIndex $spineVars $n)
      (some $i) => (some (ix (plus $depth (minus (minus $len $i) 1))))
      none => (case (gte $n $len)
        true => (some (ix (plus $depth (minus $n $len))))  -- free var past spine
        false => none)) ;  -- scope escape
  
  -- Structurally recurse
  rule invertTerm'Lam: (invertTerm' $spineVars (lam $body) $depth $len) ~>
    (case (invertTerm' $spineVars $body (suc $depth) $len)
      (some $body') => (some (lam $body'))
      none => none) ;
  
  rule invertTerm'App: (invertTerm' $spineVars (app $f $a) $depth $len) ~>
    (case (invertTerm' $spineVars $f $depth $len)
      (some $f') => (case (invertTerm' $spineVars $a $depth $len)
        (some $a') => (some (app $f' $a'))
        none => none)
      none => none) ;
  
  rule invertTerm'Pi: (invertTerm' $spineVars (pi $dom $cod) $depth $len) ~>
    (case (invertTerm' $spineVars $dom $depth $len)
      (some $dom') => (case (invertTerm' $spineVars $cod (suc $depth) $len)
        (some $cod') => (some (pi $dom' $cod'))
        none => none)
      none => none) ;
  
  rule invertTerm'Lit: (invertTerm' $spineVars (lit $s) $depth $len) ~> (some (lit $s)) ;
  rule invertTerm'Dim0: (invertTerm' $spineVars dim0 $depth $len) ~> (some dim0) ;
  rule invertTerm'Dim1: (invertTerm' $spineVars dim1 $depth $len) ~> (some dim1) ;
  
  rule invertTerm'Default: (invertTerm' $spineVars $e $depth $len) ~> (some $e) ;

-----------------------------------------------------
-- FlexRigid
-- Solve flex-rigid equation: ?α args = term
-----------------------------------------------------
piece FlexRigid
  rule solveFlexRigid: (solveFlexRigid $st $metaName $args $term) ~>
    (let gname = (gnameNamed $metaName) in
     case (occurs gname $term)
       true => (failure (concat "occurs check failed: " $metaName " occurs in solution"))
       false => (solveFlexRigid' $st $metaName $args $term gname)) ;
  
  rule solveFlexRigid': (solveFlexRigid' $st $metaName $args $term $gname) ~>
    (case (isPatternSpine $args)
      false => (stuck (unifyStatePostpone $st (lit $metaName) $term))
      true => (let spineVars = (spineToVars $args) in
               case (invertTerm spineVars $term)
                 none => (stuck (unifyStatePostpone $st (lit $metaName) $term))
                 (some $invertedTerm) =>
                   (let solution = (buildSolution $args $invertedTerm) in
                    (success (unifyStateSolveMeta $st $gname solution))))) ;
  
  rule buildSolution: (buildSolution () $body) ~> $body ;
  rule buildSolutionCons: (buildSolution ($a $rest) $body) ~>
    (lam (buildSolution $rest $body)) ;

-----------------------------------------------------
-- Unify
-- Core unification
-----------------------------------------------------
piece Unify
  rule unify: (unify $st $t1 $t2) ~>
    (case (conv $t1 $t2)
      true => (success $st)
      false => (let h1Args1 = (collectSpine $t1) in
                let h2Args2 = (collectSpine $t2) in
                (unifyHeads $st (fst h1Args1) (snd h1Args1) (fst h2Args2) (snd h2Args2)))) ;
  
  rule unifyHeads: (unifyHeads $st $h1 $args1 $h2 $args2) ~>
    (case (isMeta $h1) (isMeta $h2)
      (some $m) none => (solveFlexRigid $st $m $args1 (foldl app $h2 $args2))
      none (some $m) => (solveFlexRigid $st $m $args2 (foldl app $h1 $args1))
      (some $m1) (some $m2) => (case (eq $m1 $m2)
        true => (flexFlexSame $st $m1 $args1 $args2)
        false => (flexFlexDiff $st $m1 $args1 $m2 $args2))
      none none => (unifyRigid $st (foldl app $h1 $args1) (foldl app $h2 $args2))) ;

-----------------------------------------------------
-- FlexFlexSame
-- Handle ?α args₁ = ?α args₂
-----------------------------------------------------
piece FlexFlexSame
  rule flexFlexSame: (flexFlexSame $st $metaName $args1 $args2) ~>
    (case (eq (length $args1) (length $args2))
      false => (failure "flex-flex: spine length mismatch")
      true => (case (and (isPatternSpine $args1) (isPatternSpine $args2))
        false => (stuck (unifyStatePostpone $st (lit $metaName) (lit $metaName)))
        true => (flexFlexSamePattern $st $metaName (spineToVars $args1) (spineToVars $args2)))) ;
  
  rule flexFlexSamePattern: (flexFlexSamePattern $st $metaName $vars1 $vars2) ~>
    (let pairs = (zip $vars1 $vars2) in
     let commonCount = (length (filter (fun p => (eq (fst p) (snd p))) pairs)) in
     case (eq commonCount (length $vars1))
       true => (success $st)
       false => (stuck (unifyStatePostpone $st (lit $metaName) (lit $metaName)))) ;

-----------------------------------------------------
-- FlexFlexDiff
-- Handle ?α args₁ = ?β args₂
-----------------------------------------------------
piece FlexFlexDiff
  rule flexFlexDiff: (flexFlexDiff $st $m1 $args1 $m2 $args2) ~>
    (case (and (isPatternSpine $args1) (isPatternSpine $args2))
      false => (stuck (unifyStatePostpone $st (lit $m1) (lit $m2)))
      true => (let vars1 = (spineToVars $args1) in
               let vars2 = (spineToVars $args2) in
               (flexFlexDiff' $st $m1 $args1 vars1 $m2 $args2 vars2))) ;
  
  rule flexFlexDiff': (flexFlexDiff' $st $m1 $args1 $vars1 $m2 $args2 $vars2) ~>
    (let subset21 = (all (fun v => (contains $vars1 v)) $vars2) in
     let subset12 = (all (fun v => (contains $vars2 v)) $vars1) in
     case subset21
       true => (let body = (buildMetaApp $m1 $vars1 $vars2) in
                let solution = (buildSolution $args2 body) in
                (success (unifyStateSolveMeta $st (gnameNamed $m2) solution)))
       false => (case subset12
         true => (let body = (buildMetaApp $m2 $vars2 $vars1) in
                  let solution = (buildSolution $args1 body) in
                  (success (unifyStateSolveMeta $st (gnameNamed $m1) solution)))
         false => (stuck (unifyStatePostpone $st (lit $m1) (lit $m2))))) ;
  
  rule buildMetaApp: (buildMetaApp $m $sourceVars $targetVars) ~>
    (let reindexed = (map (fun v => (findIndexOr0 $sourceVars v)) $targetVars) in
     (foldl app (lit $m) (map ix reindexed))) ;
  
  rule findIndexOr0: (findIndexOr0 $xs $v) ~>
    (case (findIndex $xs $v)
      (some $i) => $i
      none => 0) ;

-----------------------------------------------------
-- UnifyRigid
-- Structural unification of rigid terms
-----------------------------------------------------
piece UnifyRigid
  rule unifyRigidIx: (unifyRigid $st (ix $n1) (ix $n2)) ~>
    (case (eq $n1 $n2) true => (success $st) false => (failure "variable mismatch")) ;
  
  rule unifyRigidLit: (unifyRigid $st (lit $l1) (lit $l2)) ~>
    (case (eq $l1 $l2) true => (success $st) false => (failure (concat "literal mismatch: " $l1 " ≠ " $l2))) ;
  
  rule unifyRigidUniv: (unifyRigid $st (univ $l1) (univ $l2)) ~>
    (case (levelEq $l1 $l2) true => (success $st) false => (failure "universe level mismatch")) ;
  
  rule unifyRigidLam: (unifyRigid $st (lam $b1) (lam $b2)) ~> (unify $st $b1 $b2) ;
  
  rule unifyRigidApp: (unifyRigid $st (app $f1 $a1) (app $f2 $a2)) ~>
    (case (unify $st $f1 $f2)
      (success $st') => (unify $st' $a1 $a2)
      $other => $other) ;
  
  rule unifyRigidPi: (unifyRigid $st (pi $d1 $c1) (pi $d2 $c2)) ~>
    (case (unify $st $d1 $d2)
      (success $st') => (unify $st' $c1 $c2)
      $other => $other) ;
  
  rule unifyRigidSigma: (unifyRigid $st (sigma $d1 $c1) (sigma $d2 $c2)) ~>
    (case (unify $st $d1 $d2)
      (success $st') => (unify $st' $c1 $c2)
      $other => $other) ;
  
  rule unifyRigidPair: (unifyRigid $st (pair $a1 $b1) (pair $a2 $b2)) ~>
    (case (unify $st $a1 $a2)
      (success $st') => (unify $st' $b1 $b2)
      $other => $other) ;
  
  rule unifyRigidFst: (unifyRigid $st (fst $p1) (fst $p2)) ~> (unify $st $p1 $p2) ;
  rule unifyRigidSnd: (unifyRigid $st (snd $p1) (snd $p2)) ~> (unify $st $p1 $p2) ;
  
  rule unifyRigidPath: (unifyRigid $st (path $t1 $a1 $b1) (path $t2 $a2 $b2)) ~>
    (case (unify $st $t1 $t2)
      (success $st') => (case (unify $st' $a1 $a2)
        (success $st'') => (unify $st'' $b1 $b2)
        $other => $other)
      $other => $other) ;
  
  rule unifyRigidPlam: (unifyRigid $st (plam $b1) (plam $b2)) ~> (unify $st $b1 $b2) ;
  
  rule unifyRigidPapp: (unifyRigid $st (papp $p1 $r1) (papp $p2 $r2)) ~>
    (case (unify $st $p1 $p2)
      (success $st') => (unify $st' $r1 $r2)
      $other => $other) ;
  
  rule unifyRigidDim0: (unifyRigid $st dim0 dim0) ~> (success $st) ;
  rule unifyRigidDim1: (unifyRigid $st dim1 dim1) ~> (success $st) ;
  rule unifyRigidNat: (unifyRigid $st nat nat) ~> (success $st) ;
  rule unifyRigidZero: (unifyRigid $st zero zero) ~> (success $st) ;
  rule unifyRigidSuc: (unifyRigid $st (suc $n1) (suc $n2)) ~> (unify $st $n1 $n2) ;
  rule unifyRigidCircle: (unifyRigid $st circle circle) ~> (success $st) ;
  rule unifyRigidBase: (unifyRigid $st base base) ~> (success $st) ;
  rule unifyRigidLoop: (unifyRigid $st (loop $r1) (loop $r2)) ~> (unify $st $r1 $r2) ;
  rule unifyRigidCofTop: (unifyRigid $st cof_top cof_top) ~> (success $st) ;
  rule unifyRigidCofBot: (unifyRigid $st cof_bot cof_bot) ~> (success $st) ;
  
  rule unifyRigidDefault: (unifyRigid $st $t1 $t2) ~> (failure "structural mismatch") ;

-----------------------------------------------------
-- ApplyMetas
-- Substitute solved metas in expression
-----------------------------------------------------
piece ApplyMetas
  rule applyMetas: (applyMetas $st $e) ~> (applyMetas' $st $e) ;
  
  rule applyMetas'Lit: (applyMetas' $st (lit $name)) ~>
    (case (startsWith $name "?")
      true => (case (unifyStateLookupMeta $st (gnameNamed $name))
        (some (metaInfo name: _ ctx: _ ty: _ solution: (some $sol))) => $sol
        _ => (lit $name))
      false => (lit $name)) ;
  
  rule applyMetas'Lam: (applyMetas' $st (lam $b)) ~> (lam (applyMetas' $st $b)) ;
  rule applyMetas'App: (applyMetas' $st (app $f $a)) ~> (app (applyMetas' $st $f) (applyMetas' $st $a)) ;
  rule applyMetas'Pi: (applyMetas' $st (pi $d $c)) ~> (pi (applyMetas' $st $d) (applyMetas' $st $c)) ;
  rule applyMetas'Default: (applyMetas' $st $e) ~> $e ;

-----------------------------------------------------
-- SolveAll
-- Constraint solving loop
-----------------------------------------------------
piece SolveAll
  rule processPostponed: (processPostponed $st) ~>
    (case (unifyStateTakePostponed $st)
      (result: $st' constraints: ()) => (result: $st' progress: false)
      (result: $st' constraints: $constraints) =>
        (processConstraints $st' $constraints false)) ;
  
  rule processConstraints: (processConstraints $st () $progress) ~> (result: $st progress: $progress) ;
  rule processConstraintsCons: (processConstraints $st ((($t1 ≡ $t2)) $rest) $progress) ~>
    (let t1' = (applyMetas $st $t1) in
     let t2' = (applyMetas $st $t2) in
     case (unify $st t1' t2')
       (success $newSt) => (processConstraints $newSt $rest true)
       (stuck $newSt) => (processConstraints $newSt $rest $progress)
       (failure _) => (processConstraints (unifyStatePostpone $st t1' t2') $rest $progress)) ;
  
  rule solveAll: (solveAll $st $fuel) ~> (solveAll' $st $fuel) ;
  rule solveAll'0: (solveAll' $st 0) ~> $st ;
  rule solveAll': (solveAll' $st (suc $fuel)) ~>
    (case (processPostponed $st)
      (result: $st' progress: true) => (solveAll' $st' $fuel)
      (result: $st' progress: false) => $st') ;

-----------------------------------------------------
-- TopLevel
-- High-level interface
-----------------------------------------------------
piece TopLevel
  rule tryUnify: (tryUnify $st $t1 $t2) ~>
    (case (unify $st $t1 $t2)
      (success $st') => (some $st')
      (stuck $st') => (some $st')
      (failure _) => none) ;
  
  rule unifyAndSolve: (unifyAndSolve $st $t1 $t2) ~>
    (case (unify $st $t1 $t2)
      (success $st') => (some (solveAll $st' 100))
      (stuck $st') => (some (solveAll $st' 100))
      (failure _) => none) ;
  
  rule hole: (hole $st $ctx $ty) ~>
    (case (unifyStateFreshMeta $st $ctx $ty)
      (result: $st' name: $name) => (result: $st' expr: (lit (gnameName $name)))) ;
  
  rule allSolved: (allSolved $st) ~> (isEmpty (unifyStateUnsolved $st)) ;


-----------------------------------------------------
-- Derived Operations
-----------------------------------------------------

derive subst for term ;
derive normalize for term with fuel = 100 ;

