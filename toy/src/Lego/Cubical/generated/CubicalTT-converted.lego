-----------------------------------------------------
-- CubicalTT: Shared Cubical Type Theory Foundation
-- 
-- Core CCHM cubical type theory shared by redtt and cooltt.
-- Red.lego and Cool.lego import this as their base.
--
-- Mathematical Foundation: Cartesian Cubical Type Theory
-- - Interval I: De Morgan algebra
-- - Cofibrations Ï†: distributive lattice  
-- - Kan operations: computational univalence
--
-- ENCODING: Multi-sort syntax (dim, cof, system) is encoded as terms
-- using constructor prefixes. The original multi-sort grammar is
-- preserved in comments.
--
-- Notation:
--   [x := t] body  -- substitution (replace x with t in body)
--   [$x : A] B     -- context extension (x:A in scope for B)
-----------------------------------------------------

lang CubicalTT :=

-----------------------------------------------------
-- Dimension
-- The interval I with De Morgan algebra structure
-- I forms a De Morgan algebra: (I, âˆ¨, âˆ§, ~, 0, 1)
--
-- Original grammar:
--   dim ::= "0" â†’ i0 | "1" â†’ i1 | <ident> â†’ ivar
--         | dim "âˆ¨" dim â†’ join | dim "âˆ§" dim â†’ meet | "~" dim â†’ inv ;
-----------------------------------------------------

piece Dimension
  term ::= "i0"                        â†’ i0
         | "i1"                        â†’ i1
         | "ivar" term                 â†’ ivar
         | "join" term term            â†’ join
         | "meet" term term            â†’ meet
         | "inv" term                  â†’ inv ;

  -- De Morgan algebra laws
  rule join0L: (join i0 $r) ~> $r ;
  rule join0R: (join $r i0) ~> $r ;
  rule join1L: (join i1 $r) ~> i1 ;
  rule join1R: (join $r i1) ~> i1 ;
  rule joinIdem: (join $r $r) ~> $r ;
  rule meet0L: (meet i0 $r) ~> i0 ;
  rule meet0R: (meet $r i0) ~> i0 ;
  rule meet1L: (meet i1 $r) ~> $r ;
  rule meet1R: (meet $r i1) ~> $r ;
  rule meetIdem: (meet $r $r) ~> $r ;
  rule inv0: (inv i0) ~> i1 ;
  rule inv1: (inv i1) ~> i0 ;
  rule invInv: (inv (inv $r)) ~> $r ;
  -- De Morgan: ~(r âˆ¨ s) = ~r âˆ§ ~s
  rule deMorganOr: (inv (join $r $s)) ~> (meet (inv $r) (inv $s)) ;
  rule deMorganAnd: (inv (meet $r $s)) ~> (join (inv $r) (inv $s)) ;

  type dimForm: $r : I ;

  test "join-id": (join i0 i) ~~> i ;
  test "meet-zero": (meet i0 i) ~~> i0 ;
  test "involution": (inv (inv i)) ~~> i ;

-----------------------------------------------------
-- Cofibration
-- Cofibrations Ï† : ð”½ (face lattice)
-- Classifies the "extent" of a partial element
--
-- Original grammar:
--   cof ::= "âŠ¥" â†’ cof0 | "âŠ¤" â†’ cof1 | dim "=" dim â†’ eq
--         | cof "âˆ¨" cof â†’ cofOr | cof "âˆ§" cof â†’ cofAnd ;
-----------------------------------------------------

piece Cofibration
  term ::= "cof0"                      â†’ cof0
         | "cof1"                      â†’ cof1
         | "eq" term term              â†’ eq
         | "cofOr" term term           â†’ cofOr
         | "cofAnd" term term          â†’ cofAnd ;
        
  -- Lattice laws
  rule cof0Or: (cofOr cof0 $Ï†) ~> $Ï† ;
  rule cof1Or: (cofOr cof1 $Ï†) ~> cof1 ;
  rule cofOrIdem: (cofOr $Ï† $Ï†) ~> $Ï† ;
  rule cof0And: (cofAnd cof0 $Ï†) ~> cof0 ;
  rule cof1And: (cofAnd cof1 $Ï†) ~> $Ï† ;
  rule cofAndIdem: (cofAnd $Ï† $Ï†) ~> $Ï† ;
  
  -- Equation rules
  rule eqRefl: (eq $r $r) ~> cof1 ;
  rule eq01: (eq i0 i1) ~> cof0 ;
  rule eq10: (eq i1 i0) ~> cof0 ;

  type cofForm: $Ï† : ð”½ ;

-----------------------------------------------------
-- Core
-- Universe, variables, basic terms
-----------------------------------------------------

piece Core
  term ::= "U"                         â†’ U
         | "pair" term term            â†’ pair
         | "fst" term                  â†’ fst
         | "snd" term                  â†’ snd ;

  rule fstPair: (fst (pair $a $b)) ~> $a ;
  rule sndPair: (snd (pair $a $b)) ~> $b ;
    
  type univForm: U : U ;

  test "fst": (fst (pair a b)) ~~> a ;
  test "snd": (snd (pair a b)) ~~> b ;

-----------------------------------------------------
-- Lambda
-- Lambda abstraction and dimension abstraction
-- Binders: Î» x . body binds x in body
--          Î»áµ¢ i . body binds dimension i in body
-----------------------------------------------------

piece Lambda
  term ::= "lam" term "." term         â†’ lam
         | "dlam" term "." term        â†’ dlam
         | "app" term term             â†’ app
         | "dapp" term term            â†’ dapp ;

  rule beta: (app (lam $x . $body) $arg) ~> [$x := $arg] $body ;
  rule dbeta: (dapp (dlam $i . $body) $r) ~> [$i := $r] $body ;
    
  type lamForm: (lam $x . $body) : (Pi $x : $A . $B)
    when [$x : $A] $body : $B ;
  type dlamForm: (dlam $i . $body) : (PathP $i . $A . $a0 . $a1) ;

  test "beta": (app (lam x . x) y) ~~> y ;
  test "dbeta": (dapp (dlam i . (dapp f i)) i0) ~~> (dapp f i0) ;

-----------------------------------------------------
-- Pi
-- Dependent function types: Î  (x : A) . B
-- Binder: x binds in B
-----------------------------------------------------

piece Pi
  term ::= "Pi" term ":" term "." term â†’ Pi
         | "arr" term term             â†’ arr ;

  -- Non-dependent arrow is sugar
  rule arrSugar: (arr $A $B) ~> (Pi _ : $A . $B) ;

  type PiForm: (Pi $x : $A . $B) : U
    when $A : U, [$x : $A] $B : U ;
  type appType: (app $f $a) : [$x := $a] $B
    when $f : (Pi $x : $A . $B), $a : $A ;

-----------------------------------------------------
-- Sigma  
-- Dependent pair types: Î£ (x : A) . B
-- Binder: x binds in B
-----------------------------------------------------

piece Sigma
  term ::= "Sigma" term ":" term "." term â†’ Sigma
         | "prod" term term            â†’ prod ;

  -- Non-dependent product is sugar
  rule prodSugar: (prod $A $B) ~> (Sigma _ : $A . $B) ;

  type SigmaForm: (Sigma $x : $A . $B) : U
    when $A : U, [$x : $A] $B : U ;
  type pairType: (pair $a $b) : (Sigma $x : $A . $B)
    when $a : $A, $b : [$x := $a] $B ;
  type fstType: (fst $p) : $A
    when $p : (Sigma $x : $A . $B) ;
  type sndType: (snd $p) : [$x := (fst $p)] $B
    when $p : (Sigma $x : $A . $B) ;

-----------------------------------------------------
-- Path
-- Path types: Path A a b â‰… (i : I) â†’ A with endpoints
-- PathP (i.A) a b : dependent paths
-----------------------------------------------------

piece Path
  term ::= "Path" term term term       â†’ Path
         | "PathP" term "." term "." term "." term â†’ PathP ;

  -- Path is sugar for PathP with constant type
  rule pathSugar: (Path $A $a $b) ~> (PathP _ . $A . $a . $b) ;

  type PathForm: (Path $A $a $b) : U
    when $A : U, $a : $A, $b : $A ;
  type PathPForm: (PathP $i . $A . $a0 . $a1) : U
    when [$i : I] $A : U, $a0 : [$i := i0] $A, $a1 : [$i := i1] $A ;
  type dappType: (dapp $p $r) : [$i := $r] $A
    when $p : (PathP $i . $A . $a0 . $a1) ;
    
  test "refl-type": (dlam i . a) : (Path A a a) ;

-----------------------------------------------------
-- System
-- Partial elements: [Ï†â‚ â†¦ uâ‚, Ï†â‚‚ â†¦ uâ‚‚, ...]
-- Represents an element defined on faces
--
-- Original grammar:
--   system ::= "[" "]" â†’ sysEmpty | "[" sysbranch ("," sysbranch)* "]" â†’ sys ;
--   sysbranch ::= cof "â†¦" term â†’ branch ;
-----------------------------------------------------

piece System
  term ::= "sysEmpty"                  â†’ sysEmpty
         | "sys" term                  â†’ sys
         | "branch" term term          â†’ branch
         | "branches" term term        â†’ branches ;

  -- Systems must agree on overlaps
  type sysType: (sys $branches) : (Partial $Ï† $A) ;

-----------------------------------------------------
-- Coe
-- Coercion: coe r~>s (i.A) a
-- Transport along a line of types
-- Binder: i binds in A
-----------------------------------------------------

piece Coe
  term ::= "coe" term term term "." term term â†’ coe ;

  rule coeRefl: (coe $r $r $i . $A $a) ~> $a ;
  -- Coercion in constant type
  rule coeConst: (coe $r $s $i . $A $a) ~> $a
    when $i not-free-in $A ;
    
  type coeType: (coe $r $s $i . $A $a) : [$i := $s] $A
    when $r : I, $s : I, [$i : I] $A : U, $a : [$i := $r] $A ;
      
  test "coe-refl": (coe i0 i0 i . A a) ~~> a ;

-----------------------------------------------------
-- Hcom
-- Homogeneous composition: hcom r~>s A [Ï† â†¦ u] a
-- Fill a partial tube with a cap
-----------------------------------------------------

piece Hcom
  term ::= "hcom" term term term term term â†’ hcom ;

  rule hcomRefl: (hcom $r $r $A $sys $a) ~> $a ;
  -- When Ï† = âŠ¤, the system determines the result
  rule hcomTotal: (hcom $r $s $A (sys (branch cof1 $u)) $a) ~> [$j := $s] $u ;
    
  type hcomType: (hcom $r $s $A $sys $a) : $A ;

-----------------------------------------------------
-- Com
-- Heterogeneous composition: com r~>s (i.A) [Ï† â†¦ u] a
-- Combines coercion and hcom
-- Binder: i binds in A
-----------------------------------------------------

piece Com
  term ::= "com" term term term "." term term term â†’ com ;

  rule comRefl: (com $r $r $i . $A $sys $a) ~> $a ;

  type comType: (com $r $s $i . $A $sys $a) : [$i := $s] $A ;

-----------------------------------------------------
-- VType
-- V-types for univalence: V r A B e
-- Glue types that realize univalence
-----------------------------------------------------

piece VType
  term ::= "V" term term term term     â†’ V
         | "Vin" term term             â†’ Vin
         | "Vproj" term term term      â†’ Vproj ;

  -- At r=0: V 0 A B e â‰… A, at r=1: V 1 A B e â‰… B
  rule V0: (V i0 $A $B $e) ~> $A ;
  rule V1: (V i1 $A $B $e) ~> $B ;
  rule Vin0: (Vin i0 $a) ~> (fst $a) ;
  rule Vin1: (Vin i1 $a) ~> $a ;
  rule Vproj0: (Vproj i0 $v $e) ~> (app $e (snd $v)) ;
  rule Vproj1: (Vproj i1 $v $e) ~> $v ;
    
  type VForm: (V $r $A $B $e) : U
    when $A : U, $B : U, $e : (Equiv $A $B) ;
  type VinType: (Vin $r $a) : (V $r $A $B $e) ;

-----------------------------------------------------
-- Sub
-- Subtypes: Sub A Ï† u
-- Elements of A that equal u when Ï† holds
-----------------------------------------------------

piece Sub
  term ::= "Sub" term term term        â†’ Sub
         | "inS" term                  â†’ inS
         | "outS" term                 â†’ outS ;

  rule outInS: (outS (inS $a)) ~> $a ;
    
  type SubForm: (Sub $A $Ï† $u) : U
    when $A : U, [$Ï†] $u : $A ;
  type inSType: (inS $a) : (Sub $A $Ï† $u)
    when $a : $A, [$Ï†] $a = $u ;
  type outSType: (outS $s) : $A
    when $s : (Sub $A $Ï† $u) ;

-----------------------------------------------------
-- Glue
-- Glue types (generalized V-types)
-- Glue [Ï† â†¦ (T, e)] A : glue partial equivalences
-----------------------------------------------------

piece Glue
  term ::= "Glue" term term            â†’ Glue
         | "glue" term term            â†’ glue
         | "unglue" term term          â†’ unglue ;

  -- When Ï† holds, Glue [Ï† â†¦ (T,e)] A â‰… T
  rule unglueGlue: (unglue $Ï† (glue $sys $a)) ~> $a when $Ï† ;

  type GlueForm: (Glue $sys $A) : U ;

-----------------------------------------------------
-- Conversion
-- Judgmental equality for type checking
-----------------------------------------------------

piece Conversion
  -- Conversion is checked by normalization then comparison
  -- conv A B : true iff A and B are definitionally equal
  
  -- Structural rules
  rule convRefl: (conv $A $A) ~> true ;
  rule convSym: (conv $A $B) ~> (conv $B $A) ;
  
  -- Universe conversion
  rule convU: (conv U U) ~> true ;
  
  -- Pi conversion (contravariant in domain)
  rule convPi: (conv (Pi $x : $A1 . $B1) (Pi $x : $A2 . $B2)) 
    ~> (and (conv $A2 $A1) (conv $B1 $B2)) ;
  
  -- Sigma conversion
  rule convSigma: (conv (Sigma $x : $A1 . $B1) (Sigma $x : $A2 . $B2))
    ~> (and (conv $A1 $A2) (conv $B1 $B2)) ;
    
  -- Path conversion
  rule convPath: (conv (PathP $i . $A1 . $a01 . $a11) (PathP $i . $A2 . $a02 . $a12))
    ~> (and (conv $A1 $A2) (and (conv $a01 $a02) (conv $a11 $a12))) ;

-----------------------------------------------------
-- Neutral
-- Neutral terms (stuck computation)
-- These don't reduce further without more information
-----------------------------------------------------

piece Neutral

-----------------------------------------------------
-- Equiv
-- Equivalences for univalence
-- Equiv A B : A and B are equivalent types
-----------------------------------------------------

piece Equiv
  term ::= "Equiv" term term           â†’ Equiv ;

-----------------------------------------------------
-- Fiber
-- Fibers for contractibility
-- Fiber f b : the fiber of f over b
-----------------------------------------------------

piece Fiber
  term ::= "Fiber" term term           â†’ Fiber ;


-- Derived operations
derive subst for term ;
derive normalize for term ;
derive cata for term ;
derive eq for term ;
