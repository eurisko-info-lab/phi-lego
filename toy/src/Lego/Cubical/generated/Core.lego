-----------------------------------------------------
-- Core.lego: De Bruijn indexed Core IR with substitution engine
--
-- The foundation for computational type theory:
-- - De Bruijn indices for capture-avoiding substitution
-- - Shifting for correct variable handling under binders
-- - β-reduction rules for computation
--
-- Mathematical structure:
-- - Presheaf model: terms indexed by context length
-- - Substitution: functorial action on terms
-- - Weakening: natural transformation between context extensions
-----------------------------------------------------

import Lego.Algebra ;

lang Core :=

-----------------------------------------------------
-- Level
-- Universe level expressions
-- - Concrete levels: 0, 1, 2, ...
-- - Level variables: α, β, ... (for polymorphism)
-- - Level successor: suc ℓ
-- - Level maximum: max ℓ₁ ℓ₂
--
-- Key equations:
-- - max ℓ ℓ = ℓ
-- - max ℓ (suc ℓ) = suc ℓ
-----------------------------------------------------
piece Level
  level ::= "zero" → lzero
          | "suc" level → lsuc
          | "max" level level → lmax
          | "lvar" <number> → lvar
          ;
  
  -- Normalization rules
  rule maxIdempotent: (lmax $l $l) ~> $l ;
  rule maxZeroL: (lmax lzero $l) ~> $l ;
  rule maxZeroR: (lmax $l lzero) ~> $l ;
  rule maxSucSuc: (lmax (lsuc $l1) (lsuc $l2)) ~> (lsuc (lmax $l1 $l2)) ;
  
  test "max-idem": (lmax (lsuc lzero) (lsuc lzero)) ~~> (lsuc lzero) ;
  test "max-zero": (lmax lzero (lsuc lzero)) ~~> (lsuc lzero) ;

-----------------------------------------------------
-- Expr
-- Core term: de Bruijn indexed for substitution.
-- Index 0 = most recently bound variable
-- Index n = variable bound n binders ago
-----------------------------------------------------
piece Expr
  term ::= "ix" <number> → ix
         | "lit" <string> → lit
         | "lam" term → lam
         | "app" term term → app
         | "pi" term term → pi
         | "sigma" term term → sigma
         | "pair" term term → pair
         | "fst" term → fst
         | "snd" term → snd
         | "letE" term term term → letE
         | "univ" level → univ
         ;
  
  -- β-reduction rules
  rule beta: (app (lam $body) $arg) ~> (subst 0 $arg $body) ;
  rule fstPair: (fst (pair $a $b)) ~> $a ;
  rule sndPair: (snd (pair $a $b)) ~> $b ;
  rule letBeta: (letE $ty $val $body) ~> (subst 0 $val $body) ;
  
  test "beta": (app (lam (ix 0)) (lit "x")) ~~> (lit "x") ;
  test "fst": (fst (pair (lit "a") (lit "b"))) ~~> (lit "a") ;
  test "snd": (snd (pair (lit "a") (lit "b"))) ~~> (lit "b") ;

-----------------------------------------------------
-- Dimension
-- Interval and dimension operations
-----------------------------------------------------
piece Dimension
  term ::= "dim0" → dim0
         | "dim1" → dim1
         | "dimVar" <number> → dimVar
         ;

-----------------------------------------------------
-- Cofibration
-- Cofibrations for cubical types
-----------------------------------------------------
piece Cofibration
  term ::= "cof_top" → cof_top
         | "cof_bot" → cof_bot
         | "cof_eq" term term → cof_eq
         | "cof_and" term term → cof_and
         | "cof_or" term term → cof_or
         ;
  
  -- Simplification rules
  rule eqRefl: (cof_eq $r $r) ~> cof_top ;
  rule eq01: (cof_eq dim0 dim1) ~> cof_bot ;
  rule eq10: (cof_eq dim1 dim0) ~> cof_bot ;
  rule andTop: (cof_and cof_top $φ) ~> $φ ;
  rule andBot: (cof_and cof_bot $φ) ~> cof_bot ;
  rule orTop: (cof_or cof_top $φ) ~> cof_top ;
  rule orBot: (cof_or cof_bot $φ) ~> $φ ;
  
  test "eq-refl": (cof_eq dim0 dim0) ~~> cof_top ;
  test "eq-01": (cof_eq dim0 dim1) ~~> cof_bot ;

-----------------------------------------------------
-- Path
-- Path types and operations
-----------------------------------------------------
piece Path
  term ::= "path" term term term → path
         | "plam" term → plam
         | "papp" term term → papp
         | "refl" term → refl
         ;
  
  -- Path computation rules
  rule plamApp0: (papp (plam $body) dim0) ~> (substDim 0 dim0 $body) ;
  rule plamApp1: (papp (plam $body) dim1) ~> (substDim 0 dim1 $body) ;
  rule reflApp: (papp (refl $a) $r) ~> $a ;
  
  test "refl-app": (papp (refl (lit "a")) dim0) ~~> (lit "a") ;

-----------------------------------------------------
-- Kan
-- Kan operations: coe, hcom, com
-----------------------------------------------------
piece Kan
  term ::= "coe" term term term term → coe
         | "hcom" term term term term term → hcom
         | "hcomTube" term term term tubes term → hcomTube
         | "com" term term term tubes term → com
         | "ghcom" term term term tubes term → ghcom
         | "gcom" term term term tubes term → gcom
         ;
  tubes ::= tube* → tubes ;
  tube ::= "(" term "," term ")" → tube ;
  
  -- Degenerate direction: coe r r A a = a
  rule coeRefl: (coe $r $r $A $a) ~> $a ;
  rule hcomRefl: (hcom $r $r $A $φ $cap) ~> $cap ;
  
  test "coe-refl": (coe dim0 dim0 (univ lzero) (lit "A")) ~~> (lit "A") ;

-----------------------------------------------------
-- FHCom
-- Fibrant homogeneous composition
-----------------------------------------------------
piece FHCom
  term ::= "fhcom" term term term tubes → fhcom
         | "boxEl" term term term tubes → boxEl
         | "capEl" term term term tubes term → capEl
         ;

-----------------------------------------------------
-- Sys
-- Systems (partial elements)
-----------------------------------------------------
piece Sys
  term ::= "sys" branches → sys ;
  branches ::= branch* → branches ;
  branch ::= "(" term "," term ")" → branch ;

-----------------------------------------------------
-- VType
-- V-types (Glue types for univalence)
-----------------------------------------------------
piece VType
  term ::= "vtype" term term term term → vtype
         | "vin" term term term → vin
         | "vproj" term term term term term → vproj
         ;
  
  -- V-type reduction at endpoints
  rule vin0: (vin dim0 $a $b) ~> $a ;
  rule vin1: (vin dim1 $a $b) ~> $b ;
  
  test "vin-0": (vin dim0 (lit "a") (lit "b")) ~~> (lit "a") ;
  test "vin-1": (vin dim1 (lit "a") (lit "b")) ~~> (lit "b") ;

-----------------------------------------------------
-- Nat
-- Natural numbers (for HIT treatment)
-----------------------------------------------------
piece Nat
  term ::= "nat" → nat
         | "zero" → zero
         | "suc" term → suc
         | "natElim" term term term term → natElim
         ;
  
  -- Elimination rules
  rule natElimZero: (natElim $P $z $s zero) ~> $z ;
  rule natElimSuc: (natElim $P $z $s (suc $n)) ~> (app (app $s $n) (natElim $P $z $s $n)) ;
  
  test "nat-zero": (natElim P z s zero) ~~> z ;

-----------------------------------------------------
-- Circle
-- Circle (HIT)
-----------------------------------------------------
piece Circle
  term ::= "circle" → circle
         | "base" → base
         | "loop" term → loop
         | "circleElim" term term term term → circleElim
         ;
  
  -- loop endpoints
  rule loop0: (loop dim0) ~> base ;
  rule loop1: (loop dim1) ~> base ;
  rule circleElimBase: (circleElim $P $b $l base) ~> $b ;
  
  test "loop-0": (loop dim0) ~~> base ;
  test "loop-1": (loop dim1) ~~> base ;

-----------------------------------------------------
-- Extension
-- Extension types
-----------------------------------------------------
piece Extension
  term ::= "ext" <number> term term term → ext
         | "extLam" <number> term → extLam
         | "extApp" term dimList → extApp
         ;
  dimList ::= term* → dimList ;

-----------------------------------------------------
-- Sub
-- Sub types (cubical subtypes / restriction types)
-----------------------------------------------------
piece Sub
  term ::= "sub" term term term → sub
         | "subIn" term → subIn
         | "subOut" term → subOut
         ;
  
  -- β-reduction
  rule subBeta: (subOut (subIn $e)) ~> $e ;
  
  test "sub-beta": (subOut (subIn (lit "x"))) ~~> (lit "x") ;

-----------------------------------------------------
-- Shift
-- Shifting (weakening) operation
-- shift k e = e with free vars >= k incremented
-----------------------------------------------------
piece Shift
  rule shiftIx: (shift $k $n (ix $m)) ~> (ix (if (geq $m $k) (add $m $n) $m)) ;
  rule shiftLam: (shift $k $n (lam $body)) ~> (lam (shift (add $k 1) $n $body)) ;
  rule shiftApp: (shift $k $n (app $f $a)) ~> (app (shift $k $n $f) (shift $k $n $a)) ;
  rule shiftPi: (shift $k $n (pi $A $B)) ~> (pi (shift $k $n $A) (shift (add $k 1) $n $B)) ;

-----------------------------------------------------
-- Subst
-- Substitution operation
-- subst k v e = e[v/ix k]
-----------------------------------------------------
piece Subst
  rule substIxHit: (subst $k $v (ix $k)) ~> $v ;
  rule substIxMiss: (subst $k $v (ix $m)) ~> (ix (if (gt $m $k) (sub $m 1) $m))
    when (neq $k $m) ;
  rule substLam: (subst $k $v (lam $body)) ~> (lam (subst (add $k 1) (shift 0 1 $v) $body)) ;
  rule substApp: (subst $k $v (app $f $a)) ~> (app (subst $k $v $f) (subst $k $v $a)) ;

-----------------------------------------------------
-- Normalize
-- Normalization with fuel
-----------------------------------------------------
piece Normalize
  rule normalize: (normalize $fuel $t) ~> (normalizeStep (sub $fuel 1) (step $t))
    when (gt $fuel 0) ;
  rule normalizeZero: (normalize 0 $t) ~> $t ;
  rule normalizeStep: (normalizeStep $fuel (some $t)) ~> (normalize $fuel $t) ;
  rule normalizeStepNone: (normalizeStep $fuel none) ~> $t ;



-----------------------------------------------------
-- Derived Operations  
-----------------------------------------------------

derive subst for term with binders = [lam, pi, sg] ;
derive shift for term ;
derive normalize for term with fuel = 1000 ;
derive conv for term ;

