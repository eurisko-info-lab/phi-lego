-----------------------------------------------------
-- Conversion.lego: Equality and Subtyping Checking
--
-- Mathematical Structure:
-- - Definitional equality via normalization
-- - Type-directed equality checking
-- - Cofibration-aware comparison under restrictions
--
-- Key insight:
-- "Conversion checking works by first normalizing both sides to WHNF,
--  then comparing structurally. For types like Pi and Sigma, we compare
--  under binders. For neutral terms, we compare the head and spine."
-----------------------------------------------------

import Core ;
import Cofibration ;
import Visitor ;

lang Conversion (Core, Cofibration, Visitor) :=

-----------------------------------------------------
-- ConvResult
-- Result of conversion checking
-----------------------------------------------------
piece ConvResult
  convOk ::= "ok" â†’ convResult ;
  convFail ::= "fail" <string> â†’ convResult ;
  convBlocked ::= "blocked" <number> â†’ convResult ;
  
  rule convResultIsOk: (isOk ok) ~> true ;
  rule convResultIsOkFail: (isOk (fail $msg)) ~> false ;
  rule convResultIsOkBlocked: (isOk (blocked $n)) ~> false ;
  
  rule convAndThenOk: (andThen ok $k) ~> ($k unit) ;
  rule convAndThenFail: (andThen (fail $msg) $k) ~> (fail $msg) ;
  rule convAndThenBlocked: (andThen (blocked $n) $k) ~> (blocked $n) ;

-----------------------------------------------------
-- ConvCtx
-- Conversion context: size + cofibration assumptions
-----------------------------------------------------
piece ConvCtx
  convCtx ::= "convCtx" "size:" <number> "cof:" <expr> â†’ convCtx ;
  
  rule convCtxEmpty: convCtxEmpty ~> (convCtx size: 0 cof: cof_top) ;
  
  rule convCtxExtend: (convCtxExtend (convCtx size: $s cof: $Ï†)) ~>
    (convCtx size: (suc $s) cof: $Ï†) ;
  
  rule convCtxAssume: (convCtxAssume (convCtx size: $s cof: $Ï†) $Ïˆ) ~>
    (convCtx size: $s cof: (cof_and $Ï† $Ïˆ)) ;

-----------------------------------------------------
-- WHNF
-- Weak head normal form helpers
-----------------------------------------------------
piece WHNF
  rule defaultFuel: defaultFuel ~> 1000 ;
  
  -- whnf: reduce to weak head normal form
  rule whnf: (whnf $fuel $e) ~> (whnfStep $fuel $e) ;
  
  -- Iterative WHNF reduction
  rule whnfStep0: (whnfStep 0 $e) ~> $e ;
  rule whnfStep: (whnfStep (suc $fuel) $e) ~>
    (case (tryStep $e)
      (some $e') => (whnfStep $fuel $e')
      none => $e) ;
  
  -- Try one step of reduction
  rule tryStepApp: (tryStep (app (lam $body) $arg)) ~> (some (subst 0 $arg $body)) ;
  rule tryStepFst: (tryStep (fst (pair $a $b))) ~> (some $a) ;
  rule tryStepSnd: (tryStep (snd (pair $a $b))) ~> (some $b) ;
  rule tryStepPapp: (tryStep (papp (plam $body) $r)) ~> (some (dimSubst 0 $r $body)) ;
  rule tryStepDefault: (tryStep $e) ~> none ;

-----------------------------------------------------
-- EquateDim
-- Check if two dimensions are equal
-----------------------------------------------------
piece EquateDim
  rule equateDim: (equateDim $ctx $r1 $r2) ~>
    (let r1' = (whnf defaultFuel $r1) in
     let r2' = (whnf defaultFuel $r2) in
     (equateDim' $ctx r1' r2')) ;
  
  rule equateDim'Same: (equateDim' $ctx $r $r) ~> ok ;
  rule equateDim'00: (equateDim' $ctx dim0 dim0) ~> ok ;
  rule equateDim'11: (equateDim' $ctx dim1 dim1) ~> ok ;
  rule equateDim'IxEq: (equateDim' $ctx (ix $n) (ix $n)) ~> ok ;
  rule equateDim'IxNeq: (equateDim' $ctx (ix $n) (ix $m)) ~>
    (fail (concat "dimensions differ: " $n " vs " $m)) ;
  rule equateDim'Other: (equateDim' $ctx $r1 $r2) ~>
    (fail (concat "dimensions not equal: " $r1 " vs " $r2)) ;

-----------------------------------------------------
-- EquateCof
-- Check if two cofibrations are equal
-----------------------------------------------------
piece EquateCof
  rule equateCof: (equateCof $ctx $Ï†1 $Ï†2) ~>
    (let Ï†1' = (whnf defaultFuel $Ï†1) in
     let Ï†2' = (whnf defaultFuel $Ï†2) in
     (equateCof' $ctx Ï†1' Ï†2')) ;
  
  rule equateCof'Same: (equateCof' $ctx $Ï† $Ï†) ~> ok ;
  rule equateCof'Top: (equateCof' $ctx cof_top cof_top) ~> ok ;
  rule equateCof'Bot: (equateCof' $ctx cof_bot cof_bot) ~> ok ;
  
  rule equateCof'Eq: (equateCof' $ctx (cof_eq $r1 $s1) (cof_eq $r2 $s2)) ~>
    (andThen (equateDim $ctx $r1 $r2)
      (fun _ => (equateDim $ctx $s1 $s2))) ;
  
  rule equateCof'And: (equateCof' $ctx (cof_and $Ï†1a $Ï†1b) (cof_and $Ï†2a $Ï†2b)) ~>
    (andThen (equateCof $ctx $Ï†1a $Ï†2a)
      (fun _ => (equateCof $ctx $Ï†1b $Ï†2b))) ;
  
  rule equateCof'Or: (equateCof' $ctx (cof_or $Ï†1a $Ï†1b) (cof_or $Ï†2a $Ï†2b)) ~>
    (andThen (equateCof $ctx $Ï†1a $Ï†2a)
      (fun _ => (equateCof $ctx $Ï†1b $Ï†2b))) ;
  
  rule equateCof'Other: (equateCof' $ctx $Ï†1 $Ï†2) ~>
    (fail (concat "cofibrations not equal: " $Ï†1 " vs " $Ï†2)) ;

-----------------------------------------------------
-- EquateTp
-- Check if two types are equal
-----------------------------------------------------
piece EquateTp
  rule equateTp: (equateTp $ctx $tp1 $tp2) ~>
    (let tp1' = (whnf defaultFuel $tp1) in
     let tp2' = (whnf defaultFuel $tp2) in
     (equateTp' $ctx tp1' tp2')) ;
  
  -- Same type
  rule equateTp'Same: (equateTp' $ctx $tp $tp) ~> ok ;
  
  -- Base types
  rule equateTp'Nat: (equateTp' $ctx nat nat) ~> ok ;
  rule equateTp'Circle: (equateTp' $ctx circle circle) ~> ok ;
  
  -- Universes
  rule equateTp'Univ: (equateTp' $ctx (univ $n) (univ $n)) ~> ok ;
  rule equateTp'UnivNeq: (equateTp' $ctx (univ $n1) (univ $n2)) ~>
    (fail (concat "universe levels differ: " $n1 " vs " $n2)) ;
  
  -- Dimension and cofibration types
  rule equateTp'Dim: (equateTp' $ctx (lit "ð•€") (lit "ð•€")) ~> ok ;
  rule equateTp'Cof: (equateTp' $ctx (lit "ð”½") (lit "ð”½")) ~> ok ;
  
  -- Pi types
  rule equateTp'Pi: (equateTp' $ctx (pi $dom1 $cod1) (pi $dom2 $cod2)) ~>
    (andThen (equateTp $ctx $dom1 $dom2)
      (fun _ => (equateTp (convCtxExtend $ctx) $cod1 $cod2))) ;
  
  -- Sigma types
  rule equateTp'Sigma: (equateTp' $ctx (sigma $a1 $b1) (sigma $a2 $b2)) ~>
    (andThen (equateTp $ctx $a1 $a2)
      (fun _ => (equateTp (convCtxExtend $ctx) $b1 $b2))) ;
  
  -- Path types
  rule equateTp'Path: (equateTp' $ctx (path $a1 $l1 $r1) (path $a2 $l2 $r2)) ~>
    (andThen (equateTp $ctx $a1 $a2)
      (fun _ => (andThen (equateCon $ctx $a1 $l1 $l2)
        (fun _ => (equateCon $ctx $a1 $r1 $r2))))) ;
  
  -- Sub types
  rule equateTp'Sub: (equateTp' $ctx (sub $a1 $Ï†1 $t1) (sub $a2 $Ï†2 $t2)) ~>
    (andThen (equateTp $ctx $a1 $a2)
      (fun _ => (andThen (equateCof $ctx $Ï†1 $Ï†2)
        (fun _ => (equateCon (convCtxAssume $ctx $Ï†1) $a1 $t1 $t2))))) ;
  
  -- V types
  rule equateTp'VType: (equateTp' $ctx (vtype $r1 $a1 $b1 $e1) (vtype $r2 $a2 $b2 $e2)) ~>
    (andThen (equateDim $ctx $r1 $r2)
      (fun _ => (andThen (equateTp $ctx $a1 $a2)
        (fun _ => (andThen (equateTp $ctx $b1 $b2)
          (fun _ => (equateCon $ctx (lit "Equiv") $e1 $e2))))))) ;
  
  -- Literals
  rule equateTp'Lit: (equateTp' $ctx (lit $s) (lit $s)) ~> ok ;
  rule equateTp'LitNeq: (equateTp' $ctx (lit $s1) (lit $s2)) ~>
    (fail (concat "type literals differ: " $s1 " vs " $s2)) ;
  
  -- Default: not equal
  rule equateTp'Other: (equateTp' $ctx $tp1 $tp2) ~>
    (fail (concat "types not equal: " $tp1 " vs " $tp2)) ;

-----------------------------------------------------
-- EquateCon
-- Check if two terms are equal at a type
-----------------------------------------------------
piece EquateCon
  rule equateCon: (equateCon $ctx $tp $t1 $t2) ~>
    (let t1' = (whnf defaultFuel $t1) in
     let t2' = (whnf defaultFuel $t2) in
     (case (eq t1' t2')
       true => ok
       false => (equateCon' $ctx (whnf defaultFuel $tp) t1' t2'))) ;
  
  -- Pi types: compare under abstraction
  rule equateCon'Pi: (equateCon' $ctx (pi $dom $cod) $t1 $t2) ~>
    (let ctx' = (convCtxExtend $ctx) in
     let var = (ix 0) in
     let app1 = (app (shift 0 1 $t1) var) in
     let app2 = (app (shift 0 1 $t2) var) in
     (equateCon ctx' $cod app1 app2)) ;
  
  -- Sigma types: compare components
  rule equateCon'Sigma: (equateCon' $ctx (sigma $a $b) $t1 $t2) ~>
    (let fst1 = (fst $t1) in
     let fst2 = (fst $t2) in
     (andThen (equateCon $ctx $a fst1 fst2)
       (fun _ => (let snd1 = (snd $t1) in
                  let snd2 = (snd $t2) in
                  let b' = (subst 0 fst1 $b) in
                  (equateCon $ctx b' snd1 snd2))))) ;
  
  -- Path types: compare at fresh dimension
  rule equateCon'Path: (equateCon' $ctx (path $a $l $r) $t1 $t2) ~>
    (let ctx' = (convCtxExtend $ctx) in
     let var = (ix 0) in
     let papp1 = (papp (shift 0 1 $t1) var) in
     let papp2 = (papp (shift 0 1 $t2) var) in
     (equateCon ctx' $a papp1 papp2)) ;
  
  -- Sub types: compare base
  rule equateCon'Sub: (equateCon' $ctx (sub $a $Ï† $u) $t1 $t2) ~>
    (let out1 = (subOut $t1) in
     let out2 = (subOut $t2) in
     (equateCon $ctx $a out1 out2)) ;
  
  -- Nat: structural comparison
  rule equateCon'NatZero: (equateCon' $ctx nat zero zero) ~> ok ;
  rule equateCon'NatSuc: (equateCon' $ctx nat (suc $n1) (suc $n2)) ~>
    (equateCon $ctx nat $n1 $n2) ;
  rule equateCon'Nat: (equateCon' $ctx nat $t1 $t2) ~> (equateNeutral $ctx $t1 $t2) ;
  
  -- Circle: structural comparison
  rule equateCon'CircleBase: (equateCon' $ctx circle base base) ~> ok ;
  rule equateCon'CircleLoop: (equateCon' $ctx circle (loop $r1) (loop $r2)) ~>
    (equateDim $ctx $r1 $r2) ;
  rule equateCon'Circle: (equateCon' $ctx circle $t1 $t2) ~> (equateNeutral $ctx $t1 $t2) ;
  
  -- Dimension type
  rule equateCon'Dim: (equateCon' $ctx (lit "ð•€") $t1 $t2) ~> (equateDim $ctx $t1 $t2) ;
  
  -- Cofibration type
  rule equateCon'Cof: (equateCon' $ctx (lit "ð”½") $t1 $t2) ~> (equateCof $ctx $t1 $t2) ;
  
  -- Universe: compare as types
  rule equateCon'Univ: (equateCon' $ctx (univ $l) $t1 $t2) ~> (equateTp $ctx $t1 $t2) ;
  
  -- Default: neutral comparison
  rule equateCon'Other: (equateCon' $ctx $tp $t1 $t2) ~> (equateNeutral $ctx $t1 $t2) ;

-----------------------------------------------------
-- EquateNeutral
-- Check if two neutral terms are equal
-----------------------------------------------------
piece EquateNeutral
  -- Variables
  rule equateNeutralIx: (equateNeutral $ctx (ix $n) (ix $n)) ~> ok ;
  rule equateNeutralIxNeq: (equateNeutral $ctx (ix $n1) (ix $n2)) ~>
    (fail (concat "variables differ: " $n1 " vs " $n2)) ;
  
  -- Application
  rule equateNeutralApp: (equateNeutral $ctx (app $f1 $a1) (app $f2 $a2)) ~>
    (andThen (equateNeutral $ctx $f1 $f2)
      (fun _ => (equateNeutral $ctx $a1 $a2))) ;
  
  -- Path application
  rule equateNeutralPapp: (equateNeutral $ctx (papp $p1 $r1) (papp $p2 $r2)) ~>
    (andThen (equateNeutral $ctx $p1 $p2)
      (fun _ => (equateDim $ctx $r1 $r2))) ;
  
  -- Projections
  rule equateNeutralFst: (equateNeutral $ctx (fst $p1) (fst $p2)) ~>
    (equateNeutral $ctx $p1 $p2) ;
  rule equateNeutralSnd: (equateNeutral $ctx (snd $p1) (snd $p2)) ~>
    (equateNeutral $ctx $p1 $p2) ;
  
  -- Coe
  rule equateNeutralCoe: (equateNeutral $ctx (coe $a1 $r1 $s1 $t1) (coe $a2 $r2 $s2 $t2)) ~>
    (andThen (equateNeutral $ctx $a1 $a2)
      (fun _ => (andThen (equateDim $ctx $r1 $r2)
        (fun _ => (andThen (equateDim $ctx $s1 $s2)
          (fun _ => (equateNeutral $ctx $t1 $t2))))))) ;
  
  -- HCom
  rule equateNeutralHCom: (equateNeutral $ctx (hcom $a1 $r1 $s1 $Ï†1 $u1) (hcom $a2 $r2 $s2 $Ï†2 $u2)) ~>
    (andThen (equateNeutral $ctx $a1 $a2)
      (fun _ => (andThen (equateDim $ctx $r1 $r2)
        (fun _ => (andThen (equateDim $ctx $s1 $s2)
          (fun _ => (andThen (equateCof $ctx $Ï†1 $Ï†2)
            (fun _ => (equateNeutral $ctx $u1 $u2))))))))) ;
  
  -- Literals
  rule equateNeutralLit: (equateNeutral $ctx (lit $s) (lit $s)) ~> ok ;
  rule equateNeutralLitNeq: (equateNeutral $ctx (lit $s1) (lit $s2)) ~>
    (fail (concat "literals differ: " $s1 " vs " $s2)) ;
  
  -- Default: not equal
  rule equateNeutralOther: (equateNeutral $ctx $t1 $t2) ~>
    (fail (concat "neutral terms not equal: " $t1 " vs " $t2)) ;

-----------------------------------------------------
-- TopLevel
-- Top-level conversion functions
-----------------------------------------------------
piece TopLevel
  rule checkTpEq: (checkTpEq $tp1 $tp2) ~> (equateTp convCtxEmpty $tp1 $tp2) ;
  rule checkEq: (checkEq $tp $t1 $t2) ~> (equateCon convCtxEmpty $tp $t1 $t2) ;
  rule checkSubtype: (checkSubtype $tp1 $tp2) ~> (equateTp convCtxEmpty $tp1 $tp2) ;

-----------------------------------------------------
-- Helpers
-- Helper functions for integration
-----------------------------------------------------
piece Helpers
  rule convResultToBool: (toBool ok) ~> true ;
  rule convResultToBoolFail: (toBool (fail $msg)) ~> false ;
  rule convResultToBoolBlocked: (toBool (blocked $n)) ~> false ;
  
  rule equal: (equal $tp $t1 $t2) ~> (toBool (checkEq $tp $t1 $t2)) ;
  rule equalTp: (equalTp $tp1 $tp2) ~> (toBool (checkTpEq $tp1 $tp2)) ;



-----------------------------------------------------
-- Derived Operations
-----------------------------------------------------

derive subst for term ;
derive normalize for term with fuel = 100 ;
derive conv for term ;

