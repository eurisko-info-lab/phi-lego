-----------------------------------------------------
-- Cofibration.lego: Cofibration algebra and theory
--
-- Mathematical Structure:
-- - Cofibrations: decidable propositions on the interval
-- - Lattice structure: meet (∧), join (∨), top (⊤), bot (⊥)
-- - Dimension equality: r = s as cofibration
-- - Boundary: ∂r = (r = 0) ∨ (r = 1)
-- - Restriction: working under a cofibration assumption
--
-- Algebra:
-- - Distributive lattice with top (⊤) and bottom (⊥)
-- - cof_and and cof_or distribute over each other
-- - cof_eq is symmetric and satisfies interval axioms
-----------------------------------------------------

import Core ;

lang Cofibration (Core) :=

-----------------------------------------------------
-- DimOps
-- Dimension expression operations
-----------------------------------------------------
piece DimOps
  -- Check if dimension is constant 0
  rule isDim0_0: (isDim0 dim0) ~> true ;
  rule isDim0_1: (isDim0 dim1) ~> false ;
  rule isDim0_var: (isDim0 (dimVar $n)) ~> false ;
  
  -- Check if dimension is constant 1
  rule isDim1_0: (isDim1 dim0) ~> false ;
  rule isDim1_1: (isDim1 dim1) ~> true ;
  rule isDim1_var: (isDim1 (dimVar $n)) ~> false ;
  
  -- Syntactic equality
  rule dimEq00: (dimEq dim0 dim0) ~> true ;
  rule dimEq11: (dimEq dim1 dim1) ~> true ;
  rule dimEqVar: (dimEq (dimVar $n) (dimVar $m)) ~> (eq $n $m) ;
  rule dimEqMixed: (dimEq $r $s) ~> false when (neq $r $s) ;
  
  test "dim0-check": (isDim0 dim0) ~~> true ;
  test "dim1-check": (isDim1 dim1) ~~> true ;
  test "dimEq-same": (dimEq dim0 dim0) ~~> true ;

-----------------------------------------------------
-- CofConstructors
-- Smart constructors for cofibrations
-----------------------------------------------------
piece CofConstructors
  -- Top cofibration (always true)
  rule top: top ~> cof_top ;
  
  -- Bottom cofibration (always false)
  rule bot: bot ~> cof_bot ;
  
  -- Dimension equality with optimization
  rule eqSame: (cofEq $r $r) ~> cof_top ;
  rule eq01: (cofEq dim0 dim1) ~> cof_bot ;
  rule eq10: (cofEq dim1 dim0) ~> cof_bot ;
  rule eqGen: (cofEq $r $s) ~> (cof_eq $r $s) when (neq $r $s) ;
  
  -- Less-than-or-equal: r ≤ s = (r = 0) ∨ (s = 1)
  rule le: (cofLe $r $s) ~> (cof_or (cof_eq $r dim0) (cof_eq $s dim1)) ;
  
  -- Boundary: ∂r = (r = 0) ∨ (r = 1)
  rule boundary: (boundary $r) ~> (cof_or (cof_eq $r dim0) (cof_eq $r dim1)) ;
  
  test "eq-refl": (cofEq dim0 dim0) ~~> cof_top ;
  test "eq-diff": (cofEq dim0 dim1) ~~> cof_bot ;
  test "boundary-var": (boundary (dimVar 0)) ~~> (cof_or (cof_eq (dimVar 0) dim0) (cof_eq (dimVar 0) dim1)) ;

-----------------------------------------------------
-- Meet
-- Conjunction: φ ∧ ψ
-----------------------------------------------------
piece Meet
  -- Identity: ⊤ ∧ φ = φ
  rule meetTopL: (cof_and cof_top $φ) ~> $φ ;
  rule meetTopR: (cof_and $φ cof_top) ~> $φ ;
  
  -- Annihilator: ⊥ ∧ φ = ⊥
  rule meetBotL: (cof_and cof_bot $φ) ~> cof_bot ;
  rule meetBotR: (cof_and $φ cof_bot) ~> cof_bot ;
  
  -- Idempotent: φ ∧ φ = φ
  rule meetIdem: (cof_and $φ $φ) ~> $φ ;
  
  type meetType: (cof_and $φ $ψ) : Cof when $φ : Cof, $ψ : Cof ;
  
  test "meet-top": (cof_and cof_top (cof_eq dim0 dim0)) ~~> cof_top ;
  test "meet-bot": (cof_and cof_bot cof_top) ~~> cof_bot ;
  test "meet-idem": (cof_and (cof_eq dim0 dim1) (cof_eq dim0 dim1)) ~~> (cof_eq dim0 dim1) ;

-----------------------------------------------------
-- Join
-- Disjunction: φ ∨ ψ
-----------------------------------------------------
piece Join
  -- Identity: ⊥ ∨ φ = φ
  rule joinBotL: (cof_or cof_bot $φ) ~> $φ ;
  rule joinBotR: (cof_or $φ cof_bot) ~> $φ ;
  
  -- Annihilator: ⊤ ∨ φ = ⊤
  rule joinTopL: (cof_or cof_top $φ) ~> cof_top ;
  rule joinTopR: (cof_or $φ cof_top) ~> cof_top ;
  
  -- Idempotent: φ ∨ φ = φ
  rule joinIdem: (cof_or $φ $φ) ~> $φ ;
  
  type joinType: (cof_or $φ $ψ) : Cof when $φ : Cof, $ψ : Cof ;
  
  test "join-bot": (cof_or cof_bot (cof_eq dim0 dim0)) ~~> cof_top ;
  test "join-top": (cof_or cof_top (cof_eq dim0 dim1)) ~~> cof_top ;
  test "join-idem": (cof_or (cof_eq dim0 dim1) (cof_eq dim0 dim1)) ~~> (cof_eq dim0 dim1) ;

-----------------------------------------------------
-- Normalize
-- Cofibration normalization
-----------------------------------------------------
piece Normalize
  -- Normalize: apply all simplification rules
  rule normTop: (normCof cof_top) ~> cof_top ;
  rule normBot: (normCof cof_bot) ~> cof_bot ;
  rule normEq: (normCof (cof_eq $r $s)) ~> (cofEq $r $s) ;
  rule normAnd: (normCof (cof_and $φ $ψ)) ~> (cof_and (normCof $φ) (normCof $ψ)) ;
  rule normOr: (normCof (cof_or $φ $ψ)) ~> (cof_or (normCof $φ) (normCof $ψ)) ;

-----------------------------------------------------
-- Decide
-- Decidability of cofibrations
-----------------------------------------------------
piece Decide
  -- A cofibration is true under a context
  rule cofTrueTop: (cofTrue cof_top) ~> true ;
  rule cofTrueBot: (cofTrue cof_bot) ~> false ;
  rule cofTrueEq: (cofTrue (cof_eq $r $s)) ~> (dimEq $r $s) ;
  rule cofTrueAnd: (cofTrue (cof_and $φ $ψ)) ~> (and (cofTrue $φ) (cofTrue $ψ)) ;
  rule cofTrueOr: (cofTrue (cof_or $φ $ψ)) ~> (or (cofTrue $φ) (cofTrue $ψ)) ;
  
  -- A cofibration is false
  rule cofFalse: (cofFalse $φ) ~> (not (cofTrue $φ)) ;
  
  test "cof-true-top": (cofTrue cof_top) ~~> true ;
  test "cof-true-bot": (cofTrue cof_bot) ~~> false ;
  test "cof-true-eq": (cofTrue (cof_eq dim0 dim0)) ~~> true ;

-----------------------------------------------------
-- Sequent
-- Sequent testing: φ ⊢ ψ
-----------------------------------------------------
piece Sequent
  -- Under φ, check if ψ holds
  -- φ ⊢ ψ iff (φ → ψ) = ⊤
  rule entails: (entails $φ $ψ) ~> (cofTrue (cof_or (cof_not $φ) $ψ)) ;
  
  -- Negation (for internal use)
  rule notTop: (cof_not cof_top) ~> cof_bot ;
  rule notBot: (cof_not cof_bot) ~> cof_top ;

-----------------------------------------------------
-- DimSubst
-- Dimension substitution in cofibrations
-----------------------------------------------------
piece DimSubst
  -- Substitute dimension r for dimVar n in cofibration
  rule substCofTop: (substCof $n $r cof_top) ~> cof_top ;
  rule substCofBot: (substCof $n $r cof_bot) ~> cof_bot ;
  rule substCofEq: (substCof $n $r (cof_eq $s $t)) ~> (cof_eq (substDimInDim $n $r $s) (substDimInDim $n $r $t)) ;
  rule substCofAnd: (substCof $n $r (cof_and $φ $ψ)) ~> (cof_and (substCof $n $r $φ) (substCof $n $r $ψ)) ;
  rule substCofOr: (substCof $n $r (cof_or $φ $ψ)) ~> (cof_or (substCof $n $r $φ) (substCof $n $r $ψ)) ;
  
  -- Substitute in dimension
  rule substDimVar: (substDimInDim $n $r (dimVar $n)) ~> $r ;
  rule substDimVarOther: (substDimInDim $n $r (dimVar $m)) ~> (dimVar $m) when (neq $n $m) ;
  rule substDim0: (substDimInDim $n $r dim0) ~> dim0 ;
  rule substDim1: (substDimInDim $n $r dim1) ~> dim1 ;

-----------------------------------------------------
-- Forall
-- Universal quantification over dimensions
-----------------------------------------------------
piece Forall
  -- ∀i. φ is true iff φ[0/i] ∧ φ[1/i]
  rule forallCof: (forallDim $i $φ) ~> (cof_and (substCof $i dim0 $φ) (substCof $i dim1 $φ)) ;
  
  -- ∃i. φ is true iff φ[0/i] ∨ φ[1/i]
  rule existsCof: (existsDim $i $φ) ~> (cof_or (substCof $i dim0 $φ) (substCof $i dim1 $φ)) ;



-----------------------------------------------------
-- Derived Operations
-----------------------------------------------------

derive subst for cof ;
derive normalize for cof with fuel = 100 ;
derive cata for cof ;

