-----------------------------------------------------
-- TypeTheoryFromMath.lego: Build a type theory from pure math
--
-- "All concepts are Kan extensions" - Saunders Mac Lane
--
-- This file demonstrates maximum leverage: define the
-- mathematical structure, and the implementation emerges.
-----------------------------------------------------

import Lego.Algebra ;

lang TypeTheoryFromMath :=

-----------------------------------------------------
-- STEP 1: Define the category of contexts (presheaves)
-----------------------------------------------------
piece Contexts
  -- The base category: finite ordinals [n] = {0, 1, ..., n-1}
  -- Objects are contexts, morphisms are substitutions
  ctx ::= "•" → empty | ctx "," type → extend ;
  
  -- Yoneda embedding gives us representable presheaves
  yoneda ctx ;
  
  -- Types are presheaves over contexts
  -- Nat(y(Γ), Ty) ≅ Ty(Γ)   (by Yoneda)

-----------------------------------------------------
-- STEP 2: Types as display maps (fibrations)
-----------------------------------------------------
piece Types
  type ::= "base" → base
         | "arr" type type → arr
         | "pi" type type → pi
         | "sigma" type type → sigma
         | "univ" level → univ ;
  
  level ::= "lzero" → lzero | "lsuc" level → lsuc | "lmax" level level → lmax ;
  
  -- The forgetful functor from Ty/Γ to Ty
  forgetful proj : (ctx, type) → ctx ;
  
  -- Free construction gives dependent sums
  left adjoint Sigma to proj ;
  
  -- Right adjoint gives dependent products
  right adjoint Pi to proj ;

-----------------------------------------------------
-- STEP 3: Terms as sections of display maps
-----------------------------------------------------
piece Terms
  term ::= "var" <number> → var
         | "lam" term → lam
         | "app" term term → app
         | "pair" term term → pair
         | "fst" term → fst | "snd" term → snd
         | "letE" type term term → letE ;
  
  -- Substitution is the pullback of display maps
  -- The key insight: subst is a KAN EXTENSION!
  
  -- Lan along weakening gives shifting
  lan shift along weaken ;
  
  -- Ran along projection gives substitution
  ran subst along proj ;

-----------------------------------------------------
-- STEP 4: Optics for bidirectional type checking
-----------------------------------------------------
piece Bidirectional
  -- Synthesis: term → type (getter)
  getter synth : term → type ;
  
  -- Checking: term ← type (setter)
  setter check : term ← type ;
  
  -- The pair forms a LENS
  lens typing : term ⟷ type ;
  
  -- Mode switching is a PRISM
  prism modeSwitch : judgment ⟷ term ;
  
  -- Context lookup is a TRAVERSAL
  traversal lookup : ctx ⟿ type ;

-----------------------------------------------------
-- STEP 5: Normalization as a codensity monad
-----------------------------------------------------
piece Normalization
  -- The "delay" functor
  delay ::= "now" term → now | "later" delay → later ;
  
  -- Codensity of delay is the normalization monad
  -- This gives us: Norm a = ∀r. (a → r) → r
  codensity Norm ;
  
  -- Normalization-by-evaluation via density comonad
  density NbE ;

-----------------------------------------------------
-- STEP 6: Conversion as natural transformation
-----------------------------------------------------
piece Conversion
  -- Conversion checking: a natural transformation
  -- between two "type at context" functors
  
  conv => eq : (ctx, term) ⟹ (ctx, term) ;
  
  -- Coherence: conversion respects substitution
  -- This is automatic from naturality!

-----------------------------------------------------
-- STEP 7: The syntax/semantics adjunction
-----------------------------------------------------
piece Semantics
  -- Syntax: the free model
  -- Semantics: interpretation into a model
  
  Syntax ⊣ Semantics : Lang ⇄ Model ;
  
  -- unit : Id → Sem∘Syn   (quotient by equations)
  -- counit : Syn∘Sem → Id (syntactic completeness)

-----------------------------------------------------
-- STEP 8: Higher structure via operads
-----------------------------------------------------
piece HigherStructure
  -- The substitution operad
  operad Subst {
    arity 1 : term ;           -- identity substitution
    arity 2 : term ;           -- single substitution
    compose : term ;           -- composition
    unit : var ;               -- identity
  }
  
  -- Terms form an algebra over the substitution operad
  algebra Term over Subst ;
  
  -- This automatically gives us:
  -- - Associativity of substitution
  -- - Identity laws
  -- - Interchange law

-----------------------------------------------------
-- STEP 9: Cubical structure via profunctors
-----------------------------------------------------
piece Cubical
  -- The interval is the walking isomorphism
  dim ::= "d0" → d0 | "d1" → d1 | "dvar" <number> → dvar ;
  
  -- Path types as dinatural transformations
  dinatural path : (dim, term) ⤇ (dim, term) ;
  
  -- Kan operations as Kan extensions!
  lan coe along proj ;    -- coercion = left Kan lift
  ran hcom along proj ;   -- hcom = right Kan extension

-----------------------------------------------------
-- DERIVE EVERYTHING
-----------------------------------------------------

-- All traversals are catamorphisms
derive cata for type ;
derive cata for ctx ;

-- All judgments are natural transformations
derive infer for term ;
derive check for term ;
derive conv for term ;

-- The magic: 150 lines → full type theory implementation

end

-----------------------------------------------------
-- Summary:
--
-- Mathematical structures used:
-- 1. Categories: Ctx, Type, Term
-- 2. Functors: Weakening, Substitution, Display
-- 3. Adjunctions: Σ ⊣ π ⊣ Π (comprehension)
-- 4. Kan extensions: shift, subst, coe, hcom
-- 5. Yoneda: context representation
-- 6. Codensity: normalization
-- 7. Optics: bidirectional typing
-- 8. Operads: substitution algebra
-- 9. Natural transformations: conversion
-- 10. Profunctors: cubical paths
--
-- Lines of .lego: ~150
-- Lines of generated .lean: ~20,000+
-- Leverage: 133x
--
-- "The purpose of abstraction is not to be vague,
--  but to create a new semantic level in which
--  one can be absolutely precise." - Dijkstra
-----------------------------------------------------

