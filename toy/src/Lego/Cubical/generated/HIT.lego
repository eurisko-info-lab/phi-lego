-----------------------------------------------------
-- HIT.lego: Higher Inductive Types
--
-- Mathematical Structure:
-- - HITs are types with point and path constructors
-- - Each HIT has specialized Kan operations
-- - Path constructors create identifications between points
-- - Kan operations must respect boundary conditions
--
-- Supported HITs:
-- - Nat: Natural numbers (actually an inductive, not HIT)
-- - Circle: S¹ with base and loop
-----------------------------------------------------

import Core ;
import Kan ;

lang HIT (Core, Kan) :=

-----------------------------------------------------
-- HITKind
-- Classification of higher inductive types
-----------------------------------------------------
piece HITKind
  hitKind ::= "natHIT" → natHIT
           | "circleHIT" → circleHIT ;
  
  rule hitKindToString: (hitKindToString natHIT) ~> "Nat" ;
  rule hitKindToStringCircle: (hitKindToString circleHIT) ~> "Circle" ;
  
  rule isNatHIT: (isNatHIT natHIT) ~> true ;
  rule isNatHITOther: (isNatHIT $k) ~> false ;
  
  rule isCircleHIT: (isCircleHIT circleHIT) ~> true ;
  rule isCircleHITOther: (isCircleHIT $k) ~> false ;

-----------------------------------------------------
-- NatKan
-- Kan operations for natural numbers
-----------------------------------------------------
piece NatKan
  -- hcom for Nat: computation is strict
  -- hcom Nat r r' φ tubes base computes if base is a numeral
  
  rule hcomNatEq: (hcomNat $r $r $φ $tubes $base) ~> $base ;
  rule hcomNat: (hcomNat $r $r' $φ $tubes $base) ~>
    (hcomNatStep $φ $tubes $base) ;
  
  -- Nat hcom is strict: the cap is returned immediately
  -- (In cubical type theory, Nat is decidable so hcom always computes)
  rule hcomNatStep: (hcomNatStep cof_bot $tubes $base) ~> $base ;
  rule hcomNatStepTrue: (hcomNatStep cof_top $tubes $base) ~>
    (app (app $tubes dim1) (lit "trivial-proof")) ;
  rule hcomNatStepOther: (hcomNatStep $φ $tubes $base) ~> 
    (hcom_nat $φ $tubes $base) ;
  
  -- coe for Nat is identity (Nat is constant family)
  rule coeNat: (coeNat $r $r' (lam nat) $v) ~> $v ;
  rule coeNatSimple: (coeNatSimple $r $r' $v) ~> $v ;

-----------------------------------------------------
-- NatIntro
-- Constructors for natural numbers
-----------------------------------------------------
piece NatIntro
  rule natZero: natZero ~> (intro zero) ;
  rule natSucc: (natSucc $n) ~> (intro (succ $n)) ;
  
  rule isNatIntro: (isNatIntro (intro zero)) ~> true ;
  rule isNatIntroSucc: (isNatIntro (intro (succ $n))) ~> true ;
  rule isNatIntroOther: (isNatIntro $e) ~> false ;
  
  rule natIntroVal: (natIntroVal (intro zero)) ~> zero ;
  rule natIntroValSucc: (natIntroVal (intro (succ $n))) ~> (succ $n) ;

-----------------------------------------------------
-- NatElim
-- Eliminator for natural numbers
-----------------------------------------------------
piece NatElim
  -- natElim : (P : Nat → Type) → P 0 → ((n : Nat) → P n → P (succ n)) → (n : Nat) → P n
  
  rule natElim: (natElim $P $z $s (intro zero)) ~> $z ;
  rule natElimSucc: (natElim $P $z $s (intro (succ $n))) ~>
    (app (app $s $n) (natElim $P $z $s $n)) ;
  rule natElimNeutral: (natElim $P $z $s $n) ~>
    (elim nat $P $z $s $n) ;

-----------------------------------------------------
-- CircleKan  
-- Kan operations for the circle S¹
-----------------------------------------------------
piece CircleKan
  -- hcom for Circle must handle both base and loop
  -- hcom S¹ r r' φ tubes cap
  
  rule hcomCircleEq: (hcomCircle $r $r $φ $tubes $cap) ~> $cap ;
  rule hcomCircle: (hcomCircle $r $r' $φ $tubes $cap) ~>
    (hcomCircleBody $r $r' $φ $tubes $cap) ;
  
  -- Body of circle hcom: distinguish base vs loop
  rule hcomCircleBody: (hcomCircleBody $r $r' $φ $tubes (intro base)) ~>
    (intro base) ;
  
  -- For loop: we need to compute the winding number
  rule hcomCircleBodyLoop: (hcomCircleBody $r $r' $φ $tubes (intro (loop $i))) ~>
    (hcom_circle $r $r' $φ $tubes (intro (loop $i))) ;
  
  rule hcomCircleBodyOther: (hcomCircleBody $r $r' $φ $tubes $cap) ~>
    (hcom_circle $r $r' $φ $tubes $cap) ;
  
  -- coe for Circle is identity (Circle is constant family)
  rule coeCircle: (coeCircle $r $r' (lam S1) $v) ~> $v ;
  rule coeCircleSimple: (coeCircleSimple $r $r' $v) ~> $v ;

-----------------------------------------------------
-- CircleIntro
-- Constructors for the circle
-----------------------------------------------------
piece CircleIntro
  rule circleBase: circleBase ~> (intro base) ;
  rule circleLoop: (circleLoop $i) ~> (intro (loop $i)) ;
  
  rule isCircleIntro: (isCircleIntro (intro base)) ~> true ;
  rule isCircleIntroLoop: (isCircleIntro (intro (loop $i))) ~> true ;
  rule isCircleIntroOther: (isCircleIntro $e) ~> false ;
  
  rule circleIntroKind: (circleIntroKind (intro base)) ~> base ;
  rule circleIntroKindLoop: (circleIntroKind (intro (loop $i))) ~> loop ;

-----------------------------------------------------
-- CircleElim
-- Eliminator for the circle
-----------------------------------------------------
piece CircleElim
  -- circleElim : (P : S¹ → Type) → (b : P base) → PathP (i ↦ P (loop i)) b b → (x : S¹) → P x
  
  rule circleElim: (circleElim $P $b $l (intro base)) ~> $b ;
  rule circleElimLoop: (circleElim $P $b $l (intro (loop $i))) ~>
    (papp $l $i) ;
  rule circleElimNeutral: (circleElim $P $b $l $x) ~>
    (elim circle $P $b $l $x) ;

-----------------------------------------------------
-- LoopSpace
-- Loop space operations for circles
-----------------------------------------------------
piece LoopSpace
  -- refl : base = base
  rule loopRefl: loopRefl ~> (plam (lit "_") (intro base)) ;
  
  -- loop itself as a path
  rule loopPath: loopPath ~> (plam (lit "i") (intro (loop (ix 0)))) ;
  
  -- loop concatenation
  rule loopConcat: (loopConcat $p $q) ~>
    (plam (lit "i") 
      (hcom S1 dim0 dim1 
        (cof_disj (cof_eq (ix 0) dim0) (cof_eq (ix 0) dim1))
        (lam (lam 
          (cofSplit (ix 1)
            (cof_eq (ix 1) dim0) (papp (shift 0 2 $p) (ix 0))
            (cof_eq (ix 1) dim1) (papp (shift 0 2 $q) (ix 0)))))
        (intro base))) ;
  
  -- loop inverse
  rule loopInverse: (loopInverse $p) ~>
    (plam (lit "i") (papp $p (dim_neg (ix 0)))) ;

-----------------------------------------------------
-- HITDispatch
-- Dispatch Kan operations to appropriate HIT handlers
-----------------------------------------------------
piece HITDispatch
  rule hitHcom: (hitHcom natHIT $r $r' $φ $tubes $cap) ~>
    (hcomNat $r $r' $φ $tubes $cap) ;
  rule hitHcomCircle: (hitHcom circleHIT $r $r' $φ $tubes $cap) ~>
    (hcomCircle $r $r' $φ $tubes $cap) ;
  
  rule hitCoe: (hitCoe natHIT $r $r' $line $v) ~>
    (coeNatSimple $r $r' $v) ;
  rule hitCoeCircle: (hitCoe circleHIT $r $r' $line $v) ~>
    (coeCircleSimple $r $r' $v) ;

-----------------------------------------------------
-- HITBoundary
-- Boundary conditions for HIT path constructors
-----------------------------------------------------
piece HITBoundary
  -- Check that loop has correct boundary
  rule loopBoundary0: (loopBoundary (intro (loop dim0))) ~> (intro base) ;
  rule loopBoundary1: (loopBoundary (intro (loop dim1))) ~> (intro base) ;
  rule loopBoundaryOk: (checkLoopBoundary (intro base) (intro base)) ~> true ;
  
  -- For general HITs, boundary checking would be more complex
  -- Nat has no path constructors
  rule hitCheckBoundaryNat: (hitCheckBoundary natHIT $ctor $bounds) ~> true ;
  rule hitCheckBoundaryCircle: (hitCheckBoundary circleHIT $ctor $bounds) ~>
    (checkCircleBoundary $ctor $bounds) ;
  
  rule checkCircleBoundary: (checkCircleBoundary base $bounds) ~> true ;
  rule checkCircleBoundaryLoop: (checkCircleBoundary (loop $i) $bounds) ~>
    (and (eq (subst 0 dim0 $bounds) (intro base))
         (eq (subst 0 dim1 $bounds) (intro base))) ;

-----------------------------------------------------
-- HITQuote
-- Quote HIT terms back to surface syntax
-----------------------------------------------------
piece HITQuote
  rule quoteNat: (quoteHIT natHIT (intro zero)) ~> (surface zero) ;
  rule quoteNatSucc: (quoteHIT natHIT (intro (succ $n))) ~>
    (surface (succ (quoteHIT natHIT $n))) ;
  
  rule quoteCircle: (quoteHIT circleHIT (intro base)) ~> (surface base) ;
  rule quoteCircleLoop: (quoteHIT circleHIT (intro (loop $i))) ~>
    (surface (loop (quoteDim $i))) ;

-----------------------------------------------------
-- HITNormalize
-- Normalize HIT values
-----------------------------------------------------
piece HITNormalize
  rule normalizeNat: (normalizeHIT natHIT (intro zero)) ~> (intro zero) ;
  rule normalizeNatSucc: (normalizeHIT natHIT (intro (succ $n))) ~>
    (intro (succ (normalizeHIT natHIT $n))) ;
  
  rule normalizeCircle: (normalizeHIT circleHIT (intro base)) ~> (intro base) ;
  rule normalizeCircleLoop: (normalizeHIT circleHIT (intro (loop $i))) ~>
    (intro (loop (normalizeDim $i))) ;
  
  rule normalizeCircleLoop0: (normalizeHIT circleHIT (intro (loop dim0))) ~> (intro base) ;
  rule normalizeCircleLoop1: (normalizeHIT circleHIT (intro (loop dim1))) ~> (intro base) ;


-----------------------------------------------------
-- Derived Operations
-----------------------------------------------------

derive subst for term ;
derive normalize for term with fuel = 100 ;

