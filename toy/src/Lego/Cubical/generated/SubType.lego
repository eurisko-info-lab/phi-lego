-----------------------------------------------------
-- SubType.lego: Cubical Sub-types (Restriction Types)
--
-- Mathematical Structure:
-- Sub A Ï† t : Type
-- Elements of sub A Ï† t are elements of A that equal t when Ï† holds.
--
-- Sub A Ï† t â‰… { x : A | Ï† â†’ x = t }
--
-- Key rules:
--   sub-formation: A : Type, Ï† : Cof, t : [Ï†] â†’ A âŠ¢ sub A Ï† t : Type
--   sub-intro:     e : A, [Ï† âŠ¢ e = t] âŠ¢ subIn e : sub A Ï† t
--   sub-elim:      e : sub A Ï† t âŠ¢ subOut e : A
--   sub-Î²:         subOut (subIn e) â‰¡ e
--   sub-Î·:         e : sub A Ï† t âŠ¢ subIn (subOut e) â‰¡ e
-----------------------------------------------------

import Core ;

lang SubType (Core) :=

-----------------------------------------------------
-- SubInfo
-- Information extracted from a sub type
-----------------------------------------------------
piece SubInfo
  subInfo ::= "subInfo" "base:" <expr> "cof:" <expr> "bdry:" <expr> â†’ subInfo ;
  
  rule subInfoBase: (subInfoBase (subInfo base: $b cof: $c bdry: $d)) ~> $b ;
  rule subInfoCof: (subInfoCof (subInfo base: $b cof: $c bdry: $d)) ~> $c ;
  rule subInfoBdry: (subInfoBdry (subInfo base: $b cof: $c bdry: $d)) ~> $d ;
  
  rule subInfoFromExpr: (subInfoFromExpr (sub $ty $cof $bdry)) ~>
    (some (subInfo base: $ty cof: $cof bdry: $bdry)) ;
  rule subInfoFromExprOther: (subInfoFromExpr $e) ~> none ;
  
  rule subInfoToExpr: (subInfoToExpr (subInfo base: $b cof: $c bdry: $d)) ~>
    (sub $b $c $d) ;
  
  rule subInfoIsTrivial: (subInfoIsTrivial (subInfo base: $b cof: cof_top bdry: $d)) ~> true ;
  rule subInfoIsTrivialOther: (subInfoIsTrivial $info) ~> false ;
  
  rule subInfoIsImpossible: (subInfoIsImpossible (subInfo base: $b cof: cof_bot bdry: $d)) ~> true ;
  rule subInfoIsImpossibleOther: (subInfoIsImpossible $info) ~> false ;
  
  rule subInfoGetBase: (subInfoGetBase $info) ~> (subInfoBase $info) ;
  
  rule subInfoEvalBoundary: (subInfoEvalBoundary (subInfo base: $b cof: $c bdry: $d) $prf) ~>
    (subst 0 $prf $d) ;

-----------------------------------------------------
-- MkSub
-- Smart constructor for sub types
-----------------------------------------------------
piece MkSub
  rule mkSub: (mkSub $baseType $cof $boundary) ~> (sub $baseType $cof $boundary) ;
  
  -- Simplification: sub A âŠ¤ t â‰¡ A when boundary is trivial
  rule mkSubTrivial: (mkSubTrivial $baseType (lam (ix 0))) ~> $baseType ;
  rule mkSubTrivialOther: (mkSubTrivial $baseType $boundary) ~>
    (sub $baseType cof_top $boundary) ;

-----------------------------------------------------
-- MkSubIn
-- Smart constructor for subIn
-----------------------------------------------------
piece MkSubIn
  rule mkSubIn: (mkSubIn $e) ~> (subIn $e) ;
  
  -- Î·-expansion check: subIn (subOut e) â†’ e if we know e : sub A Ï† t
  -- This is tricky to check without type info, so we keep it simple
  rule mkSubInOut: (mkSubInOut (subOut $e)) ~> $e ;
  rule mkSubInOutOther: (mkSubInOutOther $e) ~> (subIn $e) ;

-----------------------------------------------------
-- MkSubOut
-- Smart constructor for subOut with Î²-reduction
-----------------------------------------------------
piece MkSubOut
  -- Î²-rule: subOut (subIn e) â†’ e
  rule mkSubOut: (mkSubOut (subIn $inner)) ~> $inner ;
  rule mkSubOutOther: (mkSubOut $e) ~> (subOut $e) ;

-----------------------------------------------------
-- ReduceSub
-- Reduction rules for sub type expressions
-----------------------------------------------------
piece ReduceSub
  -- Î²-reduction: subOut (subIn e) â†’ e
  rule reduceSubOut: (reduceSubOut (subOut (subIn $e))) ~> (some $e) ;
  rule reduceSubOutOther: (reduceSubOut $e) ~> none ;
  
  rule reduceSubExpr: (reduceSubExpr (subOut $e)) ~>
    (case $e
      (subIn $inner) => (some $inner)
      _ => none) ;
  rule reduceSubExprOther: (reduceSubExpr $e) ~> none ;

-----------------------------------------------------
-- NormalizeSub
-- Normalize sub type expressions
-----------------------------------------------------
piece NormalizeSub
  rule normalizeSub: (normalizeSub 0 $e) ~> $e ;
  rule normalizeSubStep: (normalizeSub (succ $fuel) $e) ~>
    (case (reduceSubExpr $e)
      (some $e') => (normalizeSub $fuel $e')
      none => (normalizeSubRec $fuel $e)) ;
  
  rule normalizeSubRec: (normalizeSubRec $fuel (sub $ty $cof $bdry)) ~>
    (sub (normalizeSub $fuel $ty) (normalizeSub $fuel $cof) (normalizeSub $fuel $bdry)) ;
  rule normalizeSubRecIn: (normalizeSubRec $fuel (subIn $inner)) ~>
    (subIn (normalizeSub $fuel $inner)) ;
  rule normalizeSubRecOut: (normalizeSubRec $fuel (subOut $inner)) ~>
    (let $inner' = (normalizeSub $fuel $inner)
     in (case $inner'
           (subIn $x) => $x
           _ => (subOut $inner'))) ;
  rule normalizeSubRecOther: (normalizeSubRec $fuel $e) ~> $e ;

-----------------------------------------------------
-- TrivialSub
-- A trivial sub type (with âŠ¤ cofibration)
-----------------------------------------------------
piece TrivialSub
  rule trivialSubEquiv: (trivialSubEquiv $ty) ~>
    (mkSub $ty cof_top (lam (ix 0))) ;

-----------------------------------------------------
-- ImpossibleSub
-- An impossible sub type (with âŠ¥ cofibration)
-----------------------------------------------------
piece ImpossibleSub
  rule impossibleSub: (impossibleSub $ty) ~>
    (mkSub $ty cof_bot (lam (lit "âŠ¥-elim"))) ;

-----------------------------------------------------
-- SubTypeEquiv
-- Check if two sub types are equivalent
-----------------------------------------------------
piece SubTypeEquiv
  rule subTypeEquiv: (subTypeEquiv $s1 $s2) ~>
    (and (conv (subInfoBase $s1) (subInfoBase $s2))
         (and (conv (subInfoCof $s1) (subInfoCof $s2))
              (conv (subInfoBdry $s1) (subInfoBdry $s2)))) ;

-----------------------------------------------------
-- SubKan
-- Kan operations for sub types
-----------------------------------------------------
piece SubKan
  -- coe for sub types
  -- coe r r' (i â†¦ sub A[i] Ï†[i] t[i]) (subIn v) = subIn (coe r r' A v)
  rule coeSub: (coeSub $r $r' (lam (sub $A $Ï† $t)) (subIn $v)) ~>
    (subIn (coe $r $r' (lam $A) $v)) ;
  
  rule coeSubStuck: (coeSub $r $r' $line $v) ~>
    (coe $r $r' $line $v) ;
  
  -- hcom for sub types
  -- hcom (sub A Ï† t) r r' Ïˆ tubes (subIn cap) = subIn (hcom A r r' Ïˆ (map subOut tubes) cap)
  rule hcomSub: (hcomSub (sub $A $Ï† $t) $r $r' $Ïˆ $tubes (subIn $cap)) ~>
    (subIn (hcom $A $r $r' $Ïˆ (mapSubOut $tubes) $cap)) ;
  
  rule hcomSubStuck: (hcomSub $subTy $r $r' $Ïˆ $tubes $cap) ~>
    (hcom $subTy $r $r' $Ïˆ $tubes $cap) ;
  
  rule mapSubOut: (mapSubOut (lam (lam $body))) ~>
    (lam (lam (subOut $body))) ;

-----------------------------------------------------
-- SubBoundaryCheck
-- Check that a term satisfies the boundary constraint
-----------------------------------------------------
piece SubBoundaryCheck
  -- Given e : A and sub A Ï† t, check that [Ï† âŠ¢ e = t]
  rule checkSubBoundary: (checkSubBoundary $e (subInfo base: $A cof: $Ï† bdry: $t)) ~>
    (case $Ï†
      cof_bot => true  -- Vacuously true
      cof_top => (conv $e (subst 0 (lit "trivial") $t))  -- Must equal t
      _ => (checkSubBoundaryGeneral $e $Ï† $t)) ;
  
  rule checkSubBoundaryGeneral: (checkSubBoundaryGeneral $e $Ï† $t) ~>
    true ;  -- In general, need semantic equality under Ï†

-----------------------------------------------------
-- SubPartial
-- Connection between sub types and partial elements
-----------------------------------------------------
piece SubPartial
  -- A partial element of type A under Ï† is a term t such that [Ï† âŠ¢ t : A]
  -- This can be encoded as a function Cof.true Ï† â†’ A
  
  rule partialToSub: (partialToSub $A $Ï† $partial) ~>
    (sub $A $Ï† $partial) ;
  
  -- Extract partial element from sub type (the boundary)
  rule subToPartial: (subToPartial (sub $A $Ï† $bdry)) ~> $bdry ;

-----------------------------------------------------
-- ExtIntegration
-- Connection with extension types
-----------------------------------------------------
piece ExtIntegration
  -- ext 1 (Î»i. A) Ï† bdry â‰… (i : ð•€) â†’ sub A[i] (Ï†[i]) (bdry[i])
  -- This isomorphism is key for boundary checking
  
  rule extAsSub: (extAsSub $dim $A $Ï† $bdry) ~>
    (pi $dim (sub (app (shift 0 1 $A) (ix 0)) 
                  (app (shift 0 1 $Ï†) (ix 0)) 
                  (app (shift 0 1 $bdry) (ix 0)))) ;


-----------------------------------------------------
-- Derived Operations
-----------------------------------------------------

derive subst for term ;
derive normalize for term with fuel = 100 ;

