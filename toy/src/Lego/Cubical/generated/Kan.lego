-----------------------------------------------------
-- Kan.lego: Kan Operations for Cubical Type Theory
--
-- Implements the key transport operations:
-- - Coercion (coe): transport along a path in the universe
-- - Homogeneous Composition (hcom): fill a cube with compatible boundaries
-- - Heterogeneous Composition (com): combine coe + hcom for dependent types
--
-- Mathematical structure:
-- - These operations witness that types form a Kan complex
-- - coe: functorial action of paths on elements
-- - hcom: existence of fillers for open boxes
-- - com: composition in dependent types via pullback
-----------------------------------------------------

import Core ;
import Cofibration ;

lang Kan (Core, Cofibration) :=

-----------------------------------------------------
-- Dir
-- Direction: pair of dimensions for coercion/composition
-----------------------------------------------------
piece Dir
  dir ::= "dir" dim dim → dir ;
  
  -- Check if direction is degenerate (src = tgt)
  rule isDegenerate: (dirIsDegenerate (dir $src $tgt)) ~> (dimEqD $src $tgt) ;
  
  -- Create direction from expressions
  rule dirOfExpr: (dirOfExpr $r $r') ~> (dir (dimOfExprForce $r) (dimOfExprForce $r')) ;
  
  test "dir-degen": (dirIsDegenerate (dir ddim0 ddim0)) ~~> true ;
  test "dir-non-degen": (dirIsDegenerate (dir ddim0 ddim1)) ~~> false ;

-----------------------------------------------------
-- EvalCof
-- Evaluate cofibration to boolean given dimension substitution
-----------------------------------------------------
piece EvalCof
  rule evalCofTop: (evalCof $subst cof_top) ~> true ;
  rule evalCofBot: (evalCof $subst cof_bot) ~> false ;
  rule evalCofEq: (evalCof $subst (cof_eq $r $s)) ~> (dimEqSubst $subst $r $s) ;
  rule evalCofAnd: (evalCof $subst (cof_and $φ $ψ)) ~> (and (evalCof $subst $φ) (evalCof $subst $ψ)) ;
  rule evalCofOr: (evalCof $subst (cof_or $φ $ψ)) ~> (or (evalCof $subst $φ) (evalCof $subst $ψ)) ;

-----------------------------------------------------
-- SubstDim0
-- Substitute a dimension expression for dimVar 0
-----------------------------------------------------
piece SubstDim0
  rule substDim0Ix: (substDim0' $d (ix $n)) ~> (ix $n) ;
  rule substDim0Dim0: (substDim0' $d dim0) ~> dim0 ;
  rule substDim0Dim1: (substDim0' $d dim1) ~> dim1 ;
  rule substDim0DimVar0: (substDim0' $d (dimVar 0)) ~> $d ;
  rule substDim0DimVarS: (substDim0' $d (dimVar (suc $n))) ~> (dimVar $n) ;
  rule substDim0Lam: (substDim0' $d (lam $body)) ~> (lam (substDim0' $d $body)) ;
  rule substDim0Plam: (substDim0' $d (plam $body)) ~> (plam (substDim0' (shift 0 1 $d) $body)) ;
  rule substDim0App: (substDim0' $d (app $f $a)) ~> (app (substDim0' $d $f) (substDim0' $d $a)) ;
  rule substDim0Pi: (substDim0' $d (pi $A $B)) ~> (pi (substDim0' $d $A) (substDim0' $d $B)) ;

-----------------------------------------------------
-- Coe
-- Coercion: coe r r' (λi.A[i]) a : A[r'/i]
--
-- Transport an element a : A[r/i] to A[r'/i] along the line of types.
--
-- Key computation rules:
-- 1. coe r r A a = a (when r = r', identity)
-- 2. coe r r' (λi.Type) a = a (universe is constant)
-- 3. coe r r' (λi.Π(x:A[i]).B[i,x]) f = λx. coe r r' ... (f ...)
-- 4. coe r r' (λi.Σ(x:A[i]).B[i,x]) (a,b) = (coe r r' A a, coe r r' ... b)
-----------------------------------------------------
piece Coe
  -- Rule 1: degenerate direction
  rule coeRefl: (coe $r $r $ty $a) ~> $a ;
  
  -- Rule 2: universe is stable under coercion
  rule coeUniv: (coe $r $r' (plam (univ $l)) $a) ~> $a ;
  
  -- Rule 3: coercion in Pi type
  rule coePi: (coe $r $r' (plam (pi $dom $cod)) $f) ~>
    (lam (coe $r $r' (plamSubst 0 (coe $r' $r (plamInv $dom) (ix 0)) $cod)
                     (app $f (coe $r' $r $dom (ix 0))))) ;
  
  -- Rule 4: coercion in Sigma type
  rule coeSigma: (coe $r $r' (plam (sigma $dom $cod)) $p) ~>
    (pair (coe $r $r' $dom (fst $p))
          (coe $r $r' (plamSubst 0 (coe $r $r' $dom (fst $p)) $cod) (snd $p))) ;
  
  -- Rule for Path types
  rule coePath: (coe $r $r' (plam (path $A $a $b)) $p) ~>
    (plam (coe $r $r' $A (papp $p (dimVar 0)))) ;
  
  -- Type checking
  type coeType: (coe $r $r' $line $a) : (substDim0' $r' (plamBody $line))
    when $r : I, $r' : I, $line : (PathP _ U (substDim0' $r (plamBody $line)) (substDim0' $r' (plamBody $line))), 
         $a : (substDim0' $r (plamBody $line)) ;
  
  test "coe-refl": (coe dim0 dim0 (plam (univ lzero)) (lit "A")) ~~> (lit "A") ;
  test "coe-univ": (coe dim0 dim1 (plam (univ lzero)) (lit "A")) ~~> (lit "A") ;

-----------------------------------------------------
-- HCom
-- Homogeneous Composition: hcom r r' A φ u a : A
--
-- Key computation rules:
-- 1. hcom r r A φ u a = a (degenerate direction)
-- 2. hcom r r' A ⊤ u a = u r' (when cofibration is true, use tube at endpoint)
-- 3. hcom r r' A ⊥ u a = a (when cofibration is false, return cap)
-----------------------------------------------------
piece HCom
  -- Rule 1: degenerate direction
  rule hcomRefl: (hcom $r $r $ty $phi $cap) ~> $cap ;
  
  -- Rule 2: cofibration true (use tube at endpoint)
  rule hcomTrue: (hcom $r $r' $ty cof_top $tube $cap) ~> (app (app $tube $r') (lit "prf")) ;
  
  -- Rule 3: cofibration false (return cap)
  rule hcomFalse: (hcom $r $r' $ty cof_bot $tube $cap) ~> $cap ;
  
  -- For Pi types: pointwise hcom
  rule hcomPi: (hcom $r $r' (pi $A $B) $phi $tube $cap) ~>
    (lam (hcom $r $r' (substBody 0 (ix 0) $B) $phi
               (lam (lam (app (app (app $tube (ix 1)) (ix 0)) (ix 2))))
               (app $cap (ix 0)))) ;
  
  -- For Sigma types: component-wise hcom
  rule hcomSigma: (hcom $r $r' (sigma $A $B) $phi $tube $cap) ~>
    (pair (hcom $r $r' $A $phi (lam (lam (fst (app (app $tube (ix 1)) (ix 0))))) (fst $cap))
          (com $r $r' (plam (substBody 0 (hcom $r (dimVar 0) $A $phi
                                           (lam (lam (fst (app (app $tube (ix 1)) (ix 0))))) (fst $cap)) $B))
               $phi (lam (lam (snd (app (app $tube (ix 1)) (ix 0))))) (snd $cap))) ;
  
  -- For Path types
  rule hcomPath: (hcom $r $r' (path $A $a $b) $phi $tube $cap) ~>
    (plam (hcom $r $r' $A
                (cof_or $phi (cof_or (cof_eq (dimVar 0) dim0) (cof_eq (dimVar 0) dim1)))
                (mkTube $tube (dimVar 0) $a $b)
                (papp $cap (dimVar 0)))) ;
  
  type hcomType: (hcom $r $r' $A $phi $tube $cap) : $A
    when $r : I, $r' : I, $A : U, $phi : Cof,
         $tube : (Π (i : I) . (Π (_ : [$phi]) . $A)),
         $cap : $A,
         [$phi] $cap = (app (app $tube $r) _) ;
  
  test "hcom-refl": (hcom dim0 dim0 (univ lzero) cof_bot (lit "tube") (lit "cap")) ~~> (lit "cap") ;
  test "hcom-bot": (hcom dim0 dim1 (univ lzero) cof_bot (lit "tube") (lit "cap")) ~~> (lit "cap") ;

-----------------------------------------------------
-- Com
-- Heterogeneous Composition: com r r' (λi.A) φ u a : A[r'/i]
--
-- com = coe + hcom: coerce the cap and system, then compose homogeneously.
-----------------------------------------------------
piece Com
  -- Degenerate direction
  rule comRefl: (com $r $r $line $phi $tube $cap) ~> $cap ;
  
  -- General case: com as coe + hcom
  rule comGen: (com $r $r' $line $phi $tube $cap) ~>
    (hcom $r $r' (substDim0' $r' (plamBody $line)) $phi
          (lam (lam (coe (ix 1) $r' $line (app (app $tube (ix 1)) (ix 0)))))
          (coe $r $r' $line $cap))
    when (neq $r $r') ;
  
  type comType: (com $r $r' $line $phi $tube $cap) : (substDim0' $r' (plamBody $line))
    when $r : I, $r' : I, $line : (PathP _ U _ _), $phi : Cof,
         $tube : (Π (i : I) . (Π (_ : [$phi]) . (substDim0' i (plamBody $line)))),
         $cap : (substDim0' $r (plamBody $line)),
         [$phi] $cap = (app (app $tube $r) _) ;
  
  test "com-refl": (com dim0 dim0 (plam (univ lzero)) cof_bot (lit "tube") (lit "cap")) ~~> (lit "cap") ;

-----------------------------------------------------
-- GHCom
-- Generalized homogeneous composition
-- Used when type doesn't have strict Kan structure
-----------------------------------------------------
piece GHCom
  rule ghcomRefl: (ghcom $r $r $A $sys $cap) ~> $cap ;
  rule ghcomBdy: (ghcom $r $r' $A (sysCons ($phi, $tube) $rest) $cap) ~> (substDim0' $r' $tube)
    when (cofTrue $phi) ;

-----------------------------------------------------
-- GCom
-- Generalized heterogeneous composition
-- ghcom with varying type
-----------------------------------------------------
piece GCom
  rule gcomRefl: (gcom $r $r $line $sys $cap) ~> $cap ;
  rule gcomBdy: (gcom $r $r' $line (sysCons ($phi, $tube) $rest) $cap) ~> (substDim0' $r' $tube)
    when (cofTrue $phi) ;


-----------------------------------------------------
-- Derived Operations
-----------------------------------------------------

derive subst for term ;
derive normalize for term with fuel = 100 ;

