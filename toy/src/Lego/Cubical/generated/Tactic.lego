-----------------------------------------------------
-- Tactic.lego: Bidirectional Type Checking Tactics
--
-- Mathematical Structure:
-- - Bidirectional typing: synthesis (â†‘) and checking (â†“)
-- - Tactics as computations over typing goals
-- - Based on cooltt's Tactic module design
--
-- Key insight from cooltt:
-- "Tactics are monadic computations that produce syntax given
--  typing information. Checking tactics are given a goal type,
--  synthesis tactics return both the term and its type."
-----------------------------------------------------

import Core ;
import Cofibration ;
import Splice ;

lang Tactic (Core, Cofibration, Splice) :=

-----------------------------------------------------
-- TacResult
-- Tactic result type
-----------------------------------------------------
piece TacResult
  tacResult ::= "tacOk" <any> â†’ tacOk
             | "tacError" <name> â†’ tacError ;
  
  rule isTacOk: (isTacOk (tacOk $a)) ~> true ;
  rule isTacOkErr: (isTacOk (tacError $msg)) ~> false ;
  
  rule tacResultMap: (tacResultMap $f (tacOk $a)) ~> (tacOk ($f $a)) ;
  rule tacResultMapErr: (tacResultMap $f (tacError $msg)) ~> (tacError $msg) ;
  
  rule tacResultBind: (tacResultBind (tacOk $a) $f) ~> ($f $a) ;
  rule tacResultBindErr: (tacResultBind (tacError $msg) $f) ~> (tacError $msg) ;
  
  rule tacResultPure: (tacResultPure $a) ~> (tacOk $a) ;
  
  rule tacResultGetOrElse: (tacResultGetOrElse (tacOk $a) $default) ~> $a ;
  rule tacResultGetOrElseErr: (tacResultGetOrElse (tacError $msg) $default) ~> $default ;

-----------------------------------------------------
-- TpCtx
-- Typing context
-----------------------------------------------------
piece TpCtx
  tpCtx ::= "tpCtx" "types:" <expr>* "cofs:" <expr>* â†’ tpCtx ;
  
  rule tpCtxEmpty: tpCtxEmpty ~> (tpCtx types: () cofs: ()) ;
  
  rule tpCtxExtend: (tpCtxExtend (tpCtx types: $ts cofs: $cs) $ty) ~>
    (tpCtx types: ($ty $ts) cofs: $cs) ;
  
  rule tpCtxLookup: (tpCtxLookup (tpCtx types: $ts cofs: $cs) $n) ~>
    (listGet $ts $n) ;
  
  rule tpCtxSize: (tpCtxSize (tpCtx types: $ts cofs: $cs)) ~> (length $ts) ;
  
  rule tpCtxAssume: (tpCtxAssume (tpCtx types: $ts cofs: $cs) $Ï†) ~>
    (tpCtx types: $ts cofs: ($Ï† $cs)) ;
  
  rule tpCtxIsConsistent: (tpCtxIsConsistent (tpCtx types: $ts cofs: $cs)) ~>
    (cofIsConsistent (meetAll $cs)) ;
  
  rule meetAll: (meetAll ()) ~> cof_top ;
  rule meetAllCons: (meetAll ($Ï† $rest)) ~> (cof_and $Ï† (meetAll $rest)) ;

-----------------------------------------------------
-- ChkGoal
-- Checking goal with boundary constraints
-----------------------------------------------------
piece ChkGoal
  chkGoal ::= "chkGoal" "tp:" <expr> "cof:" <expr> "bdry:" <expr> â†’ chkGoal ;
  
  rule chkGoalSimple: (chkGoalSimple $ty) ~>
    (chkGoal tp: $ty cof: cof_top bdry: (lit "unit")) ;
  
  rule chkGoalWithBoundary: (chkGoalWithBoundary $ty $Ï† $bdry) ~>
    (chkGoal tp: $ty cof: $Ï† bdry: $bdry) ;
  
  rule chkGoalTp: (chkGoalTp (chkGoal tp: $t cof: $c bdry: $b)) ~> $t ;
  rule chkGoalCof: (chkGoalCof (chkGoal tp: $t cof: $c bdry: $b)) ~> $c ;
  rule chkGoalBdry: (chkGoalBdry (chkGoal tp: $t cof: $c bdry: $b)) ~> $b ;

-----------------------------------------------------
-- TpTac
-- Type formation tactics
-----------------------------------------------------
piece TpTac
  rule tpTacRun: (tpTacRun $tac $ctx) ~> ($tac $ctx) ;
  rule tpTacPure: (tpTacPure $e $ctx) ~> (tacOk $e) ;
  
  rule tpTacNat: (tpTacNat $ctx) ~> (tacOk nat) ;
  rule tpTacCircle: (tpTacCircle $ctx) ~> (tacOk S1) ;
  rule tpTacUniv: (tpTacUniv $ctx) ~> (tacOk (univ 0)) ;
  rule tpTacDim: (tpTacDim $ctx) ~> (tacOk (lit "ð•€")) ;
  rule tpTacCof: (tpTacCof $ctx) ~> (tacOk (lit "Cof")) ;
  
  rule tpTacPi: (tpTacPi $domTac $codTac $ctx) ~>
    (tacResultBind ($domTac $ctx) (lam
      (let $ctx' = (tpCtxExtend $ctx (ix 0))
       in (tacResultBind ($codTac (ix 0) $ctx') (lam
            (tacOk (pi (ix 1) (ix 0)))))))) ;
  
  rule tpTacSigma: (tpTacSigma $baseTac $famTac $ctx) ~>
    (tacResultBind ($baseTac $ctx) (lam
      (let $ctx' = (tpCtxExtend $ctx (ix 0))
       in (tacResultBind ($famTac (ix 0) $ctx') (lam
            (tacOk (sigma (ix 1) (ix 0)))))))) ;
  
  rule tpTacPath: (tpTacPath $tyLineTac $left $right $ctx) ~>
    (tacResultBind ($tyLineTac $ctx) (lam
      (tacOk (path (ix 0) $left $right)))) ;
  
  rule tpTacSub: (tpTacSub $tyTac $Ï† $tm $ctx) ~>
    (tacResultBind ($tyTac $ctx) (lam
      (tacOk (sub (ix 0) $Ï† $tm)))) ;
  
  rule tpTacMap: (tpTacMap $f $tac $ctx) ~>
    (tacResultMap $f ($tac $ctx)) ;

-----------------------------------------------------
-- ChkTac
-- Checking tactics (introduction rules)
-----------------------------------------------------
piece ChkTac
  rule chkTacRun: (chkTacRun $tac $ctx $tp) ~> ($tac $ctx (chkGoalSimple $tp)) ;
  rule chkTacBRun: (chkTacBRun $tac $ctx $tp $Ï† $bdry) ~> ($tac $ctx (chkGoalWithBoundary $tp $Ï† $bdry)) ;
  rule chkTacPure: (chkTacPure $e $ctx $goal) ~> (tacOk $e) ;
  
  -- Nat introduction
  rule chkTacZero: (chkTacZero $ctx $goal) ~>
    (case (chkGoalTp $goal)
      nat => (tacOk zero)
      _ => (tacError "expected Nat")) ;
  
  rule chkTacSuc: (chkTacSuc $tac $ctx $goal) ~>
    (case (chkGoalTp $goal)
      nat => (tacResultBind ($tac $ctx (chkGoalSimple nat)) (lam
               (tacOk (suc (ix 0)))))
      _ => (tacError "expected Nat")) ;
  
  -- Lambda introduction
  rule chkTacLam: (chkTacLam $bodyTac $ctx $goal) ~>
    (case (chkGoalTp $goal)
      (pi $dom $cod) =>
        (let $ctx' = (tpCtxExtend $ctx $dom)
         in (let $goalCod = (chkGoalSimple $cod)
             in (tacResultBind ($bodyTac (ix 0) $ctx' $goalCod) (lam
                  (tacOk (lam (ix 0)))))))
      _ => (tacError "expected Pi type")) ;
  
  -- Pair introduction
  rule chkTacPair: (chkTacPair $fstTac $sndTac $ctx $goal) ~>
    (case (chkGoalTp $goal)
      (sigma $base $fam) =>
        (tacResultBind ($fstTac $ctx (chkGoalSimple $base)) (lam
          (let $famSubst = (subst 0 (ix 0) $fam)
           in (tacResultBind ($sndTac $ctx (chkGoalSimple $famSubst)) (lam
                (tacOk (pair (ix 1) (ix 0))))))))
      _ => (tacError "expected Sigma type")) ;
  
  -- Path lambda introduction
  rule chkTacPlam: (chkTacPlam $bodyTac $ctx $goal) ~>
    (let $ctx' = (tpCtxExtend $ctx (lit "ð•€"))
     in (tacResultBind ($bodyTac (ix 0) $ctx' (chkGoalSimple (chkGoalTp $goal))) (lam
          (tacOk (plam (ix 0)))))) ;
  
  -- Circle introduction
  rule chkTacBase: (chkTacBase $ctx $goal) ~>
    (case (chkGoalTp $goal)
      S1 => (tacOk base)
      _ => (tacError "expected Circle")) ;
  
  rule chkTacLoop: (chkTacLoop $dimTac $ctx $goal) ~>
    (case (chkGoalTp $goal)
      S1 => (tacResultBind ($dimTac $ctx (chkGoalSimple (lit "ð•€"))) (lam
              (tacOk (loop (ix 0)))))
      _ => (tacError "expected Circle")) ;
  
  -- Sub introduction
  rule chkTacSubIn: (chkTacSubIn $tac $ctx $goal) ~>
    (case (chkGoalTp $goal)
      (sub $a $Ï† $t) =>
        (tacResultBind ($tac $ctx (chkGoalSimple $a)) (lam
          (tacOk (subIn (ix 0)))))
      _ => (tacError "expected Sub type")) ;

-----------------------------------------------------
-- SynTac
-- Synthesis tactics (elimination rules)
-----------------------------------------------------
piece SynTac
  rule synTacRun: (synTacRun $tac $ctx) ~> ($tac $ctx) ;
  rule synTacPure: (synTacPure $e $ty $ctx) ~> (tacOk ($e , $ty)) ;
  
  -- Variable synthesis
  rule synTacVar: (synTacVar $n $ctx) ~>
    (case (tpCtxLookup $ctx $n)
      (some $ty) => (tacOk ((ix $n) , $ty))
      none => (tacError "unbound variable")) ;
  
  -- Application synthesis
  rule synTacApp: (synTacApp $fnTac $argTac $ctx) ~>
    (tacResultBind ($fnTac $ctx) (lam
      (case (snd (ix 0))
        (pi $dom $cod) =>
          (tacResultBind ($argTac $ctx (chkGoalSimple $dom)) (lam
            (let $codSubst = (subst 0 (ix 0) $cod)
             in (tacOk ((app (fst (ix 1)) (ix 0)) , $codSubst)))))
        _ => (tacError "expected function type")))) ;
  
  -- First projection synthesis
  rule synTacFst: (synTacFst $pairTac $ctx) ~>
    (tacResultBind ($pairTac $ctx) (lam
      (case (snd (ix 0))
        (sigma $base $fam) => (tacOk ((fst (fst (ix 0))) , $base))
        _ => (tacError "expected Sigma type")))) ;
  
  -- Second projection synthesis
  rule synTacSnd: (synTacSnd $pairTac $ctx) ~>
    (tacResultBind ($pairTac $ctx) (lam
      (case (snd (ix 0))
        (sigma $base $fam) =>
          (let $fstVal = (fst (fst (ix 0)))
           in (let $famSubst = (subst 0 $fstVal $fam)
               in (tacOk ((snd (fst (ix 0))) , $famSubst))))
        _ => (tacError "expected Sigma type")))) ;
  
  -- Path application synthesis
  rule synTacPApp: (synTacPApp $pathTac $dimTac $ctx) ~>
    (tacResultBind ($pathTac $ctx) (lam
      (tacResultBind ($dimTac $ctx (chkGoalSimple (lit "ð•€"))) (lam
        (tacOk ((papp (fst (ix 1)) (ix 0)) , (lit "path-fiber"))))))) ;
  
  -- SubOut synthesis
  rule synTacSubOut: (synTacSubOut $subTac $ctx) ~>
    (tacResultBind ($subTac $ctx) (lam
      (case (snd (ix 0))
        (sub $a $Ï† $t) => (tacOk ((subOut (fst (ix 0))) , $a))
        _ => (tacError "expected Sub type")))) ;

-----------------------------------------------------
-- VarTac
-- Variable handling tactics
-----------------------------------------------------
piece VarTac
  rule varTacIntro: (varTacIntro $name $ty $k $ctx) ~>
    (let $ctx' = (tpCtxExtend $ctx $ty)
     in ($k (ix 0) $ctx')) ;
  
  rule varTacDim: (varTacDim $name $k $ctx) ~>
    (let $ctx' = (tpCtxExtend $ctx (lit "ð•€"))
     in ($k (ix 0) $ctx')) ;
  
  rule varTacCof: (varTacCof $Ï† $k $ctx) ~>
    (let $ctx' = (tpCtxAssume $ctx $Ï†)
     in ($k $ctx')) ;

-----------------------------------------------------
-- TacHelpers
-- Helper tactics
-----------------------------------------------------
piece TacHelpers
  rule tacSequence: (tacSequence () $ctx $goal) ~> (tacOk ()) ;
  rule tacSequenceCons: (tacSequence ($tac $rest) $ctx $goal) ~>
    (tacResultBind ($tac $ctx $goal) (lam
      (tacResultBind (tacSequence $rest $ctx $goal) (lam
        (tacOk ((ix 1) (ix 0))))))) ;
  
  rule tacChoice: (tacChoice () $ctx $goal) ~> (tacError "no tactics succeeded") ;
  rule tacChoiceCons: (tacChoice ($tac $rest) $ctx $goal) ~>
    (case ($tac $ctx $goal)
      (tacOk $a) => (tacOk $a)
      (tacError $msg) => (tacChoice $rest $ctx $goal)) ;
  
  rule tacWithFreshVar: (tacWithFreshVar $ty $bodyTac $ctx $goal) ~>
    (let $ctx' = (tpCtxExtend $ctx $ty)
     in ($bodyTac (ix 0) $ctx' $goal)) ;
  
  rule tacWithCofAssump: (tacWithCofAssump $Ï† $bodyTac $ctx $goal) ~>
    (let $ctx' = (tpCtxAssume $ctx $Ï†)
     in ($bodyTac $ctx' $goal)) ;


-----------------------------------------------------
-- Derived Operations
-----------------------------------------------------

derive subst for term ;
derive normalize for term with fuel = 100 ;

