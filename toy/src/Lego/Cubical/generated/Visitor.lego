-----------------------------------------------------
-- Visitor.lego: Visitor pattern for Expr traversal
--
-- Design goals:
-- 1. Each Expr constructor encapsulates its own traversal logic
-- 2. Operations (shift, subst, freeIn) are defined generically
-- 3. Adding a new constructor requires only local changes
--
-- Pattern:
-- - ExprF: functor describing Expr's structure (children + reconstruction)
-- - Visitor[Op]: type class for operation-specific behavior
-- - traverse: generic traversal that composes them
-----------------------------------------------------

import Core ;

lang Visitor (Core) :=

-----------------------------------------------------
-- VisitorState
-- State for traversal: current depth
-----------------------------------------------------
piece VisitorState
  vstate ::= "vstate" <number> → vstate ;
  
  rule vstateEmpty: vstateEmpty ~> (vstate 0) ;
  rule vstateDepth: (vstateDepth (vstate $d)) ~> $d ;
  rule vstateIncr: (vstateIncr (vstate $d)) ~> (vstate (suc $d)) ;

-----------------------------------------------------
-- BinderInfo
-- How a child relates to binders
-----------------------------------------------------
piece BinderInfo
  binfo ::= "binfoNone" → binfoNone          -- No binder
          | "binfoTerm" <number> → binfoTerm -- Goes under n term binders
          | "binfoDim" <number> → binfoDim   -- Goes under n dim binders
          ;

-----------------------------------------------------
-- Child
-- A child with its binding context
-----------------------------------------------------
piece Child
  child ::= "child" term binfo → child ;
  
  rule childExpr: (childExpr (child $e $bi)) ~> $e ;
  rule childBinder: (childBinder (child $e $bi)) ~> $bi ;

-----------------------------------------------------
-- ExprShape
-- Children paired with reconstruction function
-----------------------------------------------------
piece ExprShape
  shape ::= "shape" children <ident> → shape ;
  children ::= child* → children ;

-----------------------------------------------------
-- Shape
-- Extract shape from an expression
-----------------------------------------------------
piece Shape
  -- Atomic (no children)
  rule shapeIx: (exprShape (ix $n)) ~> (shape () "ix") ;
  rule shapeLit: (exprShape (lit $s)) ~> (shape () "lit") ;
  rule shapeDim0: (exprShape dim0) ~> (shape () "dim0") ;
  rule shapeDim1: (exprShape dim1) ~> (shape () "dim1") ;
  rule shapeDimVar: (exprShape (dimVar $n)) ~> (shape () "dimVar") ;
  rule shapeCofTop: (exprShape cof_top) ~> (shape () "cof_top") ;
  rule shapeCofBot: (exprShape cof_bot) ~> (shape () "cof_bot") ;
  rule shapeNat: (exprShape nat) ~> (shape () "nat") ;
  rule shapeZero: (exprShape zero) ~> (shape () "zero") ;
  rule shapeCircle: (exprShape circle) ~> (shape () "circle") ;
  rule shapeBase: (exprShape base) ~> (shape () "base") ;
  rule shapeUniv: (exprShape (univ $l)) ~> (shape () "univ") ;
  
  -- Single child, no binder
  rule shapeFst: (exprShape (fst $e)) ~> (shape ((child $e binfoNone)) "fst") ;
  rule shapeSnd: (exprShape (snd $e)) ~> (shape ((child $e binfoNone)) "snd") ;
  rule shapeSuc: (exprShape (suc $e)) ~> (shape ((child $e binfoNone)) "suc") ;
  rule shapeRefl: (exprShape (refl $e)) ~> (shape ((child $e binfoNone)) "refl") ;
  rule shapeLoop: (exprShape (loop $r)) ~> (shape ((child $r binfoNone)) "loop") ;
  rule shapeSubIn: (exprShape (subIn $e)) ~> (shape ((child $e binfoNone)) "subIn") ;
  rule shapeSubOut: (exprShape (subOut $e)) ~> (shape ((child $e binfoNone)) "subOut") ;
  
  -- Single child, binds 1 term var
  rule shapeLam: (exprShape (lam $body)) ~> (shape ((child $body (binfoTerm 1))) "lam") ;
  
  -- Single child, binds 1 dim var
  rule shapePlam: (exprShape (plam $body)) ~> (shape ((child $body (binfoDim 1))) "plam") ;
  
  -- Two children, no binders
  rule shapeApp: (exprShape (app $f $a)) ~>
    (shape ((child $f binfoNone) (child $a binfoNone)) "app") ;
  rule shapePair: (exprShape (pair $a $b)) ~>
    (shape ((child $a binfoNone) (child $b binfoNone)) "pair") ;
  rule shapePapp: (exprShape (papp $p $r)) ~>
    (shape ((child $p binfoNone) (child $r binfoNone)) "papp") ;
  rule shapeCofEq: (exprShape (cof_eq $r $s)) ~>
    (shape ((child $r binfoNone) (child $s binfoNone)) "cof_eq") ;
  rule shapeCofAnd: (exprShape (cof_and $φ $ψ)) ~>
    (shape ((child $φ binfoNone) (child $ψ binfoNone)) "cof_and") ;
  rule shapeCofOr: (exprShape (cof_or $φ $ψ)) ~>
    (shape ((child $φ binfoNone) (child $ψ binfoNone)) "cof_or") ;
  
  -- Two children, second binds 1 term var
  rule shapePi: (exprShape (pi $dom $cod)) ~>
    (shape ((child $dom binfoNone) (child $cod (binfoTerm 1))) "pi") ;
  rule shapeSigma: (exprShape (sigma $dom $cod)) ~>
    (shape ((child $dom binfoNone) (child $cod (binfoTerm 1))) "sigma") ;
  
  -- Three children
  rule shapePath: (exprShape (path $A $a $b)) ~>
    (shape ((child $A binfoNone) (child $a binfoNone) (child $b binfoNone)) "path") ;
  rule shapeSub: (exprShape (sub $A $φ $t)) ~>
    (shape ((child $A binfoNone) (child $φ binfoNone) (child $t binfoNone)) "sub") ;
  rule shapeLetE: (exprShape (letE $ty $val $body)) ~>
    (shape ((child $ty binfoNone) (child $val binfoNone) (child $body (binfoTerm 1))) "letE") ;
  
  -- Four children
  rule shapeCoe: (exprShape (coe $r $r' $A $a)) ~>
    (shape ((child $r binfoNone) (child $r' binfoNone) (child $A (binfoDim 1)) (child $a binfoNone)) "coe") ;
  rule shapeNatElim: (exprShape (natElim $P $z $s $n)) ~>
    (shape ((child $P binfoNone) (child $z binfoNone) (child $s (binfoTerm 2)) (child $n binfoNone)) "natElim") ;
  rule shapeCircleElim: (exprShape (circleElim $P $b $l $x)) ~>
    (shape ((child $P binfoNone) (child $b binfoNone) (child $l (binfoDim 1)) (child $x binfoNone)) "circleElim") ;

-----------------------------------------------------
-- Reconstruct
-- Rebuild expression from children
-----------------------------------------------------
piece Reconstruct
  rule reconstructIx: (reconstruct "ix" () $orig) ~> $orig ;
  rule reconstructLit: (reconstruct "lit" () $orig) ~> $orig ;
  rule reconstructLam: (reconstruct "lam" ($body) (lam $oldBody)) ~> (lam $body) ;
  rule reconstructApp: (reconstruct "app" ($f $a) (app $oldF $oldA)) ~> (app $f $a) ;
  rule reconstructPi: (reconstruct "pi" ($dom $cod) (pi $oldDom $oldCod)) ~> (pi $dom $cod) ;
  rule reconstructSigma: (reconstruct "sigma" ($dom $cod) (sigma $oldDom $oldCod)) ~> (sigma $dom $cod) ;
  rule reconstructPair: (reconstruct "pair" ($a $b) (pair $oldA $oldB)) ~> (pair $a $b) ;
  rule reconstructFst: (reconstruct "fst" ($e) (fst $oldE)) ~> (fst $e) ;
  rule reconstructSnd: (reconstruct "snd" ($e) (snd $oldE)) ~> (snd $e) ;
  rule reconstructPlam: (reconstruct "plam" ($body) (plam $oldBody)) ~> (plam $body) ;
  rule reconstructPapp: (reconstruct "papp" ($p $r) (papp $oldP $oldR)) ~> (papp $p $r) ;
  rule reconstructPath: (reconstruct "path" ($A $a $b) (path $oldA $oldA' $oldB)) ~> (path $A $a $b) ;
  rule reconstructRefl: (reconstruct "refl" ($a) (refl $oldA)) ~> (refl $a) ;
  rule reconstructCofEq: (reconstruct "cof_eq" ($r $s) (cof_eq $oldR $oldS)) ~> (cof_eq $r $s) ;
  rule reconstructCofAnd: (reconstruct "cof_and" ($φ $ψ) (cof_and $oldPhi $oldPsi)) ~> (cof_and $φ $ψ) ;
  rule reconstructCofOr: (reconstruct "cof_or" ($φ $ψ) (cof_or $oldPhi $oldPsi)) ~> (cof_or $φ $ψ) ;
  rule reconstructCoe: (reconstruct "coe" ($r $r' $A $a) (coe $oldR $oldR' $oldA $oldA')) ~> (coe $r $r' $A $a) ;
  rule reconstructSuc: (reconstruct "suc" ($n) (suc $oldN)) ~> (suc $n) ;
  rule reconstructNatElim: (reconstruct "natElim" ($P $z $s $n) (natElim $oldP $oldZ $oldS $oldN)) ~> (natElim $P $z $s $n) ;
  rule reconstructLoop: (reconstruct "loop" ($r) (loop $oldR)) ~> (loop $r) ;
  rule reconstructCircleElim: (reconstruct "circleElim" ($P $b $l $x) (circleElim $oldP $oldB $oldL $oldX)) ~> (circleElim $P $b $l $x) ;
  rule reconstructSub: (reconstruct "sub" ($A $φ $t) (sub $oldA $oldPhi $oldT)) ~> (sub $A $φ $t) ;
  rule reconstructSubIn: (reconstruct "subIn" ($e) (subIn $oldE)) ~> (subIn $e) ;
  rule reconstructSubOut: (reconstruct "subOut" ($e) (subOut $oldE)) ~> (subOut $e) ;
  rule reconstructLetE: (reconstruct "letE" ($ty $val $body) (letE $oldTy $oldVal $oldBody)) ~> (letE $ty $val $body) ;

-----------------------------------------------------
-- FreeVars
-- Collect free de Bruijn indices
-----------------------------------------------------
piece FreeVars
  rule freeVarsIx: (freeVars' $depth (ix $n)) ~> (if (geq $n $depth) (cons $n nil) nil) ;
  rule freeVarsLit: (freeVars' $depth (lit $s)) ~> nil ;
  rule freeVarsLam: (freeVars' $depth (lam $body)) ~> (freeVars' (suc $depth) $body) ;
  rule freeVarsApp: (freeVars' $depth (app $f $a)) ~> (append (freeVars' $depth $f) (freeVars' $depth $a)) ;
  rule freeVarsPi: (freeVars' $depth (pi $dom $cod)) ~> (append (freeVars' $depth $dom) (freeVars' (suc $depth) $cod)) ;
  rule freeVarsSigma: (freeVars' $depth (sigma $dom $cod)) ~> (append (freeVars' $depth $dom) (freeVars' (suc $depth) $cod)) ;
  rule freeVarsPair: (freeVars' $depth (pair $a $b)) ~> (append (freeVars' $depth $a) (freeVars' $depth $b)) ;
  rule freeVarsFst: (freeVars' $depth (fst $e)) ~> (freeVars' $depth $e) ;
  rule freeVarsSnd: (freeVars' $depth (snd $e)) ~> (freeVars' $depth $e) ;
  rule freeVarsPlam: (freeVars' $depth (plam $body)) ~> (freeVars' $depth $body) ;
  rule freeVarsPapp: (freeVars' $depth (papp $p $r)) ~> (freeVars' $depth $p) ;
  rule freeVarsUniv: (freeVars' $depth (univ $l)) ~> nil ;
  rule freeVarsPath: (freeVars' $depth (path $A $a $b)) ~> (append (freeVars' $depth $A) (append (freeVars' $depth $a) (freeVars' $depth $b))) ;
  
  -- Convenience: freeVars with depth 0
  rule freeVars: (freeVars $e) ~> (freeVars' 0 $e) ;

-----------------------------------------------------
-- FreeIn
-- Check if a variable is free in expression
-----------------------------------------------------
piece FreeIn
  rule freeIn: (freeIn $n $e) ~> (elem $n (freeVars $e)) ;

-----------------------------------------------------
-- WHNF
-- Weak head normal form step
-----------------------------------------------------
piece WHNF
  -- Beta reduction for app
  rule whnfAppLam: (whnfStep (app (lam $body) $arg)) ~> (some (subst 0 $arg $body)) ;
  rule whnfAppOther: (whnfStep (app $f $a)) ~> none when (not (isLam $f)) ;
  
  -- Projections
  rule whnfFstPair: (whnfStep (fst (pair $a $b))) ~> (some $a) ;
  rule whnfSndPair: (whnfStep (snd (pair $a $b))) ~> (some $b) ;
  rule whnfFstOther: (whnfStep (fst $p)) ~> none when (not (isPair $p)) ;
  rule whnfSndOther: (whnfStep (snd $p)) ~> none when (not (isPair $p)) ;
  
  -- Path application
  rule whnfPappPlam: (whnfStep (papp (plam $body) $r)) ~> (some (substDim 0 $r $body)) ;
  rule whnfPappRefl: (whnfStep (papp (refl $a) $r)) ~> (some $a) ;
  rule whnfPappOther: (whnfStep (papp $p $r)) ~> none when (not (isPlam $p)), (not (isRefl $p)) ;
  
  -- Let binding
  rule whnfLet: (whnfStep (letE $ty $val $body)) ~> (some (subst 0 $val $body)) ;
  
  -- Default: no reduction
  rule whnfStepDefault: (whnfStep $e) ~> none ;
  
  -- Full WHNF with fuel
  rule whnf': (whnf' $fuel $e) ~> (whnfLoop $fuel $e) when (gt $fuel 0) ;
  rule whnf'Zero: (whnf' 0 $e) ~> $e ;
  
  rule whnfLoop: (whnfLoop $fuel $e) ~>
    (match (whnfStep $e) with
     | (some $e') => (whnf' (sub $fuel 1) $e')
     | none => $e) ;

-----------------------------------------------------
-- TryBetaReduce
-- Generic β-reduction using visitor
-----------------------------------------------------
piece TryBetaReduce
  rule tryBetaApp: (tryBetaReduce (app (lam $body) $arg)) ~> (some (subst 0 $arg $body)) ;
  rule tryBetaFst: (tryBetaReduce (fst (pair $a $b))) ~> (some $a) ;
  rule tryBetaSnd: (tryBetaReduce (snd (pair $a $b))) ~> (some $b) ;
  rule tryBetaPapp: (tryBetaReduce (papp (plam $body) $r)) ~> (some (substDim 0 $r $body)) ;
  rule tryBetaRefl: (tryBetaReduce (papp (refl $a) $r)) ~> (some $a) ;
  rule tryBetaNone: (tryBetaReduce $e) ~> none ;


-----------------------------------------------------
-- Derived Operations
-----------------------------------------------------

derive subst for term ;
derive normalize for term with fuel = 100 ;

