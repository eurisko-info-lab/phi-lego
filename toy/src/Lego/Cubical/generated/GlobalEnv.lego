-----------------------------------------------------
-- GlobalEnv.lego: Global Environment for Definitions and Datatypes
--
-- Mathematical Structure:
-- - The global env forms a category of contexts
-- - Definitions are morphisms (substitutions)
-- - Datatypes are inductive types in the initial algebra
--
-- Holds type definitions, datatype declarations, dimension variables, metas.
-----------------------------------------------------

import Core ;

lang GlobalEnv (Core) :=

-----------------------------------------------------
-- GName
-- Global names with optional metadata
-----------------------------------------------------
piece GName
  gname ::= "gname" <string> "source:" <string>? â†’ gname ;
  
  rule gnameNamed: (gnameNamed $s) ~> (gname $s source: none) ;
  rule gnameFresh: (gnameFresh $base $counter) ~> (gname (concat $base "_" $counter) source: none) ;
  rule gnameAnonymous: gnameAnonymous ~> (gname "_" source: none) ;
  
  rule gnameName: (gnameName (gname $n source: $s)) ~> $n ;
  rule gnameSource: (gnameSource (gname $n source: $s)) ~> $s ;
  
  rule gnameEq: (gnameEq (gname $n1 source: $s1) (gname $n2 source: $s2)) ~> (eq $n1 $n2) ;

-----------------------------------------------------
-- GArgSpec
-- Argument specification in constructor telescope
-----------------------------------------------------
piece GArgSpec
  argConst ::= "const" <expr> â†’ gArgSpec ;
  argRecursive ::= "recursive" â†’ gArgSpec ;
  argDim ::= "dim" â†’ gArgSpec ;

-----------------------------------------------------
-- GConstructor
-- Constructor definition
-----------------------------------------------------
piece GConstructor
  gconstructor ::= "constructor" "name:" <string> "args:" <constructorArg>* "boundary:" <boundary>* â†’ gconstructor ;
  constructorArg ::= "(" <string> ":" <gArgSpec> ")" â†’ constructorArg ;
  boundary ::= "[" <expr> "â†¦" <expr> "]" â†’ boundary ;
  
  rule gconstructorName: (gconstructorName (constructor name: $n args: $a boundary: $b)) ~> $n ;
  rule gconstructorArgs: (gconstructorArgs (constructor name: $n args: $a boundary: $b)) ~> $a ;
  rule gconstructorBoundary: (gconstructorBoundary (constructor name: $n args: $a boundary: $b)) ~> $b ;

-----------------------------------------------------
-- GDataDesc
-- Datatype descriptor
-----------------------------------------------------
piece GDataDesc
  gdataDesc ::= "dataDesc" "name:" <gname> "params:" <param>* "level:" <level> "constrs:" <gconstructor>* â†’ gdataDesc ;
  param ::= "(" <string> ":" <expr> ")" â†’ param ;
  
  rule gdataDescName: (gdataDescName (dataDesc name: $n params: $p level: $l constrs: $c)) ~> $n ;
  rule gdataDescParams: (gdataDescParams (dataDesc name: $n params: $p level: $l constrs: $c)) ~> $p ;
  rule gdataDescLevel: (gdataDescLevel (dataDesc name: $n params: $p level: $l constrs: $c)) ~> $l ;
  rule gdataDescConstrs: (gdataDescConstrs (dataDesc name: $n params: $p level: $l constrs: $c)) ~> $c ;

-----------------------------------------------------
-- GEntry
-- Entry types in the global environment
-----------------------------------------------------
piece GEntry
  gEntryParam ::= "param" <expr> â†’ gEntry ;
  gEntryDefn ::= "defn" "type:" <expr> "value:" <expr> â†’ gEntry ;
  gEntryDatatype ::= "datatype" <gdataDesc> â†’ gEntry ;
  gEntryDimVar ::= "dimVar" â†’ gEntry ;
  gEntryMetaVar ::= "metaVar" "type:" <expr> "solution:" <expr>? â†’ gEntry ;
  
  rule gEntryGetType: (gEntryGetType (param $ty)) ~> (some $ty) ;
  rule gEntryGetTypeDefn: (gEntryGetType (defn type: $ty value: $v)) ~> (some $ty) ;
  rule gEntryGetTypeDatatype: (gEntryGetType (datatype $desc)) ~> (some (univ (gdataDescLevel $desc))) ;
  rule gEntryGetTypeDimVar: (gEntryGetType dimVar) ~> (some (lit "ð•€")) ;
  rule gEntryGetTypeMeta: (gEntryGetType (metaVar type: $ty solution: $sol)) ~> (some $ty) ;

-----------------------------------------------------
-- GlobalEnv
-- The global environment
-----------------------------------------------------
piece GlobalEnv
  globalEnv ::= "globalEnv" "entries:" <envEntry>* "order:" <gname>* â†’ globalEnv ;
  envEntry ::= "(" <gname> "â†¦" <gEntry> ")" â†’ envEntry ;
  
  rule globalEnvEmpty: globalEnvEmpty ~> (globalEnv entries: () order: ()) ;
  
  rule globalEnvExtend: (globalEnvExtend (globalEnv entries: $entries order: $order) $nm $entry) ~>
    (globalEnv entries: ($entries (($nm â†¦ $entry))) order: ($nm $order)) ;
  
  rule globalEnvDefine: (globalEnvDefine $env $nm $ty $tm) ~>
    (globalEnvExtend $env $nm (defn type: $ty value: $tm)) ;
  
  rule globalEnvDeclareParam: (globalEnvDeclareParam $env $nm $ty) ~>
    (globalEnvExtend $env $nm (param $ty)) ;
  
  rule globalEnvDeclareDim: (globalEnvDeclareDim $env $nm) ~>
    (globalEnvExtend $env $nm dimVar) ;
  
  rule globalEnvDeclareDatatype: (globalEnvDeclareDatatype $env $desc) ~>
    (globalEnvExtend $env (gdataDescName $desc) (datatype $desc)) ;
  
  rule globalEnvCreateMeta: (globalEnvCreateMeta $env $nm $ty) ~>
    (globalEnvExtend $env $nm (metaVar type: $ty solution: none)) ;
  
  rule globalEnvSolveMeta: (globalEnvSolveMeta (globalEnv entries: $entries order: $order) $nm $solution) ~>
    (globalEnv entries: (solveMeta' $entries $nm $solution) order: $order) ;
  
  rule solveMeta'Nil: (solveMeta' () $nm $sol) ~> () ;
  rule solveMeta'Match: (solveMeta' ((($nm â†¦ (metaVar type: $ty solution: $old))) $rest) $nm $sol) ~>
    ((($nm â†¦ (metaVar type: $ty solution: (some $sol)))) $rest) ;
  rule solveMeta'Miss: (solveMeta' (($entry) $rest) $nm $sol) ~>
    (($entry) (solveMeta' $rest $nm $sol)) ;

-----------------------------------------------------
-- Lookup
-- Lookup operations
-----------------------------------------------------
piece Lookup
  rule globalEnvLookup: (globalEnvLookup (globalEnv entries: $entries order: $order) $nm) ~>
    (lookupEntry $entries $nm) ;
  
  rule lookupEntryNil: (lookupEntry () $nm) ~> none ;
  rule lookupEntryMatch: (lookupEntry ((($nm â†¦ $entry)) $rest) $nm) ~> (some $entry) ;
  rule lookupEntryMiss: (lookupEntry ((($nm' â†¦ $entry)) $rest) $nm) ~>
    (lookupEntry $rest $nm) ;
  
  rule globalEnvLookupType: (globalEnvLookupType $env $nm) ~>
    (case (globalEnvLookup $env $nm)
      (some $entry) => (gEntryGetType $entry)
      none => none) ;
  
  rule globalEnvLookupValue: (globalEnvLookupValue (globalEnv entries: $entries order: $order) $nm) ~>
    (case (lookupEntry $entries $nm)
      (some (defn type: $ty value: $v)) => (some $v)
      _ => none) ;
  
  rule globalEnvLookupDatatype: (globalEnvLookupDatatype (globalEnv entries: $entries order: $order) $nm) ~>
    (case (lookupEntry $entries $nm)
      (some (datatype $desc)) => (some $desc)
      _ => none) ;
  
  rule globalEnvLookupMeta: (globalEnvLookupMeta (globalEnv entries: $entries order: $order) $nm) ~>
    (case (lookupEntry $entries $nm)
      (some (metaVar type: $ty solution: $sol)) => (some (type: $ty solution: $sol))
      _ => none) ;

-----------------------------------------------------
-- Query
-- Query operations
-----------------------------------------------------
piece Query
  rule globalEnvIsDefined: (globalEnvIsDefined $env $nm) ~>
    (case (globalEnvLookup $env $nm)
      (some _) => true
      none => false) ;
  
  rule globalEnvIsMetaSolved: (globalEnvIsMetaSolved $env $nm) ~>
    (case (globalEnvLookupMeta $env $nm)
      (some (type: $ty solution: (some $sol))) => true
      _ => false) ;
  
  rule globalEnvAllNames: (globalEnvAllNames (globalEnv entries: $entries order: $order)) ~> $order ;
  
  rule globalEnvFilterByKind: (globalEnvFilterByKind (globalEnv entries: $entries order: $order) $kind) ~>
    (filter (fun nm => (matchKind (lookupEntry $entries nm) $kind)) $order) ;
  
  rule matchKindDefn: (matchKind (some (defn type: $t value: $v)) defn) ~> true ;
  rule matchKindParam: (matchKind (some (param $t)) param) ~> true ;
  rule matchKindDatatype: (matchKind (some (datatype $d)) datatype) ~> true ;
  rule matchKindDimVar: (matchKind (some dimVar) dimVar) ~> true ;
  rule matchKindMetaVar: (matchKind (some (metaVar type: $t solution: $s)) metaVar) ~> true ;
  rule matchKindOther: (matchKind $entry $kind) ~> false ;

-----------------------------------------------------
-- Unfold
-- Unfold definitions in an expression
-----------------------------------------------------
piece Unfold
  -- Unfold a single global reference
  rule unfoldOne: (unfoldOne $env (lit $name)) ~>
    (case (globalEnvLookupValue $env (gnameNamed $name))
      (some $val) => $val
      none => (lit $name)) ;
  rule unfoldOneOther: (unfoldOne $env $e) ~> $e ;
  
  -- Full unfolding (recursive)
  rule unfoldAll: (unfoldAll $env $e) ~> (unfoldAll' $env $e 100) ;
  
  rule unfoldAll'0: (unfoldAll' $env $e 0) ~> $e ;
  rule unfoldAll': (unfoldAll' $env $e (suc $fuel)) ~>
    (let e' = (unfoldStep $env $e) in
     case (eq e' $e)
       true => e'
       false => (unfoldAll' $env e' $fuel)) ;
  
  rule unfoldStepLit: (unfoldStep $env (lit $name)) ~>
    (case (globalEnvLookupValue $env (gnameNamed $name))
      (some $val) => $val
      none => (lit $name)) ;
  rule unfoldStepApp: (unfoldStep $env (app $f $a)) ~>
    (app (unfoldStep $env $f) (unfoldStep $env $a)) ;
  rule unfoldStepLam: (unfoldStep $env (lam $body)) ~> (lam (unfoldStep $env $body)) ;
  rule unfoldStepPi: (unfoldStep $env (pi $dom $cod)) ~>
    (pi (unfoldStep $env $dom) (unfoldStep $env $cod)) ;
  rule unfoldStepOther: (unfoldStep $env $e) ~> $e ;

-----------------------------------------------------
-- Print
-- Pretty printing helpers
-----------------------------------------------------
piece Print
  rule globalEnvPrint: (globalEnvPrint (globalEnv entries: $entries order: $order)) ~>
    (mapReverse (fun nm => (printEntry nm (lookupEntry $entries nm))) $order) ;
  
  rule printEntry: (printEntry $nm (some (defn type: $ty value: $v))) ~>
    (concat "def " (gnameName $nm) " : " (show $ty) " := " (show $v)) ;
  rule printEntryParam: (printEntry $nm (some (param $ty))) ~>
    (concat "param " (gnameName $nm) " : " (show $ty)) ;
  rule printEntryDatatype: (printEntry $nm (some (datatype $desc))) ~>
    (concat "data " (gnameName $nm) " ...") ;
  rule printEntryDimVar: (printEntry $nm (some dimVar)) ~>
    (concat "dim " (gnameName $nm)) ;
  rule printEntryMetaVar: (printEntry $nm (some (metaVar type: $ty solution: $sol))) ~>
    (concat "meta " (gnameName $nm) " : " (show $ty)) ;
  rule printEntryNone: (printEntry $nm none) ~> (concat "unknown " (gnameName $nm)) ;


-----------------------------------------------------
-- Derived Operations
-----------------------------------------------------

derive subst for term ;
derive normalize for term with fuel = 100 ;

