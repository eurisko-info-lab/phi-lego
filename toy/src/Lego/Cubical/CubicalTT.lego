-----------------------------------------------------
-- CubicalTT: Shared Cubical Type Theory Foundation
-- 
-- Core CCHM cubical type theory shared by redtt and cooltt.
-- Red.lego and Cool.lego import this as their base.
--
-- Mathematical Foundation: Cartesian Cubical Type Theory
-- - Interval I: De Morgan algebra
-- - Cofibrations Ï†: distributive lattice  
-- - Kan operations: computational univalence
-----------------------------------------------------

lang CubicalTT :=

-----------------------------------------------------
-- Dimension
-- The interval I with De Morgan algebra structure
-----------------------------------------------------

piece Dimension
  dim ::= "0"                          â†’ i0
        | "1"                          â†’ i1
        | <ident>                      â†’ ivar
        | dim "âˆ¨" dim                  â†’ join
        | dim "âˆ§" dim                  â†’ meet
        | "~" dim                      â†’ inv ;

  rule join0L: (join 0 $r) ~> $r ;
  rule join0R: (join $r 0) ~> $r ;
  rule join1L: (join 1 $r) ~> 1 ;
  rule join1R: (join $r 1) ~> 1 ;
  rule meet0L: (meet 0 $r) ~> 0 ;
  rule meet0R: (meet $r 0) ~> 0 ;
  rule meet1L: (meet 1 $r) ~> $r ;
  rule meet1R: (meet $r 1) ~> $r ;
  rule inv0: (inv 0) ~> 1 ;
  rule inv1: (inv 1) ~> 0 ;
  rule invInv: (inv (inv $r)) ~> $r ;

  test "join-id": (join 0 i) ~~> i ;
  test "meet-zero": (meet 0 i) ~~> 0 ;
  test "involution": (inv (inv i)) ~~> i ;

-----------------------------------------------------
-- Cofibration
-- Cofibrations Ï† : ð”½ (face lattice)
-----------------------------------------------------

piece Cofibration
  cof ::= "âŠ¥"                          â†’ cof0
        | "âŠ¤"                          â†’ cof1
        | dim "=" dim                  â†’ eq
        | cof "âˆ¨" cof                  â†’ cofOr
        | cof "âˆ§" cof                  â†’ cofAnd ;
        
  rule cof0Or: (join cof0 $Ï†) ~> $Ï† ;
  rule cof1And: (meet cof1 $Ï†) ~> $Ï† ;

-----------------------------------------------------
-- Core
-- Universe, variables, basic terms
-----------------------------------------------------

piece Core
  term ::= "U"                         â†’ U
         | <ident>                     â†’ var
         | "(" term term ")"           â†’ app
         | "(" term "," term ")"       â†’ pair
         | term ".fst"                 â†’ fst
         | term ".snd"                 â†’ snd ;

  rule fstPair: (fst (pair $a  $b)) ~> $a ;
  rule sndPair: (snd (pair $a  $b)) ~> $b ;
    
  test "fst": (fst (pair a  b)) ~~> a ;
  test "snd": (snd (pair a  b)) ~~> b ;

-----------------------------------------------------
-- Lambda
-- Lambda abstraction and dimension abstraction
-----------------------------------------------------

piece Lambda
  term ::= "Î»" <ident> "." term        â†’ lam
         | "Î»áµ¢" <ident> "." term       â†’ dlam
         | term "@" dim                â†’ dapp ;

  rule beta: (app (lam $x $body) $arg) ~> (subst x $arg $body) ;
  rule dbeta: (dapp (Î»áµ¢ $i . $body) $r) ~> (subst i $r $body) ;
    
  test "beta": (app (lam x x) y) ~~> y ;
  test "dbeta": (dapp (dlam i (dapp f i)) 0) ~~> (dapp f 0) ;

-----------------------------------------------------
-- Pi
-- Dependent function types
-----------------------------------------------------

piece Pi
  term ::= "Î " "(" <ident> ":" term ")" term  â†’ Pi
         | term "â†’" term                      â†’ arr ;

  type PiForm: (Î  ($x : $A) $B) : U
    when $A : U, [$x : $A] $B : U ;

-----------------------------------------------------
-- Sigma  
-- Dependent pair types
-----------------------------------------------------

piece Sigma
  term ::= "Î£" "(" <ident> ":" term ")" term  â†’ Sigma
         | term "Ã—" term                      â†’ prod ;

  type SigmaForm: (Î£ ($x : $A) $B) : U
    when $A : U, [$x : $A] $B : U ;

-----------------------------------------------------
-- Path
-- Path types: Path A a b
-----------------------------------------------------

piece Path
  term ::= "Path" term term term       â†’ Path ;

  type PathForm: (Path $A $a $b) : U
    when $A : U, $a : $A, $b : $A ;
    
  test "refl": (Î»áµ¢ i . a) : (Path A a a) ;

-----------------------------------------------------
-- System
-- Partial elements [Ï† â†¦ u]
-----------------------------------------------------

piece System
  system ::= "[" sysbranch* "]"        â†’ sys ;
  sysbranch ::= cof "â†¦" term           â†’ branch ;

-----------------------------------------------------
-- Coe
-- Coercion: coe r~>s (i.A) a
-----------------------------------------------------

piece Coe
  term ::= "coe" dim "~>" dim "(" <ident> "." term ")" term  â†’ coe ;

  rule coeRefl: (coe $r ~> $r ($i . $A) $a) ~> $a ;
    
  type coeType: (coe $r ~> $s ($i . $A) $a) : [$i := $s] $A
    when $a : [$i := $r] $A ;
      
  test "coe-refl": (coe 0 ~> 0 (i . A) a) ~~> a ;

-----------------------------------------------------
-- Hcom
-- Homogeneous composition: hcom r~>s A [Ï† â†¦ u] a
-----------------------------------------------------

piece Hcom
  term ::= "hcom" dim "~>" dim term system term  â†’ hcom ;

  rule hcomRefl: (hcom $r ~> $r $A $sys $a) ~> $a ;
    
  type hcomType: (hcom $r ~> $s $A [$Ï† â†¦ $u] $a) : $A
    when $a : $A, [$Ï†] $u : I â†’ $A ;

-----------------------------------------------------
-- Com
-- Heterogeneous composition: com r~>s (i.A) [Ï† â†¦ u] a
-----------------------------------------------------

piece Com
  term ::= "com" dim "~>" dim "(" <ident> "." term ")" system term  â†’ com ;

  rule comRefl: (com $r ~> $r ($i . $A) $sys $a) ~> $a ;

-----------------------------------------------------
-- VType
-- V-types for univalence: V r A B e
-----------------------------------------------------

piece VType
  term ::= "V" dim term term term      â†’ V
         | "Vin" dim term              â†’ Vin
         | "Vproj" dim term term       â†’ Vproj ;

  rule Vin0: (Vin 0 $a) ~> (fst $a) ;
  rule Vin1: (Vin 1 $a) ~> $a ;
  rule Vproj0: (Vproj 0 $v $e) ~> ($e (snd $v)) ;
  rule Vproj1: (Vproj 1 $v $e) ~> $v ;
    
  type VForm: (V $r $A $B $e) : U
    when $A : U, $B : U, $e : Equiv $A $B ;

-----------------------------------------------------
-- Sub
-- Subtypes: Sub A Ï† u
-----------------------------------------------------

piece Sub
  term ::= "Sub" term cof term         â†’ Sub
         | "inS" term                  â†’ inS
         | "outS" term                 â†’ outS ;

  rule outInS: (outS (inS $a)) ~> $a ;
    
  type SubForm: (Sub $A $Ï† $u) : U
    when $A : U, [$Ï†] $u : $A ;
