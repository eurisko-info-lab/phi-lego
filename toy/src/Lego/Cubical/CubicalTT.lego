-----------------------------------------------------
-- CubicalTT: Shared Cubical Type Theory Foundation
-- 
-- Core CCHM cubical type theory shared by redtt and cooltt.
-- Red.lego and Cool.lego import this as their base.
--
-- Mathematical Foundation: Cartesian Cubical Type Theory
-- - Interval I: De Morgan algebra
-- - Cofibrations Ï†: distributive lattice  
-- - Kan operations: computational univalence
-----------------------------------------------------

lang CubicalTT :=

-----------------------------------------------------
-- PIECE 1: Dimension
-- The interval I with De Morgan algebra structure
-----------------------------------------------------

piece Dimension
  dim ::= "0"                          $ i0
        | "1"                          $ i1
        | <ident>                      $ ivar
        | dim "âˆ¨" dim                  $ join
        | dim "âˆ§" dim                  $ meet
        | "~" dim                      $ inv

  rule join0L: (0 âˆ¨ $r) ~> $r
  rule join0R: ($r âˆ¨ 0) ~> $r  
  rule join1L: (1 âˆ¨ $r) ~> 1
  rule join1R: ($r âˆ¨ 1) ~> 1
  rule meet0L: (0 âˆ§ $r) ~> 0
  rule meet0R: ($r âˆ§ 0) ~> 0
  rule meet1L: (1 âˆ§ $r) ~> $r
  rule meet1R: ($r âˆ§ 1) ~> $r
  rule inv0: (~ 0) ~> 1
  rule inv1: (~ 1) ~> 0
  rule invInv: (~ (~ $r)) ~> $r

  test "join-id": (0 âˆ¨ i) ~~> i
  test "meet-zero": (0 âˆ§ i) ~~> 0
  test "involution": (~ (~ i)) ~~> i

-----------------------------------------------------
-- PIECE 2: Cofibration
-- Cofibrations Ï† : ð”½ (face lattice)
-----------------------------------------------------

piece Cofibration
  cof ::= "âŠ¥"                          $ cof0
        | "âŠ¤"                          $ cof1
        | dim "=" dim                  $ eq
        | cof "âˆ¨" cof                  $ cofOr
        | cof "âˆ§" cof                  $ cofAnd
        
  rule cof0Or: (âŠ¥ âˆ¨ $Ï†) ~> $Ï†
  rule cof1And: (âŠ¤ âˆ§ $Ï†) ~> $Ï†

-----------------------------------------------------
-- PIECE 3: Core
-- Universe, variables, basic terms
-----------------------------------------------------

piece Core
  term ::= "U"                         $ U
         | <ident>                     $ var
         | "(" term term ")"           $ app
         | "(" term "," term ")"       $ pair
         | term ".fst"                 $ fst
         | term ".snd"                 $ snd

  rule fstPair: (($a , $b) .fst) ~> $a
  rule sndPair: (($a , $b) .snd) ~> $b
    
  test "fst": ((a , b) .fst) ~~> a
  test "snd": ((a , b) .snd) ~~> b

-----------------------------------------------------
-- PIECE 4: Lambda
-- Lambda abstraction and dimension abstraction
-----------------------------------------------------

piece Lambda
  term ::= "Î»" <ident> "." term        $ lam
         | "Î»áµ¢" <ident> "." term       $ dlam
         | term "@" dim                $ dapp

  rule beta: ((Î» $x . $body) $arg) ~> [x := $arg] $body
  rule dbeta: ((Î»áµ¢ $i . $body) @ $r) ~> [i := $r] $body
    
  test "beta": ((Î» x . x) y) ~~> y
  test "dbeta": ((Î»áµ¢ i . (f @ i)) @ 0) ~~> (f @ 0)

-----------------------------------------------------
-- PIECE 5: Pi
-- Dependent function types
-----------------------------------------------------

piece Pi
  term ::= "Î " "(" <ident> ":" term ")" term  $ Pi
         | term "â†’" term                       $ arr

  type PiForm: (Î  ($x : $A) $B) : U
    when $A : U, [$x : $A] $B : U

-----------------------------------------------------
-- PIECE 6: Sigma  
-- Dependent pair types
-----------------------------------------------------

piece Sigma
  term ::= "Î£" "(" <ident> ":" term ")" term  $ Sigma
         | term "Ã—" term                       $ prod

  type SigmaForm: (Î£ ($x : $A) $B) : U
    when $A : U, [$x : $A] $B : U

-----------------------------------------------------
-- PIECE 7: Path
-- Path types: Path A a b
-----------------------------------------------------

piece Path
  term ::= "Path" term term term       $ Path

  type PathForm: (Path $A $a $b) : U
    when $A : U, $a : $A, $b : $A
    
  test "refl": (Î»áµ¢ i . a) : (Path A a a)

-----------------------------------------------------
-- PIECE 8: System
-- Partial elements [Ï† â†¦ u]
-----------------------------------------------------

piece System
  system ::= "[" sysbranch* "]"        $ sys
  sysbranch ::= cof "â†¦" term           $ branch

-----------------------------------------------------
-- PIECE 9: Coe
-- Coercion: coe r~>s (i.A) a
-----------------------------------------------------

piece Coe
  term ::= "coe" dim "~>" dim "(" <ident> "." term ")" term  $ coe

  rule coeRefl: (coe $r ~> $r ($i . $A) $a) ~> $a
    
  type coeType: (coe $r ~> $s ($i . $A) $a) : [$i := $s] $A
    when $a : [$i := $r] $A
      
  test "coe-refl": (coe 0 ~> 0 (i . A) a) ~~> a

-----------------------------------------------------
-- PIECE 10: Hcom
-- Homogeneous composition: hcom r~>s A [Ï† â†¦ u] a
-----------------------------------------------------

piece Hcom
  term ::= "hcom" dim "~>" dim term system term  $ hcom

  rule hcomRefl: (hcom $r ~> $r $A $sys $a) ~> $a
    
  type hcomType: (hcom $r ~> $s $A [$Ï† â†¦ $u] $a) : $A
    when $a : $A, [$Ï†] $u : I â†’ $A

-----------------------------------------------------
-- PIECE 11: Com
-- Heterogeneous composition: com r~>s (i.A) [Ï† â†¦ u] a
-----------------------------------------------------

piece Com
  term ::= "com" dim "~>" dim "(" <ident> "." term ")" system term  $ com

  rule comRefl: (com $r ~> $r ($i . $A) $sys $a) ~> $a

-----------------------------------------------------
-- PIECE 12: VType
-- V-types for univalence: V r A B e
-----------------------------------------------------

piece VType
  term ::= "V" dim term term term      $ V
         | "Vin" dim term              $ Vin
         | "Vproj" dim term term       $ Vproj

  rule Vin0: (Vin 0 $a) ~> ($a .fst)
  rule Vin1: (Vin 1 $a) ~> $a
  rule Vproj0: (Vproj 0 $v $e) ~> ($e ($v .snd))
  rule Vproj1: (Vproj 1 $v $e) ~> $v
    
  type VForm: (V $r $A $B $e) : U
    when $A : U, $B : U, $e : Equiv $A $B

-----------------------------------------------------
-- PIECE 13: Sub
-- Subtypes: Sub A Ï† u
-----------------------------------------------------

piece Sub
  term ::= "Sub" term cof term         $ Sub
         | "inS" term                  $ inS
         | "outS" term                 $ outS

  rule outInS: (outS (inS $a)) ~> $a
    
  type SubForm: (Sub $A $Ï† $u) : U
    when $A : U, [$Ï†] $u : $A
