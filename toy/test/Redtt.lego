-----------------------------------------------------
-- Redtt: A modular parser for redtt (.red) files
--
-- Grammar for parsing .red files from the redtt library.
-- Organized into logical pieces for maintainability.
-- Cross-piece references work via parse-time name resolution.
--
-- Based on: https://github.com/RedPRL/redtt
--
-- redtt is a proof assistant implementing cartesian cubical type theory
-- with higher inductive types, univalence, and computational content.
--
-- Key features:
-- - Cartesian cubical type theory with interval ùïÄ
-- - Path types [i] A [i=0 ‚Üí M | i=1 ‚Üí N]
-- - Higher inductive types (data with path constructors)
-- - coe, comp, hcom operations
-- - Universe polymorphism (type, type^1, ...)
-----------------------------------------------------

lang Redtt :=

-----------------------------------------------------
-- Token: Character-level lexer for Red files
-- Overrides Bootstrap tokenizer with Red-specific rules
-- Uses 'x' single-char literals (same algebra as piece)
-----------------------------------------------------

token Token
  -- Character classes
  digit  ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;
  lower  ::= 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j'
           | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't'
           | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' ;
  upper  ::= 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J'
           | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T'
           | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' ;
  greek  ::= 'Œ±' | 'Œ≤' | 'Œ≥' | 'Œ¥' | 'Œµ' | 'Œ∂' | 'Œ∑' | 'Œ∏' | 'Œπ' | 'Œ∫'
           | 'Œª' | 'Œº' | 'ŒΩ' | 'Œæ' | 'Œø' | 'œÄ' | 'œÅ' | 'œÉ' | 'œÑ' | 'œÖ'
           | 'œÜ' | 'œá' | 'œà' | 'œâ'
           | 'Œë' | 'Œí' | 'Œì' | 'Œî' | 'Œï' | 'Œñ' | 'Œó' | 'Œò' | 'Œô' | 'Œö'
           | 'Œõ' | 'Œú' | 'Œù' | 'Œû' | 'Œü' | 'Œ†' | 'Œ°' | 'Œ£' | 'Œ§' | 'Œ•'
           | 'Œ¶' | 'Œß' | 'Œ®' | 'Œ©' ;
  -- Double-struck letters for type theory (ùïÄ for interval)
  mathbb ::= 'ùïÄ' | 'ùîΩ' | 'ùïä' ;
  -- Math symbols that can appear in identifiers
  mathsym ::= '‚âà' | '‚âÖ' | '‚â§' | '‚â•' | '‚àò' | '‚äó' | '‚äô' | '‚àß' | '‚à®' | '¬≥' ;
  alpha  ::= lower | upper | greek | mathbb | mathsym | '_' ;
  symch  ::= '(' | ')' | '[' | ']' | '{' | '}' | '<' | '>'
           | ':' | ';' | ',' | '.' | '|' | '!' | '?' | '@'
           | '#' | '$' | '%' | '^' | '&' | '*' | '+' | '-'
           | '=' | '~' | '/' | '\\' | '‚Üí' | '‚Üê' | '‚Üî' | '‚äï'
           | '‚ä¢' | '√ó' | 'Œª' | '‚àÇ' | '‚àÄ' | '‚àÉ' | '‚òÖ' | '‚òÜ'
           | '‚¶â' | '‚¶ä' | '¬´' | '¬ª' | '`' ;

  -- Red-specific token patterns
  -- '/' allowed in identifiers for hierarchical names (e.g., trans/filler)
  -- '\'' allowed as suffix for primed identifiers (e.g., symm')
  -- '+' allowed for identifiers like x+y'/le/m (used in gcd.red)
  ident   ::= alpha (alpha | digit | '-' | '/' | '\'' | '+')* ;
  number  ::= digit digit* ;
  string  ::= '"' strchar* '"' ;
  strchar ::= '\\' escape | printable ;
  escape  ::= '"' | '\\' | 'n' | 't' | 'r' | '\'' ;
  printable ::= alpha | digit | symch | ' ' ;

  -- Whitespace and comments (to skip)
  ws      ::= ' ' | '\t' | '\n' | '\r' ;
  comment ::= '-' '-' nonnl* ;
  nonnl   ::= alpha | digit | symch | ' ' | '\t' | '\'' | '"' ;

  -- Single symbol (fallback)
  sym     ::= symch ;

-----------------------------------------------------
-- File Structure
-----------------------------------------------------
piece File
  file       ::= topdecl* ;
  topdecl    ::= importdecl | defndecl | datadecl | metadecl | "opaque" ;

-----------------------------------------------------
-- Imports: public? import path.to.module
-- Module paths can have dots: data.bool, prelude.path
-- NOTE: 'data' is tokenized as symbol, so we accept name (ident or keyword)
-----------------------------------------------------
piece Imports
  importdecl ::= "public"? "import" modulepath ;
  modulepath ::= name ("." name)* ;
  name       ::= ident | "data" | "def" | "import" | "public" | "where" | "let" | "in" | "elim" | "opaque" | "private" | "meta" ;

-----------------------------------------------------
-- Definitions: def name (args) : type = body
-- Modifiers: opaque (skip computation), private (not exported)
-- Names can contain arrows: binnat‚Üínat, nat‚Üíbinnat‚Üínat
-----------------------------------------------------
piece Definitions
  defmodifiers ::= ("opaque" | "private")* ;
  defndecl   ::= defmodifiers "def" defname defscheme "=" expr 
               | "quit" ;   -- quit halts processing
  defscheme  ::= defargs ":" expr      -- (x : A) : B
               | defargs ;              -- (x : A) with inferred type
  defident   ::= ident "~" ident | ident ;
  -- defname allows: foo, p‚Üí, binnat‚Üínat, foo~bar
  -- The trailing ident after ‚Üí is optional for names like p‚Üí
  defname    ::= defident defnamesuffix* ;
  defnamesuffix ::= "‚Üí" ident | "‚Üí" | "~" ident ;
  defargs    ::= defarg* ;
  defarg     ::= "(" ident+ ":" expr ")" | ident ;

-----------------------------------------------------
-- Meta Commands: meta ‚¶â mlcmd ‚¶ä
-- Used for debugging: meta ‚¶â print normalize foo ‚¶ä
-- LTR/RTR brackets: ‚¶â ‚¶ä or <: :>
-----------------------------------------------------
piece Meta
  metadecl   ::= "meta" ltr mlcmd rtr ;
  ltr        ::= "‚¶â" | "<" ":" ;           -- LTR: ‚¶â or <:
  rtr        ::= "‚¶ä" | ":" ">" ;           -- RTR: ‚¶ä or :>
  llgl       ::= "¬´" | "<" "<" ;           -- LLGL: ¬´ or <<
  rrgl       ::= "¬ª" | ">" ">" ;           -- RRGL: ¬ª or >>
  mlcmd      ::= "let" ident "=" mlcmd "in" mlcmd   -- let x = c in c'
               | "let" ident "=" mlcmd              -- let x = c (top-level)
               | mlcmdseq ;
  mlcmdseq   ::= mlcmdexpr (";" mlcmd)? ;
  mlcmdexpr  ::= mlcmdatom mlval? ;
  mlcmdatom  ::= "fun" ident "‚Üí" mlcmd              -- fun x ‚Üí c
               | "check" mlval ":" mlval            -- check tm : ty
               | "!" mlval                          -- bang/unleash
               | "print" "normalize"? mlcmdatom     -- print [normalize] c
               | "normalize" mlcmdatom              -- normalize c
               | "debug" ident?                     -- debug [filter]
               | "quit"                             -- quit
               | llgl defndecl rrgl                 -- inline def: ¬´ def ... ¬ª
               | llgl datadecl rrgl                 -- inline data: ¬´ data ... ¬ª
               | llgl expr rrgl                     -- inline elab: ¬´ e ¬ª
               | mlval
               | "(" mlcmd ")" 
               | "begin" mlcmd "end" ;
  mlval      ::= "{" mlcmd "}"                      -- thunk
               | "<" mlval ("," mlval)* ">"         -- tuple: <v1, v2>
               | string
               | ident ;

-----------------------------------------------------
-- Data Types (Higher Inductive Types)
-- data Name where | Con1 | Con2 (x : A) | ...
-- data (A : type) ‚ä¢ Name where ...  (parameterized)
-- Constructors can have boundary constraints for HITs
-----------------------------------------------------
piece DataTypes
  datadecl    ::= "data" dataparams? ident "where" datacons ;
  dataparams  ::= picell+ righttack ;
  righttack   ::= "‚ä¢" | "!" "-" ;          -- RIGHT_TACK: ‚ä¢ or !-
  datacons    ::= datacon* ;
  datacon     ::= "|" dataconname dataconargs constraints? ;
  dataconname ::= ident | "*" | "‚òÖ" | "‚òÜ" | "Œµ" | "Œ∑" ;
  dataconargs ::= dataconarg* ;
  dataconarg  ::= "(" ident+ ":" expr ")" ;

-----------------------------------------------------
-- Expressions (priority: low to high)
-----------------------------------------------------
piece Expr
  expr       ::= lam 
               | lamstar
               | lampair
               | lamelim
               | letin 
               | coeexpr 
               | compexpr 
               | hcomexpr
               | vproj
               | piexpr 
               | sigmaexpr
               | arrowexpr
               | appexpr ;

-----------------------------------------------------
-- Lambda Expressions with Patterns
-- Œª x y ‚Üí body  or  Œª (x : A) ‚Üí body
-- Binders can be:
--   - simple: x, _, *
--   - typed: (x : A), (x y : A)
--   - tuple pattern: (x, y), (a, b, c), ((x, y), z)
--   - nested patterns: (x, (y, z))
-----------------------------------------------------
piece Lambda
  lam        ::= "Œª" binders "‚Üí" expr ;
  lamstar    ::= "Œª" "*" "‚Üí" expr ;         -- Lambda with wildcard
  lampair    ::= "Œª" "[" "," "]" "‚Üí" expr ; -- Pattern lambda for pairs
  lamelim    ::= "Œª" "[" elimcases "]" ;    -- Inline eliminator
  binders    ::= binder+ ;
  binder     ::= "(" ident+ ":" expr ")"    -- typed: (x : A)
               | "(" pattern ("," pattern)* ")"  -- tuple: (x), (x, y)
               | "[" pattern "," "]"             -- bite: [x,]
               | "[" "," "]"                     -- split: [,]
               | bindername | "_" | "*" ;
  -- bindername allows compound names like x+y'/le/m (IH references as binders)
  bindername ::= ident bindernameplus? ;
  bindernameplus ::= "+" ident | "+" number ;
  -- Pattern for tuple binders, allowing nesting like (f,(g,Œ±),h,Œ≤)
  pattern    ::= "(" pattern ("," pattern)* ")"
               | ident | "_" | "*"
               | "[" pattern "," "]" 
               | "[" "," "]" ;

-----------------------------------------------------
-- Let Expressions
-- let x : A = M in N  OR  let f (x : A) : B = M in N
-- let (x, y) = M in N  (pattern matching)
-- let names can include arrows: u‚Üíinner, notf2‚Üítf2
-----------------------------------------------------
piece Let
  letin      ::= "let" letpat binders? (":" expr)? "=" letinvalue "in" expr ;
  letpat     ::= "(" pattern ("," pattern)* ")" | letname ;
  -- letname allows arrows in let bindings: u‚Üíinner
  letname    ::= ident letnamesuffix* ;
  letnamesuffix ::= "‚Üí" ident | "‚Üí" ;
  letinvalue ::= letin | lam | lamstar | lampair | lamelim | compexpr | hcomexpr | coeexpr | piexpr | sigmaexpr | arrowexpr | appexpr ;

-----------------------------------------------------
-- Pi and Sigma Types
-- Pi:    (x : A) ‚Üí B  or  (x : A) (y : B) ‚Üí C
-- Sigma: (x : A) √ó B  or  A √ó B
-----------------------------------------------------
piece Types
  piexpr     ::= picell+ "‚Üí" expr ;
  picell     ::= "(" ident+ ":" expr ")" ;
  sigmaexpr  ::= "(" ident ":" expr ")" "√ó" expr ;
  arrowexpr  ::= appexpr "‚Üí" expr 
               | appexpr "√ó" expr 
               | appexpr ;

-----------------------------------------------------
-- Application and Projections
-- f x y z  (application)
-- M.fst  M.snd  M.vproj  (projections)
-- Projections can be interleaved: f x .fst y .snd
-----------------------------------------------------
piece Application
  appexpr    ::= projexpr appitem* ;
  appitem    ::= projsuffix | projexpr ;
  projexpr   ::= atom projsuffix* ;
  projsuffix ::= "." ident | levelspec ;

-----------------------------------------------------
-- Atomic Expressions
-----------------------------------------------------
piece Atoms
  atom       ::= "(" expr ")"
               | pair
               | pathtype
               | rawterm
               | hole
               | namedhole
               -- Universe levels
               | "type" levelspec?
               | "ùïÄ"                       -- The interval type
               | "pre" levelspec?
               | "kan" levelspec?
               | "cof"
               -- Path operations
               | pathsugar
               | pathdsugar
               | "refl"
               -- Fiber and Equivalence Types (HoTT)
               | fibertype
               | isequiv
               | equivtype
               | idequiv
               | isotoequiv
               -- h-level predicates
               | "is-contr" levelspec?
               | "is-prop" levelspec?
               | "is-set" levelspec?
               | "has-hlevel"
               -- V-types (univalence)
               | vtype
               | vin
               -- Function extensionality and path operations
               | "trans"
               | "symm"
               | symmfiller
               | funext
               | apd
               | "ap"
               | "cong"
               -- Square types (2D paths)
               | squaretype
               -- Connection maps (Kan operations)
               | connectionor
               | connectionand
               | connectionboth
               | weakconnor
               | weakconnand
               -- Eliminators
               | elimexpr
               | boxexpr
               | capexpr
               -- Meta/ML
               | runml
               -- Base cases
               | "_"
               | number
               | ihident
               | ident
               | "*" | "‚òÖ" | "‚òÜ" ;
  pair       ::= "(" expr ("," expr)+ ")" ;
  hole       ::= "?" ;
  namedhole  ::= "?" ident ;
  -- Compound identifiers (IH references): m+n, n+0, m-n, predl~predr
  -- Note: allows ident+number (n+0) and ident+ident (m+n)
  ihident    ::= ident "~" ident | ident "+" number | ident "+" ident | ident "-" ident ;

-----------------------------------------------------
-- Path Types
-- path A M N  (sugar for [_] A [0 ‚Üí M | 1 ‚Üí N])
-- pathd (Œª i ‚Üí A i) M N (dependent path)
-- [i] A [| i=0 ‚Üí M | i=1 ‚Üí N] (extension type)
-----------------------------------------------------
piece PathTypes
  pathtype   ::= "[" dimvars "]" arrowexpr constraints? ;
  pathsugar  ::= "path" levelspec? projexpr projexpr projexpr ;
  pathdsugar ::= "pathd" projexpr projexpr projexpr ;
  dimvars    ::= ident+ ;
  -- constraints: [| clause | clause | ... ]
  -- A cofib is a disjunction: face | face | ...
  constraints   ::= "[" "|"? cofibclause ("|" cofibclause)* "]" ;
  cofibclause   ::= faceor* face ident? "‚Üí" expr 
                  | faceor* face ;
  faceor        ::= face "|" ;
  face          ::= ident "=" dimexpr 
                  | "‚àÇ" "[" dimvars "]"           -- boundary: ‚àÇ[i j]
                  | "boundary" "[" dimvars "]"    -- keyword form
                  | "(" faceor* face ")" ;        -- grouped face
  dimexpr       ::= number | ident ;
  iterm         ::= number | ident ;

-----------------------------------------------------
-- Cubical Operations
-- coe r r' a in Œª i ‚Üí A  (coercion/transport)
-- comp r r' a [| œÜ ‚Üí u]  (composition)
-- hcom r r' a [| œÜ ‚Üí u]  (homogeneous composition)
-----------------------------------------------------
piece Cubical
  coeexpr    ::= "coe" projexpr projexpr projexpr "in" expr ;
  compexpr   ::= "comp" projexpr projexpr projexpr "in" expr constraints 
               | "comp" projexpr projexpr projexpr constraints ;
  hcomexpr   ::= "hcom" projexpr projexpr projexpr "in" expr constraints
               | "hcom" projexpr projexpr projexpr constraints ;

-----------------------------------------------------
-- Universe and Type Levels
-- type^n : universe at level n
-----------------------------------------------------
piece Universe
  levelspec  ::= "^" number ;

-----------------------------------------------------
-- V-Types (Univalence Primitive)
-- V i A B e : the "glue" type for univalence
-- When i=0, V i A B e ‚â° A
-- When i=1, V i A B e ‚â° B
-----------------------------------------------------
piece VTypes
  vtype      ::= "V" projexpr projexpr projexpr projexpr ;
  vin        ::= "vin" projexpr projexpr projexpr ;
  vproj      ::= "vproj" projexpr projexpr projexpr projexpr projexpr ;

-----------------------------------------------------
-- Fiber and Equivalence Types (HoTT Core)
-- fiber f b = (a : A) √ó path B (f a) b
-- is-equiv f = (b : B) ‚Üí is-contr (fiber A B f b)
-- equiv A B = (f : A ‚Üí B) √ó is-equiv A B f
-----------------------------------------------------
piece EquivTypes
  fibertype  ::= "fiber" projexpr projexpr projexpr projexpr ;
  isequiv    ::= "is-equiv" projexpr projexpr projexpr ;
  equivtype  ::= "equiv" projexpr projexpr ;
  idequiv    ::= "id-equiv" projexpr ;
  isotoequiv ::= "iso‚Üíequiv" projexpr projexpr projexpr ;

-----------------------------------------------------
-- Function Extensionality and Apd
-- funext : ((x : A) ‚Üí path B (f x) (g x)) ‚Üí path (A ‚Üí B) f g
-- apd : dependent application to paths
-----------------------------------------------------
piece FunExtApd
  funext     ::= "funext" levelspec? projexpr ;
  apd        ::= "apd" projexpr projexpr ;

-----------------------------------------------------
-- Connection Maps (Cubical Kan Operations)
-- These give the "and" and "or" on the interval
-- Essential for proving path compositions
-----------------------------------------------------
piece Connections
  -- connection/or : [i j] A [j=0 | i=j ‚Üí p i | j=1 | i=1 ‚Üí p 1 | i=0 ‚Üí p j]
  connectionor   ::= "connection/or" projexpr projexpr ;
  -- connection/and : [i j] A [j=0 | i=0 ‚Üí p 0 | j=1 | i=j ‚Üí p i | i=1 ‚Üí p j]
  connectionand  ::= "connection/and" projexpr projexpr ;
  -- connection/both : both directions
  connectionboth ::= "connection/both" projexpr projexpr projexpr ;
  -- Weak connections for composition boundaries
  weakconnor     ::= "weak-connection/or" projexpr projexpr ;
  weakconnand    ::= "weak-connection/and" projexpr projexpr ;
  -- Symmetry filler for inverting paths
  symmfiller     ::= "symm/filler" projexpr projexpr projexpr projexpr ;

-----------------------------------------------------
-- Square Types (2-dimensional paths)
-- square A a00 a01 a10 a11 p0- p1- p-0 p-1
-- A 2D path with 4 corners and 4 edges
-- Essential for reasoning about path composition
-----------------------------------------------------
piece SquareTypes
  squaretype ::= "square" projexpr projexpr projexpr projexpr projexpr projexpr projexpr projexpr projexpr ;

-----------------------------------------------------
-- Eliminators: elim [| case ‚Üí body | ...]
--              elim term [| case ‚Üí body | ...]
--              elim term in motive [| case ‚Üí body | ...]
--              elim with | case ‚Üí body end
-----------------------------------------------------
piece Eliminators
  elimexpr   ::= "elim" atom? elimmotive? elimblock ;
  elimmotive ::= "in" expr ;
  elimblock  ::= "[" elimcases "]" 
               | "with" elimcases "end" ;
  elimcases  ::= elimfirst? elimcase* ;
  elimfirst  ::= elimpat "‚Üí" expr ;
  elimcase   ::= "|" elimpat "‚Üí" expr ;
  -- Symbols like ‚òÜ, Œ∑ can have arguments just like regular constructors
  elimpat    ::= ident elimpatargs? | "*" | "‚òÖ" elimpatargs? | "‚òÜ" elimpatargs? | "Œµ" | "Œ∑" elimpatargs? ;
  elimpatargs ::= elimpatarg* ;
  elimpatarg ::= "(" elimpat ("‚Üí" ihbinding)? ")" | elimpat ;
  -- IH bindings: n+0 uses number, m+n uses ident
  ihbinding  ::= ident "+" number | ident "+" ident | ident "-" ident | ident ;

-----------------------------------------------------
-- Box and Cap (Glue type operations)
-- box term with | œÜ ‚Üí u end
-- cap term with | œÜ ‚Üí u end
-----------------------------------------------------
piece BoxCap
  boxexpr    ::= "box" projexpr "with" elimcases "end" ;
  capexpr    ::= "cap" projexpr "with" elimcases "end" ;

-----------------------------------------------------
-- Raw Terms: `(sexpr ...)
-- Backtick injects raw/internal term syntax
-- Used when the surface syntax can't express something
-----------------------------------------------------
piece RawTerms
  rawterm    ::= "`" "(" sexprlist ")" ;
  sexpr      ::= ident | number | "@" | "(" sexprlist ")" ;
  sexprlist  ::= sexpr* ;

-----------------------------------------------------
-- Run ML (embedded ML in expressions)
-- ‚¶â mlcmd ‚¶ä (embedded tactic/ML)
-----------------------------------------------------
piece RunML
  runml      ::= ltr mlcmd rtr ;

-----------------------------------------------------
-- Derived Operations for Redtt
-----------------------------------------------------

derive subst for expr with binders = [lam, let, pi, sg, path, ext] ;
derive normalize for expr with fuel = 1000 ;
derive cata for expr ;

-----------------------------------------------------
-- =====================================================
-- TRANSFORMATION RULES: Surface AST ‚Üí Core IR
-- =====================================================
-- These rules transform the parsed surface syntax into
-- an internal representation suitable for type checking
-- and reduction.
--
-- The transformation follows the bidirectional approach:
--   - Checking mode: term ‚áê type
--   - Inference mode: term ‚áí type
--
-- Architecture (from redtt):
--   Surface (ML.econ) ‚Üí Core (Tm.tm) ‚Üí Domain (value) ‚Üí Core (normalized)
-----------------------------------------------------

-----------------------------------------------------
-- Core IR Constructors
-- These are the target of our transformation rules
-----------------------------------------------------
-- Type formers:
--   (Univ kind lvl)        -- universe type^lvl
--   (Pi dom cod)           -- (x : A) ‚Üí B  
--   (Sg dom cod)           -- (x : A) √ó B
--   (Ext dims ty sys)      -- extension types [i] A [sys]
--   (Path A a b)           -- path types (sugar for Ext)
--   (V r ty0 ty1 equiv)    -- V-types (univalence)
--   (Data lbl params)      -- inductive data type
--
-- Introduction forms:
--   (Lam x body)           -- Œª x. e
--   (ExtLam xs body)       -- Œª [i j]. e  
--   (Cons a b)             -- (a, b)
--   (Refl a)               -- reflexivity proof
--   (VIn r tm0 tm1)        -- V-type intro
--   (Box r r' cap sys)     -- box (comp intro)
--   (Intro dlbl clbl args) -- data constructor
--
-- Elimination forms:
--   (App f x)              -- f x
--   (ExtApp f dims)        -- f @i @j
--   (Fst p)                -- p.fst
--   (Snd p)                -- p.snd
--   (Elim scrut mot cls)   -- elim scrut [in mot] clauses
--   (VProj v)              -- v.vproj
--   (Cap v)                -- v.cap
--
-- Kan operations:
--   (Coe r r' ty tm)       -- coercion
--   (HCom r r' ty cap sys) -- homogeneous composition
--   (Com r r' ty cap sys)  -- heterogeneous composition
--
-- Variables:
--   (Var name)             -- named variable
--   (Ix n)                 -- de Bruijn index
--   (Meta name)            -- metavariable/hole
-----------------------------------------------------

-----------------------------------------------------
-- Œ≤-reduction rules (Core ‚Üí Core)
-----------------------------------------------------
-- Function application
rule beta-lam: (App (Lam $x $body) $arg) ~~> (subst $body $x $arg) ;

-- Pair projections
rule beta-fst: (Fst (Cons $a $b)) ~~> $a ;
rule beta-snd: (Snd (Cons $a $b)) ~~> $b ;

-- Let binding (inline)
rule beta-let: (Let $x $val $body) ~~> (subst $body $x $val) ;

-- Extension application at endpoints
rule beta-extapp-0: (ExtApp (ExtLam $i $body) (Dim0)) ~~> (subst $body $i (Dim0)) ;
rule beta-extapp-1: (ExtApp (ExtLam $i $body) (Dim1)) ~~> (subst $body $i (Dim1)) ;

-----------------------------------------------------
-- Kan operation computation rules
-----------------------------------------------------
-- Coercion at same point is identity
rule coe-refl: (Coe $r $r $ty $tm) ~~> $tm ;

-- HCom at same point is cap
rule hcom-refl: (HCom $r $r $ty $cap $sys) ~~> $cap ;

-- Coercion through constant type is identity
rule coe-const: (Coe $r $r' (const $A) $tm) ~~> $tm ;

-----------------------------------------------------
-- Path computation rules
-----------------------------------------------------
-- Path application to refl
rule path-app-refl: (ExtApp (Refl $a) $r) ~~> $a ;

-- Path endpoints
rule path-0: (ExtApp (ExtLam $i $body) (Dim0)) ~~> (subst $body $i (Dim0)) ;
rule path-1: (ExtApp (ExtLam $i $body) (Dim1)) ~~> (subst $body $i (Dim1)) ;

-----------------------------------------------------
-- V-type computation (univalence)
-----------------------------------------------------
-- V at 0 gives ty0
rule v-0: (V (Dim0) $ty0 $ty1 $equiv) ~~> $ty0 ;

-- V at 1 gives ty1  
rule v-1: (V (Dim1) $ty0 $ty1 $equiv) ~~> $ty1 ;

-- VIn at 0 gives tm0
rule vin-0: (VIn (Dim0) $tm0 $tm1) ~~> $tm0 ;

-- VIn at 1 gives tm1
rule vin-1: (VIn (Dim1) $tm0 $tm1) ~~> $tm1 ;

-----------------------------------------------------
-- Data elimination rules
-----------------------------------------------------
-- Elim Intro computes to clause body
rule elim-intro: (Elim (Intro $dlbl $clbl $args) $mot $clauses) ~~>
  (apply-clause (lookup $clbl $clauses) $args) ;

-----------------------------------------------------
-- Tests
-----------------------------------------------------
test "import simple": (import prelude) ;
test "import path": (import prelude path) ;
test "def simple": (def id x x) ;
test "def typed": (def id (x COLON A) COLON A x) ;

-- =============================================================================
-- TODO: Executable Language Checklist for Redtt
-- Category: Cubical Type Theory (redtt/cooltt style)
-- Current: 23 pieces, 111 productions, 99.7% parse rate (731/733)
-- Source: RedPRL/redtt, RedPRL/cooltt
-- =============================================================================
-- [x] Grammar: 111 productions across 23 pieces
-- [x] Parse rate: 731/733 (99.7%) on redtt library
-- [x] Cross-piece references: Parse-time name resolution
-- [x] Unicode names in definitions: p‚Üí, binnat‚Üínat  
-- [x] Unicode names in let bindings: u‚Üíinner, notf2‚Üítf2
-- [x] Compound IH names: n+0, m+n in binders and expressions
-- [ ] Normalization: Full path/coe computation
-- [ ] Confluence: Verify cubical reduction confluence
-- =============================================================================
-- Remaining parse issues (2 files):
-- - gcd.red: Very deep nesting causes parser performance issues
-- - univalence.red: Complex nested let/comp expressions
-- These are performance issues, not grammar issues.
-- =============================================================================
-- Missing for full executability:
--
-- 1. PATH COMPUTATION
--    - Full path application: (@ p r) where r is dimension expression
--    - Path abstraction intro/elim
--    - Reflexivity: refl a : path A a a
--    - Symmetry: symm p : path A b a when p : path A a b
--    - Transitivity: trans p q : path A a c
--
-- 2. COE/TRANSPORT
--    - coe r r' a in A - full computation with type formers
--    - coe through Œ†: coe (Œ† A B) = Œªx. coe B (coe A‚Åª¬π x)
--    - coe through Œ£: coe (Œ£ A B) = (coe A fst, coe B snd)
--    - coe through path types
--
-- 3. HCOM (Homogeneous Composition)
--    - hcom r r' a [œÜ ‚Üí u] - compose with boundary
--    - Face lattice operations: ‚àß, ‚à®, ~
--    - Kan filling conditions
--
-- 4. HIGHER INDUCTIVE TYPES
--    - S¬π (circle): base, loop
--    - S¬≤ (sphere): base, surf  
--    - T¬≤ (torus): pt, p, q, f
--    - Suspension, Pushouts
--    - Path constructors compute on endpoints
--
-- 5. V TYPES (Univalence)
--    - V i A B e : glue type
--    - Compute at 0/1: V 0 A B e ‚â° A, V 1 A B e ‚â° B
--    - ua : equiv A B ‚Üí path type A B
--
-- 6. PATTERN LAMBDAS (from cooltt)
--    - Œª [,] ‚Üí body (pair pattern)
--    - Œª [| case ‚Üí body] (inline elim)
--
-- REFERENCE IMPLEMENTATIONS:
--   - RedPRL/redtt: src/core/*.ml (reduction rules)
--   - RedPRL/cooltt: src/core/*.ml (newer implementation)
--   - test/elab.cooltt, test/path.cooltt (examples)
-- =============================================================================

derive eq for expr ;
