-----------------------------------------------------
-- Cooltt: A modular parser for cooltt (.cooltt) files
--
-- Grammar for parsing .cooltt files from the cooltt library.
-- Organized into logical pieces for maintainability.
-- Cross-piece references work via parse-time name resolution.
--
-- Based on: https://github.com/RedPRL/cooltt
--
-- cooltt is a proof assistant implementing cartesian cubical type theory
-- with higher inductive types (circle, nat), records, sections,
-- and sophisticated module system.
--
-- Key features:
-- - Cartesian cubical type theory with interval ùïÄ
-- - Extension types: ext i => A with [i=0 => a | i=1 => b]
-- - Sub types: sub A œÜ a
-- - V types for univalence
-- - First-class records (sig/struct) with patches
-- - Equational reasoning proofs
-- - Module sections with views/exports/repacks
-----------------------------------------------------

lang Cooltt :=

-----------------------------------------------------
-- Token: Character-level lexer for CoolTT files
-----------------------------------------------------

token Token
  -- Character classes
  digit  ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;
  lower  ::= 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j'
           | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't'
           | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' ;
  upper  ::= 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J'
           | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T'
           | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' ;
  greek  ::= 'Œ±' | 'Œ≤' | 'Œ≥' | 'Œ¥' | 'Œµ' | 'Œ∂' | 'Œ∑' | 'Œ∏' | 'Œπ' | 'Œ∫'
           | 'Œª' | 'Œº' | 'ŒΩ' | 'Œæ' | 'Œø' | 'œÄ' | 'œÅ' | 'œÉ' | 'œÑ' | 'œÖ'
           | 'œÜ' | 'œá' | 'œà' | 'œâ'
           | 'Œë' | 'Œí' | 'Œì' | 'Œî' | 'Œï' | 'Œñ' | 'Œó' | 'Œò' | 'Œô' | 'Œö'
           | 'Œõ' | 'Œú' | 'Œù' | 'Œû' | 'Œü' | 'Œ†' | 'Œ°' | 'Œ£' | 'Œ§' | 'Œ•'
           | 'Œ¶' | 'Œß' | 'Œ®' | 'Œ©' ;
  -- Double-struck letters for type theory
  mathbb ::= 'ùïÄ' | 'ùîΩ' | 'ùïä' ;
  -- Math symbols
  mathsym ::= '‚âà' | '‚âÖ' | '‚â§' | '‚â•' | '‚àò' | '‚äó' | '‚äô' | '‚àß' | '‚à®' | '‚àÇ' ;
  alpha  ::= lower | upper | greek | mathbb | mathsym | '_' ;
  symch  ::= '(' | ')' | '[' | ']' | '{' | '}' | '<' | '>'
           | ':' | ';' | ',' | '.' | '|' | '!' | '?' | '@'
           | '#' | '$' | '%' | '^' | '&' | '*' | '+' | '-'
           | '=' | '~' | '/' | '\\' | '‚Üí' | '‚Üê' | '‚Üî' | '‚äï'
           | '‚ä¢' | '√ó' | 'Œª' | '‚àÄ' | '‚àÉ' | '‚òÖ' | '‚òÜ'
           | '‚¶â' | '‚¶ä' | '¬´' | '¬ª' | '`' ;

  -- Cooltt-specific token patterns
  -- '/' allowed in identifiers for hierarchical names (e.g., trans/filler)
  -- '\'' allowed as suffix for primed identifiers (e.g., symm')
  -- '-' allowed in identifiers (e.g., path-p, coe-fwd)
  ident   ::= alpha (alpha | digit | '-' | '/' | '\'' | '+')* ;
  number  ::= digit digit* ;
  string  ::= '"' strchar* '"' ;
  strchar ::= '\\' escape | printable ;
  escape  ::= '"' | '\\' | 'n' | 't' | 'r' | '\'' ;
  printable ::= alpha | digit | symch | ' ' ;

  -- Whitespace and comments (to skip)
  ws      ::= ' ' | '\t' | '\n' | '\r' ;
  comment ::= '-' '-' nonnl* ;
  nonnl   ::= alpha | digit | symch | ' ' | '\t' | '\'' | '"' ;

  -- Multi-character operators (must be checked BEFORE single sym)
  -- These are ordered longest-first for proper tokenization
  op3     ::= ':' ':' '=' ;        -- ::= (assignment with type)
  op2     ::= ':' '='              -- := (assignment)
            | ':' ':'              -- :: (qualified name separator)
            | '-' '>'              -- -> (arrow)
            | '<' '-'              -- <- (back arrow)
            | '=' '>'              -- => (fat arrow)
            | '{' '!'              -- {! (hole start)
            | '!' '}'              -- !} (hole end)
            | '?' '_' ;            -- ?_ (hole)

  -- Single symbol (fallback)
  sym     ::= symch ;

-----------------------------------------------------
-- File Structure
-----------------------------------------------------
piece File
  file       ::= topdecl* ;
  topdecl    ::= importdecl | defndecl | axiomdecl | printcmd | normcmd 
               | failcmd | debugcmd | quitcmd | sectiondecl | viewdecl 
               | exportdecl | repackdecl | abstractmod | unfoldmod ;

-----------------------------------------------------
-- Imports: import path.to.module [modifier]
-----------------------------------------------------
piece Imports
  importdecl ::= "import" modulepath bracketmod? ;
  modulepath ::= name ("." name)* ;
  name       ::= ident | "def" | "import" | "with" | "let" | "in" | "elim" | "type" 
               | "nat" | "circle" | "sig" | "struct" | "begin" | "end" | "+" | "-" ;

-----------------------------------------------------
-- Definitions: def name (args) : type := body
-----------------------------------------------------
piece Definitions
  defndecl   ::= modifiers? "def" defname telecells? ":" expr ":=" expr ;
  defname    ::= opname | path ;
  opname     ::= "+" | "-" | "*" ;
  path       ::= name ("::" name)* ;
  telecells  ::= telecell+ ;
  telecell   ::= "(" names ":" expr ")" ;
  names      ::= name+ ;
  
  modifiers  ::= modifier+ ;
  modifier   ::= "shadowing" | "abstract" | unfoldspec ;
  -- unfoldspec uses unfoldnames; keywords become sym tokens via vocab
  -- so ident will NOT match "abstract", "def", etc.
  unfoldspec ::= "unfold" unfoldnames ;
  unfoldnames ::= unfoldname+ ;
  -- unfoldname matches identifiers (but not keywords which are sym tokens)
  -- and operators like + -
  unfoldname ::= ident | "+" | "-" | ident "::" unfoldname ;
  
  -- Standalone modifiers (appear as separate "declarations")
  abstractmod ::= "abstract" ;
  unfoldmod   ::= "unfold" unfoldnames ;

-----------------------------------------------------
-- Axioms: axiom name (args) : type
-----------------------------------------------------
piece Axioms
  axiomdecl  ::= modifiers? "axiom" defname telecells? ":" expr ;

-----------------------------------------------------
-- Commands
-----------------------------------------------------
piece Commands
  printcmd   ::= "#print" name ;
  normcmd    ::= "#normalize" expr ;
  failcmd    ::= "#fail" topdecl ;
  debugcmd   ::= "#debug" flag ;
  quitcmd    ::= "#quit" ;
  flag       ::= "on" | "off" ;

-----------------------------------------------------
-- Module System: section, view, export, repack
-----------------------------------------------------
piece ModuleSystem
  sectiondecl ::= modifiers "section" path? "begin" topdecl* "end" bracketmod? ;
  viewdecl    ::= modifiers "view" bracketmod ;
  exportdecl  ::= modifiers "export" bracketmod
                | modifiers "export" path ;
  repackdecl  ::= modifiers "repack" bracketmod ;
  
  bracketmod  ::= "[" moditems "]" | "{" moditems "}" ;
  moditems    ::= moditem? | moditem (";" moditem)* | moditem ("," moditem)* ;
  moditem     ::= "::" | path "::" atomicmod | path ("->" | "‚Üí") path? | ("->" | "‚Üí") path 
                | "!" path? | path | atomicmod ;
  atomicmod   ::= bracketmod | "!" "::"? | hole ;

-----------------------------------------------------
-- Expressions (priority: low to high)
-- Note: Arrow/product parsed after appexpr to avoid left recursion
-- IMPORTANT: Order matters for performance!
--   Check keyword-triggered expressions first (fast fail on first token)
--   Then fall back to arrowexpr (most common case for identifiers)
-----------------------------------------------------
piece Expr
  expr       ::= letexpr       -- starts with "let"
               | openexpr      -- starts with "open"
               | generalize    -- starts with "generalize"
               | unfoldexpr    -- starts with "unfold"
               | abstractexpr  -- starts with "abstract"
               | elimexpr      -- starts with "elim"
               | piexpr        -- starts with "("
               | sigmaexpr     -- starts with "("
               | lambda        -- starts with name followed by "=>"
               | arrowexpr ;   -- everything else (identifiers, apps, etc)

-----------------------------------------------------
-- Lambda and Eliminators
-----------------------------------------------------
piece Lambda
  lambda     ::= names "=>" expr ;
  elimexpr   ::= "elim" atomicexpr? motive? "with"? cases
               | "elim" cases ;
  motive     ::= "as" atomicexpr ;
  cases      ::= "[" caseopt* "]" ;
  caseopt    ::= "|"? case ;
  case       ::= pattern "=>" expr ;
  pattern    ::= patlabel patargs? ;
  patlabel   ::= "zero" | "suc" | "base" | "loop" | path ;
  patargs    ::= patarg* ;
  patarg     ::= name | "{" name "=>" name "}" ;

-----------------------------------------------------
-- Let, Open, Generalize, Unfold, Abstract
-----------------------------------------------------
piece Binding
  letexpr    ::= "let" name ":" expr ":=" expr "in" expr
               | "let" name ":=" expr "in" expr ;
  openexpr   ::= "open" expr renaming? "in" expr ;
  generalize ::= "generalize" name "in" expr ;
  unfoldexpr ::= "unfold" names "in" expr ;
  abstractexpr ::= "abstract" name? "<-" expr ;
  renaming   ::= "renaming" "[" renamelist "]" ;
  renamelist ::= renamepair (";" renamepair)* ;
  renamepair ::= path ("->" | "‚Üí") path ;

-----------------------------------------------------
-- Pi, Sigma, and Arrow Types
-- Uses appexpr as base to avoid left recursion
-- Accepts both -> and ‚Üí for arrows
-----------------------------------------------------
piece Types
  piexpr     ::= telecells ("->" | "‚Üí") expr ;
  sigmaexpr  ::= telecells ("*" | "√ó") expr ;
  arrowexpr  ::= appexpr (("->" | "‚Üí") expr)? (("*" | "√ó") expr)? ;

-----------------------------------------------------
-- Application
-----------------------------------------------------
piece Application
  appexpr    ::= atomicexpr atomicexpr*
               | "suc" atomicexpr
               | "loop" atomicexpr
               | "fst" atomicexpr
               | "snd" atomicexpr
               | "vproj" atomicexpr
               | "cap" atomicexpr ;

-----------------------------------------------------
-- Atomic Expressions
-----------------------------------------------------
piece Atomic
  atomicexpr ::= var | literal | parenexpr | bracketexpr | braceexpr
               | bangbracket | hole | underscore | builtin
               | sigtype | structexpr | extexpr | subexpr
               | coeexpr | hcomexpr | hfillexpr | comexpr | vexpr
               | equationexpr | patchexpr | projexpr ;
  
  var        ::= path ;
  underscore ::= "_" ;
  literal    ::= number ;
  parenexpr  ::= "(" expr ")" ;
  bracketexpr ::= "[" bracketcontent "]" ;
  braceexpr  ::= "{" expr "}" ;
  bangbracket ::= "{!" expr? "!}" ;
  
  bracketcontent ::= pairexpr | cofsplit | prfexpr ;
  pairexpr   ::= expr "," expr ;
  cofsplit   ::= "|"? cofcase ("|" cofcase)* ;
  cofcase    ::= cof "=" ">" expr ;
  prfexpr    ::= expr ;

-----------------------------------------------------
-- Holes
-----------------------------------------------------
piece Holes
  hole       ::= "?" holename? | "?_" holename? ;
  holename   ::= ident ;

-----------------------------------------------------
-- Built-in Types
-----------------------------------------------------
piece Builtins
  builtin    ::= "type" | dimtype | coftype | "nat" | "circle"
               | "zero" | "base" | topcof | botcof | "#viz" ;
  dimtype    ::= "dim" | "ùïÄ" ;
  coftype    ::= "cof" | "ùîΩ" ;
  topcof     ::= "true" | "‚ä§" ;
  botcof     ::= "false" | "‚ä•" ;

-----------------------------------------------------
-- Cofibrations
-----------------------------------------------------
piece Cofibrations
  cof        ::= atomiccof | joincof | meetcof ;
  atomiccof  ::= cofeq | cofle | cofbdry | atomicexpr ;
  cofeq      ::= atomicexpr "=" atomicexpr ;
  cofle      ::= atomicexpr "<=" atomicexpr
               | atomicexpr "‚â§" atomicexpr ;
  cofbdry    ::= "‚àÇ" atomicexpr ;
  joincof    ::= atomiccof ("\\/" | "‚à®") atomiccof+ ;
  meetcof    ::= atomiccof ("/\\" | "‚àß") atomiccof+ ;

-----------------------------------------------------
-- Extension Types
-----------------------------------------------------
piece ExtTypes
  extexpr    ::= "ext" names? "=" ">" expr "with" extbdy ;
  extbdy     ::= "[" "|"? extcase ("|" extcase)* "]" ;
  extcase    ::= cof "=" ">" expr ;

-----------------------------------------------------
-- Sub Types
-----------------------------------------------------
piece SubTypes
  subexpr    ::= "sub" atomicexpr atomicexpr atomicexpr ;

-----------------------------------------------------
-- Cubical Operations
-----------------------------------------------------
piece CubicalOps
  coeexpr    ::= "coe" atomicexpr atomicexpr atomicexpr atomicexpr ;
  hcomexpr   ::= "hcom" atomicexpr atomicexpr atomicexpr atomicexpr atomicexpr
               | "hcom" atomicexpr atomicexpr atomicexpr ;
  hfillexpr  ::= "hfill" atomicexpr atomicexpr atomicexpr atomicexpr
               | "hfill" atomicexpr atomicexpr ;
  comexpr    ::= "com" atomicexpr atomicexpr atomicexpr atomicexpr atomicexpr ;

-----------------------------------------------------
-- V Types
-----------------------------------------------------
piece VTypes
  vexpr      ::= "V" atomicexpr atomicexpr atomicexpr atomicexpr ;

-----------------------------------------------------
-- Records: sig and struct
-----------------------------------------------------
piece Records
  sigtype    ::= "sig" sigbody ;
  sigbody    ::= sigfields "end" | "[" barefieldspecs? "]" ;
  sigfields  ::= sigfield* ;
  sigfield   ::= "def" barefielddspec | "include" expr renaming? ;
  barefielddspec ::= path ":" expr ;
  barefieldspecs ::= barefielddspec ("," barefielddspec)* ;
  
  structexpr ::= "struct" structbody ;
  structbody ::= structfields "end" | "[" barefields? "]" ;
  structfields ::= structfield* ;
  structfield ::= "def" barefield | "include" expr renaming? ;
  barefield  ::= path ":=" expr ;
  barefields ::= barefield ("," barefield)* ;
  
  patchexpr  ::= expr "#" "[" patches "]" ;
  patches    ::= patch ("," patch)* ;
  patch      ::= path ":=" expr | path "::=" expr ;
  
  projexpr   ::= expr "." name ;

-----------------------------------------------------
-- Equations (Stepped Proofs)
-----------------------------------------------------
piece Equations
  equationexpr ::= "equation" expr "begin" eqnsteps "end" ;
  eqnsteps   ::= eqnstep* eqnfinal ;
  eqnstep    ::= expr "=[" expr "]" | expr "=[]" ;
  eqnfinal   ::= expr ;

-----------------------------------------------------
-- Constraints (for extensions, sub types)
-----------------------------------------------------
piece Constraints
  constraints ::= "[" "|"? constraint ("|" constraint)* "]" ;
  constraint  ::= cof "=" ">" expr ;

