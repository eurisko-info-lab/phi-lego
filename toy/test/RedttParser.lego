-----------------------------------------------------
-- RedttParser: A parser for redtt (.red) files
--
-- Grammar for parsing .red files from the redtt library.
-- Handles imports, definitions, data types, path types,
-- cubical operations (coe, comp, hcom), and more.
--
-- Based on: https://github.com/RedPRL/redtt
--
-- Adapted for Bootstrap parser:
-- - Single piece (no cross-piece references)  
-- - Use ? for optionals
-- - Productions end with ;
--
-- Ported from Haskell's Redtt.lego (99 rules)
-----------------------------------------------------

lang RedttParser :=

piece Redtt
  -----------------------------------------------------
  -- File Structure
  -----------------------------------------------------
  file       ::= topdecl* ;
  topdecl    ::= importdecl | defndecl | datadecl ;
  
  -----------------------------------------------------
  -- Imports: public? import path.to.module
  -- Module paths can have dots: data.bool, prelude.path
  -- NOTE: 'data' is tokenized as symbol, so we accept name (ident or keyword)
  -----------------------------------------------------
  importdecl ::= "public"? "import" modulepath ;
  modulepath ::= name ("." name)* ;
  name       ::= ident | "data" | "def" | "import" | "public" | "where" | "let" | "in" | "elim" ;
  
  -----------------------------------------------------
  -- Definitions: def name (args) : type = body
  -- Names can contain arrows: binnat‚Üínat, nat‚Üíbinnat‚Üínat
  -----------------------------------------------------
  defndecl   ::= "def" defname defargs (":" expr)? "=" expr ;
  defname    ::= ident ("‚Üí" ident)* ;
  defargs    ::= defarg* ;
  defarg     ::= "(" ident+ ":" expr ")" | ident ;
  
  -----------------------------------------------------
  -- Data Types (Higher Inductive Types)
  -- data Name where | Con1 | Con2 (x : A) | ...
  -- (A : type) ‚ä¢ data Name where ...  (parameterized)
  -- (A B : type) ‚ä¢ data Name where ...  (multiple params)
  -----------------------------------------------------
  datadecl   ::= dataparams? "data" ident "where" datacons ;
  dataparams ::= picell+ "‚ä¢" ;
  datacons   ::= datacon* ;
  datacon    ::= "|" ident dataconargs databdy? ;
  dataconargs ::= dataconarg* ;
  dataconarg ::= "(" ident ":" expr ")" ;
  databdy    ::= "[" databdyconstr ("|" databdyconstr)* "]" ;
  databdyconstr ::= ident "=" dimexpr "‚Üí" expr ;
  
  -----------------------------------------------------
  -- Expressions (priority: low to high)
  -----------------------------------------------------
  expr       ::= lam 
               | lamstar
               | lampair
               | lampairbind
               | lampairwild
               | lamelim
               | letin 
               | coeexpr 
               | compexpr 
               | hcomexpr
               | piexpr 
               | sigmaexpr
               | arrowexpr
               | appexpr ;
  
  -----------------------------------------------------
  -- Lambda: Œª x y ‚Üí body  or  Œª (x : A) ‚Üí body
  -----------------------------------------------------
  lam        ::= "Œª" binders "‚Üí" expr ;
  lamstar    ::= "Œª" "*" "‚Üí" expr ;
  binders    ::= binder+ ;
  binder     ::= "(" ident+ ":" expr ")" | ident | "_" | "*" ;
  
  -----------------------------------------------------
  -- Pattern Lambdas (from cooltt)
  --   Œª [,] ‚Üí body      matches pair structure
  --   Œª (x, y) ‚Üí body   binds components  
  --   Œª (*, *) ‚Üí body   wildcard pair
  --   Œª [| case ‚Üí ...]  inline eliminator
  -----------------------------------------------------
  lampair     ::= "Œª" "[" "," "]" "‚Üí" expr ;
  lampairbind ::= "Œª" "(" ident "," ident ")" "‚Üí" expr ;
  lampairwild ::= "Œª" "(" "*" "," "*" ")" "‚Üí" expr ;
  lamelim     ::= "Œª" "[" elimcases "]" ;
  
  -----------------------------------------------------
  -- Let: let x : A = M in N  OR  let f (x : A) : B = M in N
  --      let (x, y) = M in N  (pattern matching)
  -----------------------------------------------------
  letin      ::= "let" letpat binders? (":" expr)? "=" expr "in" expr ;
  letpat     ::= "(" ident ("," ident)+ ")" | ident ;
  
  -----------------------------------------------------
  -- Path Types
  -- path A M N  (sugar for [_] A [0 ‚Üí M | 1 ‚Üí N])
  -- pathd (Œª i ‚Üí A i) M N (dependent path)
  -- [i] A [| i=0 ‚Üí M | i=1 ‚Üí N] (extension type)
  -----------------------------------------------------
  pathtype   ::= "[" dimvars "]" arrowexpr constraints? ;
  pathsugar  ::= "path" levelspec? projexpr projexpr projexpr ;
  pathdsugar ::= "pathd" projexpr projexpr projexpr ;
  dimvars    ::= ident+ ;
  
  -- constraints: [| clause | clause | ... ]
  constraints   ::= "[" "|"? clause ("|" clause)* "]" ;
  clause        ::= facelist ident? "‚Üí" expr 
                  | facelist ;
  facelist      ::= face+ ;
  face          ::= ident "=" dimexpr 
                  | "‚àÇ" "[" dimvars "]" ;
  dimexpr       ::= number | ident ;
  
  -----------------------------------------------------
  -- Interval Terms
  -----------------------------------------------------
  iterm      ::= number | ident ;
  
  -----------------------------------------------------
  -- Cubical Operations
  -----------------------------------------------------
  -- coe r r' a in Œª i ‚Üí A
  coeexpr    ::= "coe" projexpr projexpr projexpr "in" expr ;
  
  -- comp r r' a in Œª i ‚Üí T [| œÜ ‚Üí u]
  -- comp r r' a [| œÜ ‚Üí u]
  compexpr   ::= "comp" projexpr projexpr projexpr "in" expr constraints 
               | "comp" projexpr projexpr projexpr constraints ;
  
  -- hcom r r' a in Œª i ‚Üí T [| œÜ ‚Üí u]  
  -- hcom r r' a [| œÜ ‚Üí u]
  hcomexpr   ::= "hcom" projexpr projexpr projexpr "in" expr constraints
               | "hcom" projexpr projexpr projexpr constraints ;
  
  -----------------------------------------------------
  -- Pi Type: (x : A) ‚Üí B  or (x : A) (y : B) ‚Üí C  (multiple cells)
  -----------------------------------------------------
  piexpr     ::= picell+ "‚Üí" expr ;
  picell     ::= "(" ident+ ":" expr ")" ;
  
  -----------------------------------------------------
  -- Sigma Type: (x : A) √ó B  or  A √ó B
  -----------------------------------------------------
  sigmaexpr  ::= "(" ident ":" expr ")" "√ó" expr ;
  
  -----------------------------------------------------
  -- Arrow/Product: A ‚Üí B  or  A √ó B  
  -----------------------------------------------------
  arrowexpr  ::= appexpr "‚Üí" expr 
               | appexpr "√ó" expr 
               | appexpr ;
  
  -----------------------------------------------------
  -- Application: f x y z
  -----------------------------------------------------
  appexpr    ::= projexpr projexpr* ;
  
  -----------------------------------------------------
  -- Projections: M.fst  M.snd  M.vproj  M.cap  M.anything
  -----------------------------------------------------
  projexpr   ::= atom projsuffix* ;
  projsuffix ::= "." ident | levelspec ;
  
  -----------------------------------------------------
  -- Atoms (base expressions)
  -----------------------------------------------------
  atom       ::= "(" expr ")"
               | pair
               | pathtype
               | rawterm
               | hole
               | namedhole
               | "type" levelspec?
               | "ùïÄ"
               | "refl"
               | pathsugar
               | pathdsugar
               | "fiber" 
               | "is-equiv"
               | "equiv"
               | "id-equiv"
               | "iso‚Üíequiv"
               | "is-contr" levelspec?
               | "is-prop" levelspec?
               | "is-set" levelspec?
               | "has-hlevel"
               | vtype
               | vin
               | "trans"
               | "symm"
               | symmfiller
               | "funext"
               | "apd"
               | "ap"
               | "cong"
               | squaretype
               | connectionor
               | connectionand
               | connectionboth
               | weakconnor
               | weakconnand
               | elimexpr
               | boxexpr
               | capexpr
               | "_"
               | number 
               | ident ;
  
  -----------------------------------------------------
  -- Pair/Tuple constructor: (a, b) or (a, b, c, ...)
  -----------------------------------------------------
  pair       ::= "(" expr ("," expr)+ ")" ;
  
  -----------------------------------------------------
  -- Holes: ? or ?name
  -----------------------------------------------------
  hole       ::= "?" ;
  namedhole  ::= "?" ident ;
  
  -----------------------------------------------------
  -- Backtick/Raw Terms: `(sexpr)
  -----------------------------------------------------
  rawterm    ::= "`" "(" sexpr ")" ;
  sexpr      ::= ident | "(" sexprlist ")" ;
  sexprlist  ::= sexpr* ;
  
  -----------------------------------------------------
  -- Universe Levels: type^1, type^2
  -----------------------------------------------------
  levelspec  ::= "^" number ;
  
  -----------------------------------------------------
  -- V Type (Univalence Primitive)
  -- V i A B e : the "glue" type for univalence
  -----------------------------------------------------
  vtype      ::= "V" projexpr projexpr projexpr projexpr ;
  vin        ::= "vin" projexpr projexpr projexpr ;
  
  -----------------------------------------------------
  -- Connection Maps (Cubical Kan Operations)
  -----------------------------------------------------
  connectionor   ::= "connection/or" projexpr projexpr ;
  connectionand  ::= "connection/and" projexpr projexpr ;
  connectionboth ::= "connection/both" projexpr projexpr projexpr ;
  weakconnor     ::= "weak-connection/or" projexpr projexpr ;
  weakconnand    ::= "weak-connection/and" projexpr projexpr ;
  
  -----------------------------------------------------
  -- Symmetry filler
  -----------------------------------------------------
  symmfiller ::= "symm/filler" projexpr projexpr projexpr projexpr ;
  
  -----------------------------------------------------
  -- Square Types (2-dimensional paths)
  -----------------------------------------------------
  squaretype ::= "square" projexpr projexpr projexpr projexpr projexpr projexpr projexpr projexpr projexpr ;
  
  -----------------------------------------------------
  -- Fiber and Equivalence Types
  -----------------------------------------------------
  fibertype  ::= "fiber" projexpr projexpr projexpr projexpr ;
  isequiv    ::= "is-equiv" projexpr projexpr projexpr ;
  equivtype  ::= "equiv" projexpr projexpr ;
  idequiv    ::= "id-equiv" projexpr ;
  isotoequiv ::= "iso‚Üíequiv" projexpr projexpr projexpr ;
  
  -----------------------------------------------------
  -- Eliminators: elim [| case ‚Üí body | ...]
  --              elim term [| case ‚Üí body | ...]
  --              elim with | case ‚Üí body end
  -----------------------------------------------------
  elimexpr   ::= "elim" atom? elimblock ;
  elimblock  ::= "[" elimcases "]" 
               | "with" elimcases "end" ;
  -- First case can omit |, remaining cases require |
  elimcases  ::= elimfirst? elimcase* ;
  elimfirst  ::= elimpat "‚Üí" expr ;
  elimcase   ::= "|" elimpat "‚Üí" expr ;
  elimpat    ::= ident elimpatargs? | "*" ;
  -- Arguments can be: bare ident, or (pattern ‚Üí ih), or (pattern)
  -- The ‚Üí ih binding can be an ident or an expression like m+n
  elimpatargs ::= elimpat* elimpatrec* ;
  elimpatrec ::= "(" elimpat ("‚Üí" ihbinding)? ")" ;
  -- Order matters: try compound forms first before plain ident
  ihbinding  ::= ident "+" ident | ident "-" ident | ident ;
  
  -----------------------------------------------------
  -- Box and Cap (Glue type operations)
  -- box term with | œÜ ‚Üí u end
  -- cap term with | œÜ ‚Üí u end
  -----------------------------------------------------
  boxexpr    ::= "box" projexpr "with" elimcases "end" ;
  capexpr    ::= "cap" projexpr "with" elimcases "end" ;

test "import simple": (import prelude) ;
test "import path": (import prelude path) ;
test "def simple": (def id x x) ;
test "def typed": (def id (x COLON A) COLON A x) ;
