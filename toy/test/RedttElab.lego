-----------------------------------------------------
-- RedttElab: Attribute Grammar for Redtt Elaboration
--
-- Type-checking as Attribute Grammar:
-- - Synthesized (‚Üë): type inference (catamorphism)
-- - Inherited (‚Üì): context propagation (paramorphism)
--
-- Mathematical foundation:
--   check : Œì ‚ä¢ e ‚áê A   (inherited type, check mode)
--   infer : Œì ‚ä¢ e ‚áí A   (synthesized type, infer mode)
--
-- The bidirectional typing discipline maps directly to
-- attribute flow: inh = check, syn = infer.
-----------------------------------------------------

lang RedttElab :=

import Redtt ;

-----------------------------------------------------
-- Core Type Checking Attributes
--
-- Bidirectional typing as attribute flow:
--   Œì ‚ä¢ e ‚áí A  (inference)  ‚Üí syn type
--   Œì ‚ä¢ e ‚áê A  (checking)   ‚Üí inh expected
-----------------------------------------------------

attrs TypeCheck
  -- Inherited: typing context flows down
  inh ctx : Ctx ;
  
  -- Inherited: expected type (check mode)
  inh expected : MaybeTerm ;
  
  -- Synthesized: inferred type flows up
  syn type : Term ;
  
  -- Synthesized: elaborated term flows up
  syn elab : Term ;

  -----------------------------------------------------
  -- Variable: Œì(x) = A  ‚üπ  Œì ‚ä¢ x ‚áí A
  -----------------------------------------------------
  ident.type = (lookupCtx ctx) ;
  ident.elab = (mkVar) ;
  
  -----------------------------------------------------
  -- Lambda: Œì, x:A ‚ä¢ e ‚áí B  ‚üπ  Œì ‚ä¢ Œªx.e ‚áí (x:A) ‚Üí B
  -----------------------------------------------------
  lam.binder.ctx = ctx ;
  lam.body.ctx = (extendCtx ctx) ;
  lam.type = mkPi ;
  lam.elab = mkLam ;
  
  -----------------------------------------------------
  -- Application: Œì ‚ä¢ f ‚áí (x:A) ‚Üí B   Œì ‚ä¢ a ‚áê A
  --              ‚üπ Œì ‚ä¢ f a ‚áí B[a/x]
  -----------------------------------------------------
  appexpr.fn.ctx = ctx ;
  appexpr.arg.ctx = ctx ;
  appexpr.arg.expected = (domainOf fnType) ;
  appexpr.type = (codomain fnType argElab) ;
  appexpr.elab = mkApp ;
  
  -----------------------------------------------------
  -- Pi type: Œì ‚ä¢ A : type^i   Œì, x:A ‚ä¢ B : type^j
  --          ‚üπ Œì ‚ä¢ (x:A) ‚Üí B : type^max(i,j)
  -----------------------------------------------------
  piexpr.dom.ctx = ctx ;
  piexpr.cod.ctx = (extendCtx ctx) ;
  piexpr.type = mkTypeLevel ;
  piexpr.elab = mkPiType ;
  
  -----------------------------------------------------
  -- Universe:  Œì ‚ä¢ type^n : type^(n+1)
  -----------------------------------------------------
  type.type = (mkType (succ level)) ;
  type.elab = (mkType level) ;
  
  -----------------------------------------------------
  -- Let: Œì ‚ä¢ e : A   Œì, x:A ‚ä¢ body ‚áí B
  --      ‚üπ Œì ‚ä¢ let x = e in body ‚áí B
  -----------------------------------------------------
  letin.def.ctx = ctx ;
  letin.body.ctx = (extendCtx ctx) ;
  letin.type = bodyType ;
  letin.elab = mkLet ;

-----------------------------------------------------
-- Cubical-Specific Attributes
-- 
-- Interval ùïÄ and dimension variables need special handling
-----------------------------------------------------

attrs CubicalCheck
  -- Dimension context (separate from term context)
  inh dimctx : DimCtx ;
  
  -- Is this a cofibration constraint?
  syn isCofib : Bool ;
  
  -----------------------------------------------------
  -- Interval type: ùïÄ : IType
  -----------------------------------------------------
  interval.type = IType ;
  interval.elab = Interval ;
  
  -----------------------------------------------------
  -- Path type: [i] A [| i=0 ‚Üí M | i=1 ‚Üí N]
  -----------------------------------------------------
  pathtype.body.dimctx = (extendDim dimctx) ;
  pathtype.body.ctx = ctx ;
  pathtype.left.ctx = ctx ;
  pathtype.right.ctx = ctx ;
  pathtype.type = mkTypeLevel ;
  pathtype.elab = mkPathType ;
  
  -----------------------------------------------------
  -- Coercion: coe r r' a in Œª i ‚Üí A
  -----------------------------------------------------
  coeexpr.src.ctx = ctx ;
  coeexpr.tgt.ctx = ctx ;
  coeexpr.tm.ctx = ctx ;
  coeexpr.line.ctx = ctx ;
  coeexpr.line.dimctx = (extendDim dimctx) ;
  coeexpr.type = (substDim lineType tgt) ;
  coeexpr.elab = mkCoe ;

-----------------------------------------------------
-- Mode Switching (Bidirectional)
-----------------------------------------------------

attrs Bidirectional
  -- Mode: Check vs Infer
  inh mode : Mode ;
  
  -- Check mode: compare against expected
  syn ok : Bool ;
  
  -----------------------------------------------------
  -- Application argument uses check mode
  -----------------------------------------------------
  appexpr.arg.mode = Check ;
  
  -----------------------------------------------------
  -- Annotation switches to check mode
  -----------------------------------------------------
  annotated.tm.mode = Check ;
  annotated.tm.expected = (Some annType) ;
  
  -----------------------------------------------------
  -- Lambda body mode depends on annotation
  -----------------------------------------------------
  lam.body.mode = (modeFromAnnotation) ;

-----------------------------------------------------
-- Tests
-----------------------------------------------------

test "identity": (lam x x) ;
test "const": (lam x (lam y x)) ;

