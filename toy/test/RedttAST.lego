-----------------------------------------------------
-- RedttAST: Redtt grammar with AST annotations
--
-- This version produces structured Terms suitable for:
-- 1. Attribute grammar type checking
-- 2. Conversion to/from Core IR
--
-- Key difference from Redtt.lego:
-- - All productions have â†’ annotations
-- - AST nodes match type rule expectations
-----------------------------------------------------

lang RedttAST :=

-----------------------------------------------------
-- Token: Same as Redtt.lego
-----------------------------------------------------

token Token
  digit  ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;
  lower  ::= 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j'
           | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't'
           | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' ;
  upper  ::= 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J'
           | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T'
           | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' ;
  greek  ::= 'Î±' | 'Î²' | 'Î³' | 'Î´' | 'Îµ' | 'Î¶' | 'Î·' | 'Î¸' | 'Î¹' | 'Îº'
           | 'Î»' | 'Î¼' | 'Î½' | 'Î¾' | 'Î¿' | 'Ï€' | 'Ï' | 'Ïƒ' | 'Ï„' | 'Ï…'
           | 'Ï†' | 'Ï‡' | 'Ïˆ' | 'Ï‰'
           | 'Î‘' | 'Î’' | 'Î“' | 'Î”' | 'Î•' | 'Î–' | 'Î—' | 'Î˜' | 'Î™' | 'Îš'
           | 'Î›' | 'Îœ' | 'Î' | 'Î' | 'ÎŸ' | 'Î ' | 'Î¡' | 'Î£' | 'Î¤' | 'Î¥'
           | 'Î¦' | 'Î§' | 'Î¨' | 'Î©' ;
  mathbb ::= 'ğ•€' | 'ğ”½' | 'ğ•Š' ;
  mathsym ::= 'â‰ˆ' | 'â‰…' | 'â‰¤' | 'â‰¥' | 'âˆ˜' | 'âŠ—' | 'âŠ™' | 'âˆ§' | 'âˆ¨' | 'Â³' ;
  alpha  ::= lower | upper | greek | mathbb | mathsym | '_' ;
  symch  ::= '(' | ')' | '[' | ']' | '{' | '}' | '<' | '>'
           | ':' | ';' | ',' | '.' | '|' | '!' | '?' | '@'
           | '#' | '$' | '%' | '^' | '&' | '*' | '+' | '-'
           | '=' | '~' | '/' | '\\' | 'â†’' | 'â†' | 'â†”' | 'âŠ•'
           | 'âŠ¢' | 'Ã—' | 'Î»' | 'âˆ‚' | 'âˆ€' | 'âˆƒ' | 'â˜…' | 'â˜†'
           | 'â¦‰' | 'â¦Š' | 'Â«' | 'Â»' | '`' ;

  ident   ::= alpha (alpha | digit | '-' | '/' | '\'' | '+')* ;
  number  ::= digit digit* ;
  string  ::= '"' strchar* '"' ;
  strchar ::= '\\' escape | printable ;
  escape  ::= '"' | '\\' | 'n' | 't' | 'r' | '\'' ;
  printable ::= alpha | digit | symch | ' ' ;
  ws      ::= ' ' | '\t' | '\n' | '\r' ;
  comment ::= '-' '-' nonnl* ;
  nonnl   ::= alpha | digit | symch | ' ' | '\t' | '\'' | '"' ;
  sym     ::= symch ;

-----------------------------------------------------
-- File Structure (with AST annotations)
-----------------------------------------------------
piece File
  file       ::= topdecl* â†’ file ;
  topdecl    ::= importdecl â†’ import
               | defndecl â†’ defn
               | datadecl â†’ data
               | "opaque" â†’ opaque ;

-----------------------------------------------------
-- Imports
-----------------------------------------------------
piece Imports
  importdecl ::= "public"? "import" modulepath â†’ import ;
  modulepath ::= name ("." name)* â†’ path ;
  name       ::= ident â†’ name ;

-----------------------------------------------------
-- Definitions (produce structured def nodes)
-----------------------------------------------------
piece Definitions
  defndecl   ::= "def" defname defargs ":" expr "=" expr â†’ def
               | "def" defname defargs "=" expr â†’ defInfer
               | "opaque" "def" defname defargs ":" expr "=" expr â†’ opaqueDef
               | "private" "def" defname defargs ":" expr "=" expr â†’ privateDef ;
  defname    ::= ident â†’ name ;
  defargs    ::= defarg* â†’ args ;
  defarg     ::= "(" ident+ ":" expr ")" â†’ typedArg
               | ident â†’ simpleArg ;

-----------------------------------------------------
-- Expressions (all annotated for AST production)
-----------------------------------------------------
piece Expr
  expr       ::= lam | letin | coeexpr | hcomexpr | piexpr | sigmaexpr | arrowexpr | appexpr ;

-----------------------------------------------------
-- Lambda (produces lam nodes)
-----------------------------------------------------
piece Lambda
  lam        ::= "Î»" binders "â†’" expr â†’ lam ;
  binders    ::= binder+ â†’ binders ;
  binder     ::= "(" ident+ ":" expr ")" â†’ typedBinder
               | ident â†’ simpleBinder
               | "_" â†’ wildcard
               | "*" â†’ star ;

-----------------------------------------------------
-- Let (produces let nodes)
-----------------------------------------------------
piece Let
  letin      ::= "let" ident binders? (":" expr)? "=" expr "in" expr â†’ let ;

-----------------------------------------------------
-- Pi and Sigma Types (produce Pi/Sigma nodes)
-----------------------------------------------------
piece Types
  piexpr     ::= picell+ "â†’" expr â†’ Pi ;
  picell     ::= "(" ident+ ":" expr ")" â†’ cell ;
  sigmaexpr  ::= "(" ident ":" expr ")" "Ã—" expr â†’ Sigma ;
  arrowexpr  ::= appexpr "â†’" expr â†’ Arrow
               | appexpr "Ã—" expr â†’ Prod
               | appexpr ;

-----------------------------------------------------
-- Application (produces app nodes)
-----------------------------------------------------
piece Application
  appexpr    ::= atom apparg* â†’ app ;
  apparg     ::= projsuffix â†’ proj
               | atom â†’ arg ;
  projsuffix ::= "." ident â†’ field
               | "^" number â†’ level ;

-----------------------------------------------------
-- Atomic Expressions (all produce specific nodes)
-----------------------------------------------------
piece Atoms
  atom       ::= "(" expr ")" â†’ paren
               | pair â†’ pair
               | pathtype â†’ pathType
               -- Universes
               | "type" "^" number â†’ typeLevel
               | "type" â†’ type
               | "ğ•€" â†’ interval
               -- Path operations
               | "refl" â†’ refl
               | "path" projexpr projexpr projexpr â†’ path
               | "pathd" projexpr projexpr projexpr â†’ pathd
               -- Coercion
               | "coe" projexpr projexpr projexpr "in" expr â†’ coe
               -- Composition
               | "hcom" projexpr projexpr projexpr "in" expr constraints â†’ hcom
               | "comp" projexpr projexpr projexpr "in" expr constraints â†’ comp
               -- Glue types
               | "Glue" â†’ Glue
               | "glue" â†’ glue
               | "unglue" â†’ unglue
               -- V-types
               | "V" projexpr projexpr projexpr projexpr â†’ Vtype
               | "Vin" projexpr projexpr projexpr projexpr â†’ Vin
               | "Vproj" projexpr projexpr projexpr projexpr â†’ Vproj
               -- Circle
               | "S1" â†’ circle
               | "base" â†’ base
               | "loop" â†’ loop
               -- Natural numbers
               | "nat" â†’ nat
               | "zero" â†’ zero
               | "suc" â†’ suc
               -- Eliminators
               | "elim" atom "with" elimcases "end" â†’ elim
               -- Hole
               | "?" ident â†’ namedHole
               | "?" â†’ hole
               -- Literals
               | number â†’ num
               | ident â†’ var ;

  pair       ::= "(" expr ("," expr)+ ")" â†’ pair ;
  projexpr   ::= atom projsuffix* â†’ proj ;

-----------------------------------------------------
-- Path Types (extension types)
-----------------------------------------------------
piece PathTypes
  pathtype   ::= "[" dimvars "]" arrowexpr constraints? â†’ pathAbs ;
  dimvars    ::= ident+ â†’ dims ;
  constraints ::= "[" "|"? cofibclause ("|" cofibclause)* "]" â†’ sys ;
  cofibclause ::= face "â†’" expr â†’ face ;
  face       ::= ident "=" dimexpr â†’ eq ;
  dimexpr    ::= number â†’ dim
               | ident â†’ dimVar ;

-----------------------------------------------------
-- Cubical Operations
-----------------------------------------------------
piece Cubical
  coeexpr    ::= "coe" projexpr projexpr projexpr "in" expr â†’ coe ;
  hcomexpr   ::= "hcom" projexpr projexpr projexpr "in" expr constraints â†’ hcom ;

-----------------------------------------------------
-- Eliminators
-----------------------------------------------------
piece Elim
  elimcases  ::= elimcase* â†’ cases ;
  elimcase   ::= "|" ident elimargs "â†’" expr â†’ case ;
  elimargs   ::= elimarg* â†’ args ;
  elimarg    ::= "(" ident ":" expr ")" â†’ typedArg
               | ident â†’ simpleArg ;

-----------------------------------------------------
-- Data Types
-----------------------------------------------------
piece DataTypes
  datadecl   ::= "data" dataparams? ident "where" datacons â†’ data ;
  dataparams ::= picell+ "âŠ¢" â†’ params ;
  datacons   ::= datacon* â†’ cons ;
  datacon    ::= "|" ident dataconargs constraints? â†’ con ;
  dataconargs ::= dataconarg* â†’ args ;
  dataconarg ::= "(" ident+ ":" expr ")" â†’ arg ;

