-- MetaGrammar.lego: Grammar as a Functor Coproduct
--
-- Structure: Language = ⊔ Pieces (pushout chain)
-- GrammarExpr = Fix (ExprF :+: KleeneF :+: BindF :+: AnyF)

lang MetaGrammar :=

-- =============================================================================
-- PIECE 1: ExprF (Base Expressions)
-- =============================================================================

piece ExprF
  exprf ::= evar | econ | elit | esyn

  evar ::= "(" "EVar" <ident> ")"
  econ ::= "(" "ECon" <ident> gexpr* ")"
  elit ::= "(" "ELit" <string> ")"
  esyn ::= "(" "ESyn" <ident> ")"

  rule con_nullary:
    (ECon $c) <~> (ESyn $c)

  law "con_nullary": (ECon $c) == (ESyn $c)

  test "evar": (EVar x)
  test "econ": (ECon app (EVar f) (EVar x))
  test "elit": (ELit "hello")
  test "esyn": (ESyn lam)

-- =============================================================================
-- PIECE 2: KleeneF (Kleene Algebra)
-- =============================================================================

piece KleeneF
  kleenef ::= kempty | kseq | kalt | kstar

  kempty ::= "(" "KEmpty" ")"
  kseq   ::= "(" "KSeq" gexpr gexpr ")"
  kalt   ::= "(" "KAlt" gexpr gexpr ")"
  kstar  ::= "(" "KStar" gexpr ")"

  rule seq_identity_left:
    (KSeq (KEmpty) $g) <~> $g

  rule seq_identity_right:
    (KSeq $g (KEmpty)) <~> $g

  rule seq_assoc:
    (KSeq (KSeq $a $b) $c) <~> (KSeq $a (KSeq $b $c))

  rule alt_identity:
    (KAlt (KEmpty) $g) <~> $g

  rule alt_assoc:
    (KAlt (KAlt $a $b) $c) <~> (KAlt $a (KAlt $b $c))

  rule alt_comm:
    (KAlt $a $b) <~> (KAlt $b $a)

  rule alt_idem:
    (KAlt $a $a) <~> $a

  rule dist_left:
    (KSeq $a (KAlt $b $c)) <~> (KAlt (KSeq $a $b) (KSeq $a $c))

  rule dist_right:
    (KSeq (KAlt $a $b) $c) <~> (KAlt (KSeq $a $c) (KSeq $b $c))

  rule star_unfold:
    (KStar $g) <~> (KAlt (KSeq $g (KStar $g)) (KEmpty))

  rule star_empty:
    (KStar (KEmpty)) <~> (KEmpty)

  rule star_idem:
    (KStar (KStar $g)) <~> (KStar $g)

  law "kseq_assoc": (KSeq (KSeq $a $b) $c) == (KSeq $a (KSeq $b $c))
  law "kseq_unit_l": (KSeq (KEmpty) $g) == $g
  law "kseq_unit_r": (KSeq $g (KEmpty)) == $g
  law "kalt_assoc": (KAlt (KAlt $a $b) $c) == (KAlt $a (KAlt $b $c))
  law "kalt_comm": (KAlt $a $b) == (KAlt $b $a)
  law "kalt_idem": (KAlt $a $a) == $a
  law "dist_l": (KSeq $a (KAlt $b $c)) == (KAlt (KSeq $a $b) (KSeq $a $c))
  law "dist_r": (KSeq (KAlt $a $b) $c) == (KAlt (KSeq $a $c) (KSeq $b $c))
  law "star_unfold": (KStar $g) == (KAlt (KSeq $g (KStar $g)) (KEmpty))
  law "star_idem": (KStar (KStar $g)) == (KStar $g)

  test "kempty": (KEmpty)
  test "kseq": (KSeq (ELit "a") (ELit "b"))
  test "kalt": (KAlt (ELit "true") (ELit "false"))
  test "kstar": (KStar (ELit "a"))

-- =============================================================================
-- PIECE 3: KleeneDerived (Sugar)
-- =============================================================================

piece KleeneDerived
  kleenederiv ::= kplus | kopt

  kplus ::= "(" "KPlus" gexpr ")"
  kopt  ::= "(" "KOpt" gexpr ")"

  rule plus_unfold:
    (KPlus $g) <~> (KSeq $g (KStar $g))

  rule opt_unfold:
    (KOpt $g) <~> (KAlt $g (KEmpty))

  law "plus_def": (KPlus $g) == (KSeq $g (KStar $g))
  law "opt_def": (KOpt $g) == (KAlt $g (KEmpty))

  test "kplus": (KPlus (ELit "a"))
  test "kopt": (KOpt (ELit "a"))

-- =============================================================================
-- PIECE 4: BindF (Binding and Recursion)
-- =============================================================================

piece BindF
  bindf ::= brec | bref | bbind

  brec  ::= "(" "BRec" <ident> gexpr ")"
  bref  ::= "(" "BRef" <ident> ")"
  bbind ::= "(" "BBind" <ident> gexpr ")"

  rule mu_unfold:
    (BRec $x $body) <~> (subst $x (BRec $x $body) $body)

  law "mu_unfold": (BRec $x $g) == (subst $x (BRec $x $g) $g)

  test "brec": (BRec X (KAlt (KSeq (ELit "a") (BRef X)) (KEmpty)))
  test "bref": (BRef foo)
  test "bbind": (BBind x (EVar ident))

-- =============================================================================
-- PIECE 5: AnyF (Wildcard)
-- =============================================================================

piece AnyF
  anyf ::= eany

  eany ::= "(" "EAny" ")"

  test "eany": (EAny)

-- =============================================================================
-- PIECE 6: Fix (Fixed Point)
-- =============================================================================

piece Fix
  gexpr ::= exprf | kleenef | kleenederiv | bindf | anyf | fixf

  fixf   ::= gfix | gunfix | inl | inr
  gfix   ::= "(" "Fix" gexpr ")"
  gunfix ::= "(" "unFix" gexpr ")"
  inl    ::= "(" "InL" gexpr ")"
  inr    ::= "(" "InR" gexpr ")"

  rule fix_unfix:
    (unFix (Fix $g)) <~> $g

  rule unfix_fix:
    (Fix (unFix $g)) <~> $g

  law "fix_iso": (unFix (Fix $g)) == $g

  test "gfix": (Fix (EVar x))
  test "gunfix": (unFix (Fix (EVar x)))
  test "inl": (InL (EVar x))
  test "inr": (InR (KStar (ELit "a")))
  test "gexpr_var": (EVar x)
  test "gexpr_seq": (KSeq (ELit "a") (ELit "b"))
  test "gexpr_star": (KStar (EVar term))
  test "gexpr_rec": (BRec list (KAlt (KSeq (EVar elem) (BRef list)) (KEmpty)))

-- =============================================================================
-- PIECE 7: Lambda Grammar Example
-- =============================================================================
-- Using MetaGrammar to define a minimal lambda calculus.

piece LambdaExample
  lamGrammar ::= "(" "LamGrammar" <ident> gexpr ")"
  parseResult ::= "(" "Parsed" <ident> gexpr ")"

  test "lam_var_grammar": (LamGrammar var (EVar ident))

  test "lam_lam_grammar": (LamGrammar lam 
    (KSeq (ELit "(") (KSeq (ELit "lam") (KSeq (EVar ident) (KSeq (EVar expr) (ELit ")"))))))

  test "lam_app_grammar": (LamGrammar app
    (KSeq (ELit "(") (KSeq (EVar expr) (KSeq (EVar expr) (ELit ")")))))

  test "lam_expr_grammar": (LamGrammar expr
    (KAlt (EVar var) (KAlt (EVar lam) (EVar app))))

-- =============================================================================
-- PIECE 8: Eval Example
-- =============================================================================

piece EvalExample
  evalResult ::= "(" "Eval" gexpr gexpr ")"

  test "eval_var": (Eval (EVar x) (EVar x))
  
  test "eval_lam": (Eval (ECon lam x (EVar x)) (ECon lam x (EVar x)))
  
  test "eval_app_id": (Eval (ECon app (ECon lam x (EVar x)) (EVar y)) (EVar y))

  test "eval_app_const": (Eval 
    (ECon app (ECon app (ECon lam x (ECon lam y (EVar x))) (EVar a)) (EVar b))
    (EVar a))

-- =============================================================================
-- GLOBAL LAWS
-- =============================================================================

-- The full algebra: GrammarExpr = Fix (ExprF :+: KleeneF :+: BindF :+: AnyF)

-- =============================================================================
-- INTERPRETER TESTS: Grammar Expressions
-- =============================================================================

-- Complete grammar for lambda calculus
test "interp_full_lambda": (LamGrammar expr
  (KAlt (EVar ident)
        (KAlt (KSeq (ELit "(") (KSeq (ELit "lam") (KSeq (EVar ident) (KSeq (EVar expr) (ELit ")")))))
              (KSeq (ELit "(") (KSeq (EVar expr) (KSeq (EVar expr) (ELit ")")))))))

-- Recursive list grammar: list ::= elem list | empty
test "interp_list_grammar": (BRec list 
  (KAlt (KSeq (EVar elem) (BRef list)) (KEmpty)))

-- Kleene star for argument lists
test "interp_args": (KStar (KSeq (EVar arg) (KOpt (ELit ","))))

-- Church numerals as grammar terms
test "interp_church_zero": (ECon lam f (ECon lam x (EVar x)))

test "interp_church_succ": (ECon lam n 
  (ECon lam f 
    (ECon lam x 
      (ECon app (EVar f) 
        (ECon app (ECon app (EVar n) (EVar f)) (EVar x))))))

-- Fibonacci: recursive grammar pattern
test "interp_fib_pattern": (BRec fib 
  (KAlt (ELit "0")
        (KAlt (ELit "1") 
              (KSeq (BRef fib) (KSeq (ELit "+") (BRef fib))))))

-- Factorial: recursive pattern
test "interp_fact_pattern": (BRec fact
  (KAlt (KSeq (ELit "1") (KEmpty))
        (KSeq (EVar n) (KSeq (ELit "*") (BRef fact)))))

-- Parse result example
test "interp_parsed_id": (Parsed identity (ECon lam x (EVar x)))

-- Eval result example  
test "interp_evaled_K": (Eval 
  (ECon app (ECon lam x (ECon lam y (EVar x))) (EVar a))
  (ECon lam y (EVar a)))

-- =============================================================================
-- MATHEMATICAL FOUNDATION
-- =============================================================================
--
-- MetaGrammar = ExprF ⊕ KleeneF ⊕ KleeneDerived ⊕ BindF ⊕ AnyF ⊕ Fix
--             ⊕ LambdaExample ⊕ EvalExample
--
-- Key insight: MetaGrammar is SELF-HOSTING.
-- We define lambda calculus grammar IN MetaGrammar,
-- then use that grammar to parse/eval lambda expressions.
-- The same BiReducer structure handles grammar and evaluation!
--
-- =============================================================================
